{"title":"[转]写好JavaScript条件语句的5条守则","uid":"4ed54b66406825cfd09b4a09d07c0870","slug":"写好JavaScript条件语句的5条守则(转)","date":"2019-03-28T06:21:57.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/写好JavaScript条件语句的5条守则(转).json","keywords":null,"cover":null,"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>原文地址：<a href=\"https://scotch.io/bar-talk/5-tips-to-write-better-conditionals-in-javascript#toc-3-use-default-function-parameters-and-destructuring\">5 Tips to Write Better Conditionals in JavaScript</a></li>\n<li>原文作者：<a href=\"https://scotch.io/@jecelyn\">ecelyn Yeen</a><a href=\"https://twitter.com/jecelynyeen\">(@jecelynyeen)</a></li>\n<li>译文出自：<a href=\"https://github.com/dawn-teams/translate\">阿里云翻译小组</a></li>\n<li>译文链接：<a href=\"https://github.com/dawn-teams/translate/blob/master/articles/5-Tips-to-Write-Better-Conditionals-in-JavaScript.md\">https://github.com/dawn-teams/translate/blob/master/articles/5-Tips-to-Write-Better-Conditionals-in-JavaScript.md</a></li>\n<li>译者：<a href=\"https://github.com/JeromeYangtao\">眠云(杨涛)</a></li>\n<li>校对者：<a href=\"https://github.com/xdlrt\">也树</a>，<a href=\"https://github.com/Mcskiller\">Mcskiller</a></li>\n</ul></blockquote>\n<hr>\n<h1 id=\"写好JavaScript条件语句的5条守则\"><a href=\"#写好JavaScript条件语句的5条守则\" class=\"headerlink\" title=\"写好JavaScript条件语句的5条守则\"></a>写好JavaScript条件语句的5条守则</h1><p>在用 JavaScript 工作时，我们经常和条件语句打交道，这里有5条让你写出更好/干净的条件语句的建议。</p>\n<p>1.多重判断时使用 Array.includes</p>\n<p>2.更少的嵌套，尽早 return</p>\n<p>3.使用默认参数和解构</p>\n<p>4.倾向于遍历对象而不是 Switch 语句</p>\n<p>5.对 所有/部分 判断使用 Array.every &amp; Array.some</p>\n<p>6.总结</p>\n<h3 id=\"1-多重判断时使用-Array-includes\"><a href=\"#1-多重判断时使用-Array-includes\" class=\"headerlink\" title=\"1.多重判断时使用 Array.includes\"></a>1.多重判断时使用 Array.includes</h3><p>让我们看一下下面这个例子:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; condition\nfunction test(fruit) &#123;\n  if (fruit &#x3D;&#x3D; &#39;apple&#39; || fruit &#x3D;&#x3D; &#39;strawberry&#39;) &#123;\n    console.log(&#39;red&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>第一眼，上面这个例子看起来没问题。如果我们有更多名字叫 <code>cherry</code> 和 <code>cranberries</code> 的红色水果呢？我们准备用更多的 <code>||</code> 来拓展条件语句吗？</p>\n<p>我们可以用 <code>Array.includes</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes\">(Array.includes)</a>重写条件语句。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function test(fruit) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  if (redFruits.includes(fruit)) &#123;\n    console.log(&#39;red&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>我们把<code>红色的水果(red fruits)</code>这一判断条件提取到一个数组。这样一来，代码看起来更整洁。</p>\n<h3 id=\"2-更少的嵌套，尽早-Return\"><a href=\"#2-更少的嵌套，尽早-Return\" class=\"headerlink\" title=\"2.更少的嵌套，尽早 Return\"></a>2.更少的嵌套，尽早 Return</h3><p>让我们拓展上一个例子让它包含两个条件。</p>\n<ul>\n<li>如果没有传入参数 fruit，抛出错误</li>\n<li>接受 quantity 参数，并且在 quantity 大于 10 时打印出来</li>\n</ul>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function test(fruit, quantity) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  &#x2F;&#x2F; 条件 1: fruit 必须有值\n  if (fruit) &#123;\n    &#x2F;&#x2F; 条件 2: 必须是red的\n    if (redFruits.includes(fruit)) &#123;\n      console.log(&#39;red&#39;);\n\n      &#x2F;&#x2F; 条件 3: quantity大于10\n      if (quantity &gt; 10) &#123;\n        console.log(&#39;big quantity&#39;);\n      &#125;\n    &#125;\n  &#125; else &#123;\n    throw new Error(&#39;No fruit!&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 测试结果\ntest(null); &#x2F;&#x2F; error: No fruits\ntest(&#39;apple&#39;); &#x2F;&#x2F; print: red\ntest(&#39;apple&#39;, 20); &#x2F;&#x2F; print: red, big quantity</code></pre>\n\n<p>在上面的代码, 我们有:</p>\n<ul>\n<li>1个 if/else 语句筛选出无效的语句</li>\n<li>3层if嵌套语句 (条件 1, 2 &amp; 3)</li>\n</ul>\n<p>我个人遵循的规则一般是在发现无效条件时，<strong>尽早Return</strong>。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;_ 当发现无效语句时，尽早Return _&#x2F;\n\nfunction test(fruit, quantity) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  &#x2F;&#x2F; 条件 1: 尽早抛出错误\n  if (!fruit) throw new Error(&#39;No fruit!&#39;);\n\n  &#x2F;&#x2F; 条件 2: 必须是红色的\n  if (redFruits.includes(fruit)) &#123;\n    console.log(&#39;red&#39;);\n\n    &#x2F;&#x2F; 条件 3: 必须是大质量的\n    if (quantity &gt; 10) &#123;\n      console.log(&#39;big quantity&#39;);\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n\n<p>这样一来，我们少了一层嵌套语句。这种编码风格非常好，尤其是当你有很长的if语句的时候(想象你需要滚动到最底层才知道还有else语句，这并不酷)</p>\n<p>我们可以通过 倒置判断条件 &amp; 尽早return 进一步减少if嵌套。看下面我们是怎么处理判断 条件2 的: </p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;_ 当发现无效语句时，尽早Return _&#x2F;\n\nfunction test(fruit, quantity) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  &#x2F;&#x2F; 条件 1: 尽早抛出错误\n  if (!fruit) throw new Error(&#39;No fruit!&#39;);\n  &#x2F;&#x2F; 条件 2: 当水果不是红色时停止继续执行\n  if (!redFruits.includes(fruit)) return; \n\n  console.log(&#39;red&#39;);\n\n  &#x2F;&#x2F; 条件 3: 必须是大质量的\n  if (quantity &gt; 10) &#123;\n    console.log(&#39;big quantity&#39;);\n  &#125;\n&#125;</code></pre>\n\n<p>通过倒置判断条件2，我们的代码避免了嵌套语句。这个技巧在我们需要进行很长的逻辑判断时是非常有用的，特别是我们希望能够在条件不满足时能够停止下来进行处理。</p>\n<p>而且这么做并不困难。问问自己，这个版本(没有嵌套)是不是比之前的(两层条件嵌套)更好，可读性更高？</p>\n<p>但对于我，我会保留先前的版本(包含两层嵌套)。这是因为:</p>\n<ul>\n<li>代码比较短且直接，包含if嵌套的更清晰</li>\n<li>倒置判断条件可能加重思考的负担(增加认知载荷)</li>\n</ul>\n<p>因此，应当<strong>尽力减少嵌套和尽早return，但不要过度</strong>。如果你感兴趣的话，可以看一下关于这个话题的一篇文章和 StackOverflow 上的讨论。</p>\n<ul>\n<li><a href=\"http://blog.timoxley.com/post/47041269194/avoid-else-return-early\">Avoid Else, Return Early</a> by Tim Oxley</li>\n<li><a href=\"https://softwareengineering.stackexchange.com/questions/18454/should-i-return-from-a-function-early-or-use-an-if-statement\">StackOverflow discussion</a> on if/else coding style</li>\n</ul>\n<h3 id=\"3-使用默认参数和解构\"><a href=\"#3-使用默认参数和解构\" class=\"headerlink\" title=\"3.使用默认参数和解构\"></a>3.使用默认参数和解构</h3><p>我猜下面的代码你可能会熟悉，在JavaScript中我们总是需要检查 <code>null</code> / <code>undefined</code>的值和指定默认值:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function test(fruit, quantity) &#123;\n  if (!fruit) return;\n  &#x2F;&#x2F; 如果 quantity 参数没有传入，设置默认值为 1\n  const q &#x3D; quantity || 1; \n\n  console.log(&#96;We have $&#123;q&#125; $&#123;fruit&#125;!&#96;);\n&#125;\n\n&#x2F;&#x2F;test results\ntest(&#39;banana&#39;); &#x2F;&#x2F; We have 1 banana!\ntest(&#39;apple&#39;, 2); &#x2F;&#x2F; We have 2 apple!</code></pre>\n\n<p>实际上，我们可以通过声明 默认函数参数 来消除变量 q。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function test(fruit, quantity &#x3D; 1) &#123;\n  &#x2F;&#x2F; 如果 quantity 参数没有传入，设置默认值为 1\n  if (!fruit) return;\n  console.log(&#96;We have $&#123;quantity&#125; $&#123;fruit&#125;!&#96;);\n&#125;\n\n&#x2F;&#x2F;test results\ntest(&#39;banana&#39;); &#x2F;&#x2F; We have 1 banana!\ntest(&#39;apple&#39;, 2); &#x2F;&#x2F; We have 2 apple!</code></pre>\n\n<p>这更加直观，不是吗？注意，每个声明都有自己的<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters\">默认参数</a>.</p>\n<p>例如，我们也能给<code>fruit</code>分配默认值:<code>function test(fruit = &#39;unknown&#39;, quantity = 1)</code>。</p>\n<p>如果<code>fruit</code>是一个object会怎么样？我们能分配一个默认参数吗？</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function test(fruit) &#123; \n  &#x2F;&#x2F; 当值存在时打印 fruit 的值\n  if (fruit &amp;&amp; fruit.name)  &#123;\n    console.log (fruit.name);\n  &#125; else &#123;\n    console.log(&#39;unknown&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F;test results\ntest(undefined); &#x2F;&#x2F; unknown\ntest(&#123; &#125;); &#x2F;&#x2F; unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); &#x2F;&#x2F; apple</code></pre>\n\n<p>看上面这个例子，我们想打印 fruit 对象中可能存在的 name 属性。否则我们将打印unknown。我们可以通过默认参数以及解构从而避免判断条件 <code>fruit &amp;&amp; fruit.name</code></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 解构 - 仅仅获取 name 属性\n&#x2F;&#x2F; 为其赋默认值为空对象\nfunction test(&#123;name&#125; &#x3D; &#123;&#125;) &#123;\n  console.log (name || &#39;unknown&#39;);\n&#125;\n\n&#x2F;&#x2F; test results\ntest(undefined); &#x2F;&#x2F; unknown\ntest(&#123; &#125;); &#x2F;&#x2F; unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); &#x2F;&#x2F; apple</code></pre>\n\n<p>由于我们只需要 <code>name</code> 属性，我们可以用 <code>&#123;name&#125;</code> 解构出参数，然后我们就能使用变量 <code>name</code> 代替 <code>fruit.name</code>。</p>\n<p>我们也需要声明空对象 <code>&#123;&#125;</code> 作为默认值。如果我们不这么做，当执行 <code>test(undefined)</code> 时，你将得到一个无法对 undefined 或 null 解构的的错误。因为在 undefined 中没有 <code>name</code> 属性。</p>\n<p>如果你不介意使用第三方库，这有一些方式减少null的检查:</p>\n<ul>\n<li>使用 <a href=\"https://lodash.com/docs/4.17.10#get\">Lodash get</a>函数</li>\n<li>使用Facebook开源的<a href=\"https://github.com/facebookincubator/idx\">idx</a>库(with Babeljs)</li>\n</ul>\n<p>这是一个使用Lodash的例子:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function test(fruit) &#123;\n  &#x2F;&#x2F; 获取属性名，如果属性名不可用，赋默认值为 unknown\n  console.log(__.get(fruit, &#39;name&#39;, &#39;unknown&#39;); \n&#125;\n\n&#x2F;&#x2F; test results\ntest(undefined); &#x2F;&#x2F; unknown\ntest(&#123; &#125;); &#x2F;&#x2F; unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); &#x2F;&#x2F; apple</code></pre>\n\n<p>你可以在<a href=\"http://jsbin.com/bopovajiye/edit?js,console\">jsbin</a>运行demo代码。除此之外，如果你是函数式编程的粉丝，你可能选择使用 <a href=\"https://github.com/lodash/lodash/wiki/FP-Guide\">Lodash fp</a>，Lodash的函数式版本(方法变更为<code>get</code>或者<code>getOr</code>)。</p>\n<h3 id=\"4-倾向于对象遍历而不是Switch语句\"><a href=\"#4-倾向于对象遍历而不是Switch语句\" class=\"headerlink\" title=\"4.倾向于对象遍历而不是Switch语句\"></a>4.倾向于对象遍历而不是Switch语句</h3><p>让我们看下面这个例子，我们想根据 color 打印出水果:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">function test(color) &#123;\n  &#x2F;&#x2F; 使用条件语句来寻找对应颜色的水果\n  switch (color) &#123;\n    case &#39;red&#39;:\n      return [&#39;apple&#39;, &#39;strawberry&#39;];\n    case &#39;yellow&#39;:\n      return [&#39;banana&#39;, &#39;pineapple&#39;];\n    case &#39;purple&#39;:\n      return [&#39;grape&#39;, &#39;plum&#39;];\n    default:\n      return [];\n  &#125;\n&#125;\n\n&#x2F;&#x2F; test results\ntest(null); &#x2F;&#x2F; []\ntest(&#39;yellow&#39;); &#x2F;&#x2F; [&#39;banana&#39;, &#39;pineapple&#39;]</code></pre>\n\n<p>上面的代码看起来没有错误，但是我找到了一些累赘。用对象遍历实现相同的结果，语法看起来更简洁:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const fruitColor &#x3D; &#123;\n  red: [&#39;apple&#39;, &#39;strawberry&#39;],\n  yellow: [&#39;banana&#39;, &#39;pineapple&#39;],\n  purple: [&#39;grape&#39;, &#39;plum&#39;]\n&#125;;\n\nfunction test(color) &#123;\n  return fruitColor[color] || [];\n&#125;</code></pre>\n\n<p>或者你也可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map</a>实现相同的结果:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">  const fruitColor &#x3D; new Map()\n    .set(&#39;red&#39;, [&#39;apple&#39;, &#39;strawberry&#39;])\n    .set(&#39;yellow&#39;, [&#39;banana&#39;, &#39;pineapple&#39;])\n    .set(&#39;purple&#39;, [&#39;grape&#39;, &#39;plum&#39;]);\n\nfunction test(color) &#123;\n  return fruitColor.get(color) || [];\n&#125;</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">Map</a>是一种在 ES2015 规范之后实现的对象类型，允许你存储 key 和 value 的值。</p>\n<p>但我们是否应当禁止switch语句的使用呢？答案是不要限制你自己。从个人来说，我会尽可能的使用对象遍历，但我并不严格遵守它，而是使用对当前的场景更有意义的方式。</p>\n<p>Todd Motto有一篇关于 switch 语句对比对象遍历的更深入的文章，你可以在<a href=\"https://toddmotto.com/deprecating-the-switch-statement-for-object-literals/\">这个地方</a>阅读</p>\n<h3 id=\"TL-DR-重构语法\"><a href=\"#TL-DR-重构语法\" class=\"headerlink\" title=\"TL;DR; 重构语法\"></a>TL;DR; 重构语法</h3><p>在上面的例子，我们能够用<code>Array.filter</code> 重构我们的代码，实现相同的效果。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\"> const fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;, \n    &#123; name: &#39;strawberry&#39;, color: &#39;red&#39; &#125;, \n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;, \n    &#123; name: &#39;pineapple&#39;, color: &#39;yellow&#39; &#125;, \n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;, \n    &#123; name: &#39;plum&#39;, color: &#39;purple&#39; &#125;\n];\n\nfunction test(color) &#123;\n  return fruits.filter(f &#x3D;&gt; f.color &#x3D;&#x3D; color);\n&#125;</code></pre>\n\n<p>有着不止一种方法能够实现相同的结果，我们以上展示了 4 种。</p>\n<h3 id=\"5-对-所有-部分-判断使用Array-every-amp-Array-some\"><a href=\"#5-对-所有-部分-判断使用Array-every-amp-Array-some\" class=\"headerlink\" title=\"5.对 所有/部分 判断使用Array.every &amp; Array.some\"></a>5.对 所有/部分 判断使用Array.every &amp; Array.some</h3><p>这最后一个建议更多是关于利用 JavaScript Array 的内置方法来减少代码行数。看下面的代码，我们想要检查是否所有水果都是红色:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n  ];\n\nfunction test() &#123;\n  let isAllRed &#x3D; true;\n\n  &#x2F;&#x2F; 条件：所有水果都是红色\n  for (let f of fruits) &#123;\n    if (!isAllRed) break;\n    isAllRed &#x3D; (f.color &#x3D;&#x3D; &#39;red&#39;);\n  &#125;\n\n  console.log(isAllRed); &#x2F;&#x2F; false\n&#125;</code></pre>\n\n<p>代码那么长！我们可以通过 <code>Array.every</code>减少代码行数:</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n  ];\n\nfunction test() &#123;\n  const isAllRed &#x3D; fruits.every(f &#x3D;&gt; f.color &#x3D;&#x3D; &#39;red&#39;);\n\n  console.log(isAllRed); &#x2F;&#x2F; false\n&#125;</code></pre>\n\n<p>现在更简洁了，不是吗？相同的方式，如果我们想测试是否存在红色的水果，我们可以使用 <code>Array.some</code> 一行代码实现。</p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">const fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n];\n\nfunction test() &#123;\n  &#x2F;&#x2F; 条件：任何一个水果是红色\n  const isAnyRed &#x3D; fruits.some(f &#x3D;&gt; f.color &#x3D;&#x3D; &#39;red&#39;);\n\n  console.log(isAnyRed); &#x2F;&#x2F; true\n&#125;</code></pre>\n\n<h3 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6.总结\"></a>6.总结</h3><p>让我们一起生产更多可读性高的代码。我希望你能从这篇文章学到东西。</p>\n<p>这就是所有的内容。编码快乐！</p>\n","text":" 原文地址：5 Tips to Write Better Conditionals in JavaScript 原文作者：ecelyn Yeen(@jecelynyeen) 译文出自：阿里云翻译小组 译文链接：https://github.com/dawn-teams/trans...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"js","slug":"js","count":4,"path":"api/categories/js.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%A5%BDJavaScript%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E7%9A%845%E6%9D%A1%E5%AE%88%E5%88%99\"><span class=\"toc-text\">写好JavaScript条件语句的5条守则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%A4%9A%E9%87%8D%E5%88%A4%E6%96%AD%E6%97%B6%E4%BD%BF%E7%94%A8-Array-includes\"><span class=\"toc-text\">1.多重判断时使用 Array.includes</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9B%B4%E5%B0%91%E7%9A%84%E5%B5%8C%E5%A5%97%EF%BC%8C%E5%B0%BD%E6%97%A9-Return\"><span class=\"toc-text\">2.更少的嵌套，尽早 Return</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E8%A7%A3%E6%9E%84\"><span class=\"toc-text\">3.使用默认参数和解构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%80%BE%E5%90%91%E4%BA%8E%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86%E8%80%8C%E4%B8%8D%E6%98%AFSwitch%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">4.倾向于对象遍历而不是Switch语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TL-DR-%E9%87%8D%E6%9E%84%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">TL;DR; 重构语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%AF%B9-%E6%89%80%E6%9C%89-%E9%83%A8%E5%88%86-%E5%88%A4%E6%96%AD%E4%BD%BF%E7%94%A8Array-every-amp-Array-some\"><span class=\"toc-text\">5.对 所有&#x2F;部分 判断使用Array.every &amp; Array.some</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6.总结</span></a></li></ol></li></ol></li></ol>","author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaScript工作原理之事件循环和基础的异步实现","uid":"043f9cbe38a0b25b8b616d2a4ca463e9","slug":"JavaScript工作原理之事件循环和基础的异步实现","date":"2019-03-28T06:22:44.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/JavaScript工作原理之事件循环和基础的异步实现.json","keywords":null,"cover":[],"text":"事件循环 常规的JavaScript引擎是单线程的，也就是说所有的代码块都是顺序按照顺序被执行，这就导致遇到处理慢的代码块会阻塞软件的运行，甚至使程序停止响应，通常解决方案是使用异步来处理，把需要时间处理的代码块异步的进行处理，后面的块则继续执行，等到该代码块处理完以后再回过头来...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"js","slug":"js","count":4,"path":"api/categories/js.json"}],"tags":[],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"centos安装jdk8","uid":"7fb61ad3abf570e620c0abbb8d9991cb","slug":"centos安装jdk8","date":"2019-01-17T08:12:56.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/centos安装jdk8.json","keywords":null,"cover":null,"text":"准备 在 linux 环境下创建一个目录来安装 java如/usr/java 下载安装文件 JDK8 官网下载地址 移动到/usr/java 目录，使用 wget 进行安装，需要先在网页上点击要下载的版本，然后在浏览器的下载内容里把带有带有认证信息的下载链接拷贝出来使用 wget...","link":"","photos":[],"count_time":{"symbolsCount":895,"symbolsTime":"1 mins."},"categories":[{"name":"linux","slug":"linux","count":2,"path":"api/categories/linux.json"}],"tags":[{"name":"linux","slug":"linux","count":2,"path":"api/tags/linux.json"},{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}