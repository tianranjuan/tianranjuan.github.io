{"title":"JavaScript工作原理之事件循环和基础的异步实现","uid":"043f9cbe38a0b25b8b616d2a4ca463e9","slug":"JavaScript工作原理之事件循环和基础的异步实现","date":"2019-03-28T06:22:44.000Z","updated":"2025-09-28T09:23:30.322Z","comments":true,"path":"api/articles/JavaScript工作原理之事件循环和基础的异步实现.json","keywords":null,"cover":[],"content":"<h1 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h1><hr>\n<p>常规的JavaScript引擎是单线程的，也就是说所有的代码块都是顺序按照顺序被执行，这就导致遇到处理慢的代码块会阻塞软件的运行，甚至使程序停止响应，通常解决方案是使用异步来处理，把需要时间处理的代码块异步的进行处理，后面的块则继续执行，等到该代码块处理完以后再回过头来进行结果的处理，但是在ES6前并没有很好的异步解决方案，所以大部分是使用setTimeout来进行处理。下面就通过setTimeout的执行原理来理解一下JavaScript的异步处理的核心机制－－事件循环机制。</p>\n<p>首先看一下JavaScript的运行时模型：</p>\n<ul>\n<li><p>JavaScript引擎部分(例如V8引擎) ，黑框中部分</p>\n</li>\n<li><p>WebAPIs部分，由宿主环境提供的额外API不属于引擎的原生部分</p>\n</li>\n<li><p>EventLoop &amp; CallbackQueue 事件循环和回调队列，同样属于宿主环境提供的机制，用于辅助引擎工作</p>\n</li>\n</ul>\n<p><img src=\"/image/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/image-20200408144938967.png\" alt=\"image-20200408144938967\"></p>\n<hr>\n<p>下面基于这个模型，通过定时器来理解一下，JavaScript的事件循环机制以及异步是如何调用的。</p>\n<p>首先写一个基本的定时器</p>\n<p>[图片上传失败…(image-5c33a6-1553756162784)]</p>\n<p>1.代码运行，此时进行代码的解析</p>\n<p><img src=\"/image/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/image-20200408144926592.png\" alt=\"image-20200408144926592\"></p>\n<p>2.调用<code>console.log(&#39;HI&#39;)</code> 进入到调用栈中</p>\n<p><img src=\"/image/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/image-20200408144948667.png\" alt=\"image-20200408144948667\"></p>\n<p>3.控制台打印<code>Hi</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-be3ba662fdc450dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>4.解析下一部分代码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-3507f73b265f17cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>5.执行定时器，加入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-1d05a0efa2d86e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>6.在WebAPIs中创建一个Timer，并将定时器的内容移过去</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-8baf0f6a1709ef17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>7.定时器部分执行完毕，弹出调用栈,此时定时器内的内容被保存在WebAPIs环境当中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-45664e326829d779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>8.调用<code>console.log(&#39;Bye&#39;)</code> 进入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-32bf1b647d81e33a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>9.控制台打印<code>Bye</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-2055718437ed63a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>10.<code>console.log(&#39;Bye&#39;)</code>弹出调用栈</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-460f0229bf5ef0ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>11.等待WebAPIs中的timer执行，将<code>cb1</code>加入到回调队列中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-be1c58bd91a46179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>12.通过事件循环将回调队列中的<code>cb1</code>重新压入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-a023640fe79c7765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>13.<code>cb1</code>内调用了<code>console.log(&#39;cb1&#39;)</code>所以也要压入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-96e2354ff3d441d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>14.控制台打印<code>cb1</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-a79be9922f59b022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>15.弹出<code>console.log(&#39;cb1&#39;)</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-33325832868e4fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>16.弹出<code>cb1</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-70577a8cb7b402f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>通过对<code>setTimeout</code>的流程解析，很容易发现JavaScript在运行时的调用过程是首先由JS引擎将代码解析编译，然后根据调用顺序加入到调用栈中(栈中的每一项都叫做帧)逐帧执行，其中需要用到WebAPIs、事件循环、回调队列的辅助，最后将执行的结果返回给调用处，至此JavaScript就完成了一次调用的循环。</p>\n<h1 id=\"基础异步实现\"><a href=\"#基础异步实现\" class=\"headerlink\" title=\"基础异步实现\"></a>基础异步实现</h1><hr>\n<p>上面的例子已经使用<code>setTimeout</code>实现了一个基础的异步调用但是需要注意的是，虽然例子中使用的<code>setTimeout(myCallback, 5000);</code>但这并不意味着回调函数会在5秒后立即被执行，而是表示回调方法在5秒后把回调函数添加到<strong>回调队列</strong>中,如果此时队列中存在待处理任务，那么该回调函数也会相应的被延迟执行。</p>\n<p>所以即使是像下面这个例子一样也依然会是一个异步的调用结果，因为<code>setTimeout</code>的第二个参数仅仅是延迟多久将回调内容放置到<code>回调队列</code>中，而不是确保延迟多久后一定执行。</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">console.log(&#39;Hi&#39;);</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">setTimeout(function() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">    console.log(&#39;callback&#39;);</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">&#125;, 0);</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">console.log(&#39;Bye&#39;);</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">/**输出结果**/</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">//Hi</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">//Bye</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\">//callback</span></span>\n<span class=\"line\"><span style=\"color: #abb2bf\"></span></span></code></pre></div>","text":"事件循环 常规的JavaScript引擎是单线程的，也就是说所有的代码块都是顺序按照顺序被执行，这就导致遇到处理慢的代码块会阻塞软件的运行，甚至使程序停止响应，...","permalink":"/post/JavaScript工作原理之事件循环和基础的异步实现","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">事件循环</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">基础异步实现</span></a></li></ol>","author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"git把某本地分支的某次修改修改到其他远程分支","uid":"6d5ec0ddb13963c47904e9839c9e31d9","slug":"git把某本地分支的某次修改修改到其他远程分支","date":"2019-03-28T08:18:56.000Z","updated":"2025-09-28T09:23:30.331Z","comments":true,"path":"api/articles/git把某本地分支的某次修改修改到其他远程分支.json","keywords":null,"cover":[],"text":"起因因为一次手残操作，在没看清分支的情况下把代码写在了一个错误分支上，并且把修改提交到了该分支上。在网上找了很多解决办法都不太好用，最后用下面的这个命令解决了这...","permalink":"/post/git把某本地分支的某次修改修改到其他远程分支","photos":[],"count_time":{"symbolsCount":387,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"[转]写好JavaScript条件语句的5条守则","uid":"4ed54b66406825cfd09b4a09d07c0870","slug":"写好JavaScript条件语句的5条守则(转)","date":"2019-03-28T06:21:57.000Z","updated":"2023-12-18T13:29:03.659Z","comments":true,"path":"api/articles/写好JavaScript条件语句的5条守则(转).json","keywords":null,"cover":null,"text":" 原文地址：5 Tips to Write Better Conditionals in JavaScript 原文作者：ecelyn Yeen(@jecely...","permalink":"/post/写好JavaScript条件语句的5条守则(转)","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[],"tags":[],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}