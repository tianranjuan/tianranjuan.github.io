{"title":"JavaScript工作原理之事件循环和基础的异步实现","uid":"043f9cbe38a0b25b8b616d2a4ca463e9","slug":"JavaScript工作原理之事件循环和基础的异步实现","date":"2019-03-28T06:22:44.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/JavaScript工作原理之事件循环和基础的异步实现.json","keywords":null,"cover":[],"content":"<h1 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h1><hr>\n<p>常规的JavaScript引擎是单线程的，也就是说所有的代码块都是顺序按照顺序被执行，这就导致遇到处理慢的代码块会阻塞软件的运行，甚至使程序停止响应，通常解决方案是使用异步来处理，把需要时间处理的代码块异步的进行处理，后面的块则继续执行，等到该代码块处理完以后再回过头来进行结果的处理，但是在ES6前并没有很好的异步解决方案，所以大部分是使用setTimeout来进行处理。下面就通过setTimeout的执行原理来理解一下JavaScript的异步处理的核心机制－－事件循环机制。</p>\n<p>首先看一下JavaScript的运行时模型：</p>\n<ul>\n<li><p>JavaScript引擎部分(例如V8引擎) ，黑框中部分</p>\n</li>\n<li><p>WebAPIs部分，由宿主环境提供的额外API不属于引擎的原生部分</p>\n</li>\n<li><p>EventLoop &amp; CallbackQueue 事件循环和回调队列，同样属于宿主环境提供的机制，用于辅助引擎工作</p>\n</li>\n</ul>\n<p><img src=\"../images/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/image-20200408144938967.png\" alt=\"image-20200408144938967\"></p>\n<hr>\n<p>下面基于这个模型，通过定时器来理解一下，JavaScript的事件循环机制以及异步是如何调用的。</p>\n<p>首先写一个基本的定时器</p>\n<p>[图片上传失败…(image-5c33a6-1553756162784)]</p>\n<p>1.代码运行，此时进行代码的解析</p>\n<p><img src=\"../images/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/image-20200408144926592.png\" alt=\"image-20200408144926592\"></p>\n<p>2.调用<code>console.log(&#39;HI&#39;)</code> 进入到调用栈中</p>\n<p><img src=\"../images/JavaScript%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0/image-20200408144948667.png\" alt=\"image-20200408144948667\"></p>\n<p>3.控制台打印<code>Hi</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-be3ba662fdc450dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>4.解析下一部分代码</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-3507f73b265f17cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>5.执行定时器，加入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-1d05a0efa2d86e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>6.在WebAPIs中创建一个Timer，并将定时器的内容移过去</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-8baf0f6a1709ef17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>7.定时器部分执行完毕，弹出调用栈,此时定时器内的内容被保存在WebAPIs环境当中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-45664e326829d779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>8.调用<code>console.log(&#39;Bye&#39;)</code> 进入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-32bf1b647d81e33a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>9.控制台打印<code>Bye</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-2055718437ed63a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>10.<code>console.log(&#39;Bye&#39;)</code>弹出调用栈</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-460f0229bf5ef0ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>11.等待WebAPIs中的timer执行，将<code>cb1</code>加入到回调队列中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-be1c58bd91a46179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>12.通过事件循环将回调队列中的<code>cb1</code>重新压入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-a023640fe79c7765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>13.<code>cb1</code>内调用了<code>console.log(&#39;cb1&#39;)</code>所以也要压入到调用栈中</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-96e2354ff3d441d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>14.控制台打印<code>cb1</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-a79be9922f59b022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>15.弹出<code>console.log(&#39;cb1&#39;)</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-33325832868e4fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>16.弹出<code>cb1</code></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-70577a8cb7b402f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>通过对<code>setTimeout</code>的流程解析，很容易发现JavaScript在运行时的调用过程是首先由JS引擎将代码解析编译，然后根据调用顺序加入到调用栈中(栈中的每一项都叫做帧)逐帧执行，其中需要用到WebAPIs、事件循环、回调队列的辅助，最后将执行的结果返回给调用处，至此JavaScript就完成了一次调用的循环。</p>\n<h1 id=\"基础异步实现\"><a href=\"#基础异步实现\" class=\"headerlink\" title=\"基础异步实现\"></a>基础异步实现</h1><hr>\n<p>上面的例子已经使用<code>setTimeout</code>实现了一个基础的异步调用但是需要注意的是，虽然例子中使用的<code>setTimeout(myCallback, 5000);</code>但这并不意味着回调函数会在5秒后立即被执行，而是表示回调方法在5秒后把回调函数添加到<strong>回调队列</strong>中,如果此时队列中存在待处理任务，那么该回调函数也会相应的被延迟执行。</p>\n<p>所以即使是像下面这个例子一样也依然会是一个异步的调用结果，因为<code>setTimeout</code>的第二个参数仅仅是延迟多久将回调内容放置到<code>回调队列</code>中，而不是确保延迟多久后一定执行。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nconsole.log(&#39;Hi&#39;);\n\nsetTimeout(function() &#123;\n\n    console.log(&#39;callback&#39;);\n\n&#125;, 0);\n\nconsole.log(&#39;Bye&#39;);\n\n&#x2F;**输出结果**&#x2F;\n\n&#x2F;&#x2F;Hi\n\n&#x2F;&#x2F;Bye\n\n&#x2F;&#x2F;callback\n</code></pre>","text":"事件循环 常规的JavaScript引擎是单线程的，也就是说所有的代码块都是顺序按照顺序被执行，这就导致遇到处理慢的代码块会阻塞软件的运行，甚至使程序停止响应，通常解决方案是使用异步来处理，把需要时间处理的代码块异步的进行处理，后面的块则继续执行，等到该代码块处理完以后再回过头来...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"js","slug":"js","count":4,"path":"api/categories/js.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">事件循环</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">基础异步实现</span></a></li></ol>","author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"git把某本地分支的某次修改修改到其他远程分支","uid":"6d5ec0ddb13963c47904e9839c9e31d9","slug":"git把某本地分支的某次修改修改到其他远程分支","date":"2019-03-28T08:18:56.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/git把某本地分支的某次修改修改到其他远程分支.json","keywords":null,"cover":[],"text":"起因 因为一次手残操作，在没看清分支的情况下把代码写在了一个错误分支上，并且把修改提交到了该分支上。在网上找了很多解决办法都不太好用，最后用下面的这个命令解决了这个问题。 目标 git的修改提交到了不是目标分支的另一个分支上，需要将其修正过来。 解决 首先切换到本地的错误分支上 ...","link":"","photos":[],"count_time":{"symbolsCount":390,"symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":3,"path":"api/categories/git.json"}],"tags":[],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"[转]写好JavaScript条件语句的5条守则","uid":"4ed54b66406825cfd09b4a09d07c0870","slug":"写好JavaScript条件语句的5条守则(转)","date":"2019-03-28T06:21:57.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/写好JavaScript条件语句的5条守则(转).json","keywords":null,"cover":null,"text":" 原文地址：5 Tips to Write Better Conditionals in JavaScript 原文作者：ecelyn Yeen(@jecelynyeen) 译文出自：阿里云翻译小组 译文链接：https://github.com/dawn-teams/trans...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"js","slug":"js","count":4,"path":"api/categories/js.json"}],"tags":[],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}