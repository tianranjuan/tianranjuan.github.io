{"title":"js到底要不要加分号？","uid":"066dbf65de05ce712f1d73bffa64257b","slug":"js到底要不要加分号","date":"2025-09-29T15:06:22.035Z","updated":"2025-09-29T15:10:31.355Z","comments":true,"path":"api/articles/js到底要不要加分号.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/280h/alone-background_TJSWWAXG9T.jpg","content":"<h2 id=\"1-争吵的由来\"><a href=\"#1-争吵的由来\" class=\"headerlink\" title=\"1. 争吵的由来\"></a>1. 争吵的由来</h2><p>行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号。 于是乎两伙人在同时写 js 的时候就打了起来。</p>\n<h2 id=\"2-优劣\"><a href=\"#2-优劣\" class=\"headerlink\" title=\"2. 优劣\"></a>2. 优劣</h2><p>其实并没有什么优劣，加分号代码更清晰，自己控制的分号肯定不会出错；不加分号，js 引擎可以自动插入，但是要注意自动插入的规则，在规则内不加分号也是完全不会有问题。</p>\n<h3 id=\"2-1-自动插入分号规则\"><a href=\"#2-1-自动插入分号规则\" class=\"headerlink\" title=\"2.1. 自动插入分号规则\"></a>2.1. 自动插入分号规则</h3><p>自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。</p>\n<ul>\n<li>要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</li>\n<li>有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</li>\n<li>源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</li>\n</ul>\n<p>什么意思呢，下面几个例子来说明下</p>\n<h4 id=\"2-1-1-要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。\"><a href=\"#2-1-1-要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。\" class=\"headerlink\" title=\"2.1.1. 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。\"></a>2.1.1. 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</h4><div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #C678DD\">function</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E06C75; font-style: italic\">a</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">})(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">);</span></span></code></pre></div><p>这个例子中本意是想在声明变量 a 后，执行一个 IIFE，由于 1 后面紧跟的是 void，这是不符合语法规则的，所以根据第一条规则，这里会自动插入一个分号。</p>\n<h4 id=\"2-1-2-有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。\"><a href=\"#2-1-2-有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。\" class=\"headerlink\" title=\"2.1.2. 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。\"></a>2.1.2. 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</h4><div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">,</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E06C75\">b</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">,</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E06C75\">c</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #56B6C2\">++</span><span style=\"color: #E06C75\">b</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #56B6C2\">++</span><span style=\"color: #E06C75\">c</span><span style=\"color: #ABB2BF\">;</span></span></code></pre></div><p>这个例子中呢，本意是想在声明完 a，b，c 三个变量后，对 a，b 进行自增(++)操作，但是由于 a 后面紧跟了换行符，而 a++(后自增)的语法时不允许存在换行符的（根据 no LineTerminator here 规则）所以会在 a 后面自动插入一个分号，此时就变成了</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">,</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E06C75\">b</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">,</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E06C75\">c</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #56B6C2\">++</span><span style=\"color: #E06C75\">b</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #56B6C2\">++</span><span style=\"color: #E06C75\">c</span><span style=\"color: #ABB2BF\">;</span></span></code></pre></div><p>这明显是不符合预期的，所以在这个示例中，不写分号是影响开发的。</p>\n<h4 id=\"2-1-3-源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。\"><a href=\"#2-1-3-源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。\" class=\"headerlink\" title=\"2.1.3. 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。\"></a>2.1.3. 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</h4><div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">function</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E06C75; font-style: italic\">a</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">})()(</span><span style=\"color: #C678DD\">function</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E06C75; font-style: italic\">a</span><span style=\"color: #ABB2BF\">) {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">})();</span></span></code></pre></div><p>这个例子中我们原本的意图是先后执行两个 IIFE 可以却会报错，原因是在第一个 IIFE 执行完毕后，解析第二个 IIFE 时，js 引擎会认为第一个 IIFE 有可能返回一个函数，那么在函数后面紧跟了一个<code>(</code>符号就有可能是调用传参操作，而这种操作是合法的，也就不会在这里自动插入符号，导致报错。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>避免这种情况的方法有在第二个 IIFE 钱加<code>;</code>，或者是使用一些表达式加以区分，如： <code>0, function() {}()</code>, <code>true &amp;&amp; function(){}()</code>, <code>+function() {}()</code>, <code>(0, function(){}())()</code>等</p></blockquote>\n<h2 id=\"3-那么什么是-no-LineTerminator-here-规则\"><a href=\"#3-那么什么是-no-LineTerminator-here-规则\" class=\"headerlink\" title=\"3. 那么什么是 no LineTerminator here 规则\"></a>3. 那么什么是 no LineTerminator here 规则</h2><p><img src=\"https://static001.geekbang.org/resource/image/c3/ad/c3ffbc89e049ad1901d4108c8ad88aad.jpg\" alt=\"no LineTerminator here规则\"></p>\n<p>凡是符合上图规则的都不会自动插入分号，如 a 自增的例子中，就是因为不符合<code>后自增、后自减运算符前不能插入换行</code>的规则导致的自动插入错误。</p>\n<h2 id=\"4-其他坑\"><a href=\"#4-其他坑\" class=\"headerlink\" title=\"4. 其他坑\"></a>4. 其他坑</h2><h3 id=\"4-1-以数组开头\"><a href=\"#4-1-以数组开头\" class=\"headerlink\" title=\"4.1. 以数组开头\"></a>4.1. 以数组开头</h3><div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> [[]] </span><span style=\"color: #7F848E; font-style: italic\">/*这里没有被自动插入分号*/</span><span style=\"color: #ABB2BF\"> [</span><span style=\"color: #D19A66\">3</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">2</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">]</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  .</span><span style=\"color: #61AFEF\">forEach</span><span style=\"color: #ABB2BF\">((</span><span style=\"color: #E06C75; font-style: italic\">e</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #C678DD\">=&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">e</span><span style=\"color: #ABB2BF\">));</span></span></code></pre></div><p>这里的问题是由于<code>[[]]</code>中的最后一个<code>]</code>后没有写分号，导致第二哥开始的<code>[</code>和<code>,</code>会被认为是下标运算符和逗号表达式,而在这个例子中甚至都不会报错，所以排查起来也会非常的困难。</p>\n<h3 id=\"4-2-正则表达式开头-自面量形式\"><a href=\"#4-2-正则表达式开头-自面量形式\" class=\"headerlink\" title=\"4.2. 正则表达式开头(自面量形式)\"></a>4.2. 正则表达式开头(自面量形式)</h3><div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">,</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E06C75\">g</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> { </span><span style=\"color: #61AFEF\">test</span><span style=\"color: #ABB2BF\">: () </span><span style=\"color: #C678DD\">=&gt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\"> },</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E06C75\">b</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #7F848E; font-style: italic\">/*这里没有被自动插入分号*/</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">/</span><span style=\"color: #E06C75\">a</span><span style=\"color: #56B6C2\">/</span><span style=\"color: #E5C07B\">g</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">test</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #98C379\">\"abc\"</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">RegExp</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">$1</span><span style=\"color: #ABB2BF\">);</span></span></code></pre></div><p>这个例子中在本意是想在声明完 x，g，b 三个变量后使用正则表达式对字符串进行 test 测试，而由于在声明完变量 b 以后没有写分号，所以正则表达式开头的<code>/</code>被认为是一个<strong>除法运算符</strong>，所以后面会被当成一个表达式运行，会抛出<code> a is not defined</code>的异常，而后面如果 g 是以个正常的对象，同时又拥有 test 方法的情况甚至还会被正常执行 test 方式，所以排查起来也会很困难。</p>\n<h3 id=\"4-3-以-Template-开头的语句\"><a href=\"#4-3-以-Template-开头的语句\" class=\"headerlink\" title=\"4.3. 以 Template 开头的语句\"></a>4.3. 以 Template 开头的语句</h3><div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">f</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">function</span><span style=\"color: #ABB2BF\"> () {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">\"\"</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">};</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">g</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">f</span><span style=\"color: #7F848E; font-style: italic\">/*这里没有被自动插入分号*/</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">`Template`</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">match</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">/(a)/</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">RegExp</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">$1</span><span style=\"color: #ABB2BF\">);</span></span></code></pre></div><p>这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。排查起来同样非常困难。</p>\n<h2 id=\"5-总结一下\"><a href=\"#5-总结一下\" class=\"headerlink\" title=\"5. 总结一下\"></a>5. 总结一下</h2><p>看了这么多示例后，想必对自动插入分号的规则也有了了解，那么就通过引用尤雨溪尤大在知乎的一个回答来快速的记住如何避免不写分号所带来的坑：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>没有应该不应该，只有你自己喜欢不喜欢。JavaScript 语法长得 C-like 不代表它本质上和 C 是一类语言，所有直觉性的 “当然应该加分号” 都是保守的、未经深入思考的草率结论。后来新设计的语言里可选分号的多得去了，光是 “可以加分号但是大家都不加” 的语言就有：Go, Scala, Ruby, Python, Swift, Groovy…</p>\n<p>至于说 “很难总结什么时候加不加”，其实真的很简单。真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。</p></blockquote>\n","text":"1. 争吵的由来行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。但是，从今天的角度来看，行尾使用分号其...","permalink":"/post/js到底要不要加分号","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BA%89%E5%90%B5%E7%9A%84%E7%94%B1%E6%9D%A5\"><span class=\"toc-text\">1. 争吵的由来</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BC%98%E5%8A%A3\"><span class=\"toc-text\">2. 优劣</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E5%88%86%E5%8F%B7%E8%A7%84%E5%88%99\"><span class=\"toc-text\">2.1. 自动插入分号规则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-1-%E8%A6%81%E6%9C%89%E6%8D%A2%E8%A1%8C%E7%AC%A6%EF%BC%8C%E4%B8%94%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%AC%A6%E5%8F%B7%E6%98%AF%E4%B8%8D%E7%AC%A6%E5%90%88%E8%AF%AD%E6%B3%95%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E5%B0%9D%E8%AF%95%E6%8F%92%E5%85%A5%E5%88%86%E5%8F%B7%E3%80%82\"><span class=\"toc-text\">2.1.1. 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-2-%E6%9C%89%E6%8D%A2%E8%A1%8C%E7%AC%A6%EF%BC%8C%E4%B8%94%E8%AF%AD%E6%B3%95%E4%B8%AD%E8%A7%84%E5%AE%9A%E6%AD%A4%E5%A4%84%E4%B8%8D%E8%83%BD%E6%9C%89%E6%8D%A2%E8%A1%8C%E7%AC%A6%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E5%88%86%E5%8F%B7%E3%80%82\"><span class=\"toc-text\">2.1.2. 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-3-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9D%9F%E5%A4%84%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%BD%A2%E6%88%90%E5%AE%8C%E6%95%B4%E7%9A%84%E8%84%9A%E6%9C%AC%E6%88%96%E8%80%85%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5%E5%88%86%E5%8F%B7%E3%80%82\"><span class=\"toc-text\">2.1.3. 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AF-no-LineTerminator-here-%E8%A7%84%E5%88%99\"><span class=\"toc-text\">3. 那么什么是 no LineTerminator here 规则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%85%B6%E4%BB%96%E5%9D%91\"><span class=\"toc-text\">4. 其他坑</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-%E4%BB%A5%E6%95%B0%E7%BB%84%E5%BC%80%E5%A4%B4\"><span class=\"toc-text\">4.1. 以数组开头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BC%80%E5%A4%B4-%E8%87%AA%E9%9D%A2%E9%87%8F%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">4.2. 正则表达式开头(自面量形式)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E4%BB%A5-Template-%E5%BC%80%E5%A4%B4%E7%9A%84%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">4.3. 以 Template 开头的语句</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B\"><span class=\"toc-text\">5. 总结一下</span></a></li></ol>","author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"关于JS中变量提升问题的研究","uid":"147d0b77a639b4360d2d5ae395dbfd1a","slug":"关于JS中变量提升问题的研究","date":"2025-09-29T15:09:13.110Z","updated":"2025-09-29T15:10:31.355Z","comments":true,"path":"api/articles/关于JS中变量提升问题的研究.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/280h/enchanting-forest_1CFKSWRR5X.jpg","text":"1. 提升意思指代码在在代码执行前预处理阶段由解释器对代码进行扫描后，对代码进行的优化处理，把以某些特定关键字声明的变量提前放置到作用域顶层提前声明、创建的行为...","permalink":"/post/关于JS中变量提升问题的研究","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/tags/JavaScript.json"}],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"d3的7步开发法","uid":"5e69e1cf00eccada627cba6c5b3a1509","slug":"d3/07步开发法","date":"2025-09-28T14:01:52.646Z","updated":"2025-09-28T14:04:35.256Z","comments":true,"path":"api/articles/d3/07步开发法.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/280h/bird-spoonbill_OXW52JDMAI.jpg","text":"根据《Fullstack D3 and Data Visualization》的核心方法论，开发数据可视化通常遵循以下 7 步流程，这些步骤结合了数据驱动文档（...","permalink":"/post/d3/07步开发法","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"d3","slug":"d3","count":5,"path":"api/categories/d3.json"}],"tags":[{"name":"d3","slug":"d3","count":5,"path":"api/tags/d3.json"},{"name":"数据可视化","slug":"数据可视化","count":5,"path":"api/tags/数据可视化.json"}],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}