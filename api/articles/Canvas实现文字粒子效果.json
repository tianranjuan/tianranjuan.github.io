{"title":"Canvas实现文字粒子效果","uid":"f05f533c1133c025c502733d54123419","slug":"Canvas实现文字粒子效果","date":"2019-03-29T06:45:12.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/Canvas实现文字粒子效果.json","keywords":null,"cover":[],"content":"<p>最终实现效果</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/15262297-10ecaf3d3baec6ad.gif?imageMogr2/auto-orient/strip\" alt=\"文字粒子\"></p>\n<p><strong>实现思路：</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>获取到canvas绘制后屏幕上像素点的数组，在目标像素点上绘制粒子替换掉原来的内容</p></blockquote>\n<ul>\n<li>绘制文字</li>\n<li>通过API获取画布的二进制数组</li>\n<li>设置粒子的填充步长</li>\n<li>添加粒子</li>\n<li>循环的遍历粒子，更新粒子的状态</li>\n</ul>\n<p><strong>代码实现</strong></p>\n<p><strong>绘制文字</strong><br> <pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">context.textAlign &#x3D; &quot;center&quot;;\ncontext.font &#x3D; this.size + &quot;px arial&quot;;\ncontext.fillText(this.text, this.x, this.y);</code></pre></p>\n<p><strong>获取<code>二进制</code>数组</strong><br> <pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">let idata &#x3D; context.getImageData(0, 0, canvas.width, canvas.height); &#x2F;&#x2F; 获取 canvas指定范围内的 像素数组\nlet buffer32 &#x3D; new Uint32Array(idata.data.buffer); &#x2F;&#x2F; 转成32位的数组</code></pre></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里使用的<code>getImageData()</code>方法是获取画布内所有的像素点的<code>二进制</code>表示，在JS中使用<code>Uint32Array</code>来接收，已数组形式展现，没有渲染的地方数组值是0，有渲染的地方为一个非0的数字</p></blockquote>\n<p><strong>填充粒子</strong></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 遍历所有的数组 \nfor (var j &#x3D; 0; j &lt; canvas.height; j +&#x3D; gridY) &#123;&#x2F;&#x2F;步长\n  for (var i &#x3D; 0; i &lt; canvas.width; i +&#x3D; gridX) &#123;&#x2F;&#x2F;步长\n      if (buffer32[j * canvas.width + i]) &#123;\n            &#x2F;&#x2F; 放入粒子对象\n            var ball &#x3D; new Particle(i, j);\n            this.placement.push(ball);\n      &#125;\n    &#125;\n &#125;</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里的意思是在二进制数组中某一个范围内的粒子的密度，其中步长越小越密集</p></blockquote>\n<p><strong>更新粒子状态</strong></p>\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">(function drawFrame() &#123;\n    window.requestAnimationFrame(drawFrame);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    for (var i &#x3D; 0; i &lt; word.placement.length; i++) &#123;\n        &#x2F;&#x2F;调用particle对像的drawParticle方法，开始画布上画\n        word.placement[i].drawParticle();\n    &#125;\n&#125;())</code></pre>\n\n<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">this.drawParticle &#x3D; function () &#123;\n    &#x2F;&#x2F; 当前粒子变小到一定程度之后，每次将它的半径+0.1，使其慢慢变大\n    if (this.radius &lt; this.futurRadius &amp;&amp; this.dying &#x3D;&#x3D;&#x3D; false) &#123;\n        this.radius +&#x3D; durVal;\n    &#125; else &#123; &#x2F;&#x2F;粒子已经到达最大状态\n        this.dying &#x3D; true; &#x2F;&#x2F;表示粒子还处于show状态\n    &#125;\n\n    &#x2F;&#x2F;每次-0.1\n    if (this.dying) &#123;\n        this.radius -&#x3D; durVal;\n    &#125;\n    &#x2F;&#x2F; 画粒子形状\n    context.save();\n    context.fillStyle &#x3D; this.color;\n    context.beginPath();\n    context.fillRect(this.x, this.y, this.futurRadius, this.futurRadius)\n    context.closePath();\n    context.fill();\n    context.restore();\n\n    &#x2F;&#x2F;将消失的粒子重置最初的状态\n    if (this.y &lt; 0 || this.radius &lt; 1) &#123;\n        this.x &#x3D; this.base[0];\n        this.y &#x3D; this.base[1];\n        this.dying &#x3D; false;\n        this.futurRadius &#x3D; randomInt(1.1, 5.1);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>完整代码</strong></p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;canvas id&#x3D;&quot;dir&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;800&quot; style&#x3D;&quot;border:1px solid #ccc&quot;&gt;\n    &lt;&#x2F;canvas&gt;\n\n    &lt;script&gt;\n        var canvas &#x3D; document.getElementById(&quot;dir&quot;);\n        var context &#x3D; canvas.getContext(&quot;2d&quot;);\n\n        var gridY &#x3D; 10,\n            gridX &#x3D; 10,\n            colors &#x3D; [&#39;#f44336&#39;, &#39;#e91e63&#39;, &#39;#9c27b0&#39;, &#39;#673ab7&#39;, &#39;#3f51b5&#39;,\n                &#39;#2196f3&#39;, &#39;#03a9f4&#39;, &#39;#00bcd4&#39;, &#39;#009688&#39;, &#39;#4CAF50&#39;,\n                &#39;#8BC34A&#39;, &#39;#CDDC39&#39;, &#39;#FFEB3B&#39;, &#39;#FFC107&#39;, &#39;#FF9800&#39;,\n                &#39;#FF5722&#39;\n            ],\n            durVal &#x3D; 0.1;\n\n\n        &#x2F;&#x2F; 粒子\n        function Particle(x, y) &#123;\n            this.x &#x3D; x;\n            this.y &#x3D; y;\n            this.color &#x3D; colors[Math.floor(Math.random() * colors.length)]; &#x2F;&#x2F;&#39;bleack&#39;&#x2F;&#x2F;\n            this.futurRadius &#x3D; randomInt(1.1, 5.1);\n            this.radius &#x3D; 1.1;\n            this.dying &#x3D; false;\n            this.base &#x3D; [x, y];\n\n            this.drawParticle &#x3D; function () &#123;\n\n                &#x2F;&#x2F; 当前粒子变小到一定程度之后，每次将它的半径+0.1，使其慢慢变大\n                if (this.radius &lt; this.futurRadius &amp;&amp; this.dying &#x3D;&#x3D;&#x3D; false) &#123;\n                    this.radius +&#x3D; durVal;\n                &#125; else &#123; &#x2F;&#x2F;粒子已经到达最大状态\n                    this.dying &#x3D; true; &#x2F;&#x2F;表示粒子还处于show状态\n                &#125;\n\n                &#x2F;&#x2F;每次-0.1\n                if (this.dying) &#123;\n                    this.radius -&#x3D; durVal;\n                &#125;\n                &#x2F;&#x2F; 画粒子形状\n                context.save();\n                context.fillStyle &#x3D; this.color;\n                context.beginPath();\n                context.fillRect(this.x, this.y, this.futurRadius, this.futurRadius)\n                context.closePath();\n                context.fill();\n                context.restore();\n\n                &#x2F;&#x2F;将消失的粒子重置最初的状态\n                if (this.y &lt; 0 || this.radius &lt; 1) &#123;\n                    this.x &#x3D; this.base[0];\n                    this.y &#x3D; this.base[1];\n                    this.dying &#x3D; false;\n                    this.futurRadius &#x3D; randomInt(1.1, 5.1);\n                &#125;\n            &#125;\n        &#125;\n\n        function Shape(x, y, texte) &#123;\n            this.x &#x3D; x;\n            this.y &#x3D; y;\n            this.size &#x3D; 200;\n            this.text &#x3D; texte;\n            this.placement &#x3D; [];\n        &#125;\n\n\n        Shape.prototype.getValue &#x3D; function () &#123;\n            context.textAlign &#x3D; &quot;center&quot;;\n            context.font &#x3D; this.size + &quot;px arial&quot;;\n            context.fillText(this.text, this.x, this.y);\n\n            let idata &#x3D; context.getImageData(0, 0, canvas.width, canvas.height); &#x2F;&#x2F; 获取 canvas指定范围内的 像素数组\n            let buffer32 &#x3D; new Uint32Array(idata.data.buffer); &#x2F;&#x2F; 转成32位的数组\n\n            &#x2F;&#x2F; 遍历所有的数组 \n            for (var j &#x3D; 0; j &lt; canvas.height; j +&#x3D; gridY) &#123;\n                for (var i &#x3D; 0; i &lt; canvas.width; i +&#x3D; gridX) &#123;\n                    if (buffer32[j * canvas.width + i]) &#123;\n                        &#x2F;&#x2F; 放入粒子对象\n                        var ball &#x3D; new Particle(i, j);\n                        this.placement.push(ball);\n                    &#125;\n                &#125;\n            &#125;\n\n            context.clearRect(0, 0, canvas.width, canvas.height);\n        &#125;\n\n        function randomInt(min, max) &#123;\n            return min + Math.random() * (max - min + 1);\n        &#125;\n\n        var word &#x3D; new Shape(canvas.width &#x2F; 2, canvas.height &#x2F; 2, &#39;文字粒子&#39;)\n        word.getValue\n\n        (function drawFrame() &#123;\n            window.requestAnimationFrame(drawFrame);\n            context.clearRect(0, 0, canvas.width, canvas.height);\n\n            for (var i &#x3D; 0; i &lt; word.placement.length; i++) &#123;\n                &#x2F;&#x2F;调用particle对像的drawParticle方法，开始画布上画\n                word.placement[i].drawParticle();\n            &#125;\n\n        &#125;())\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n</code></pre>\n\n\n\n\n","text":"最终实现效果 实现思路： 获取到canvas绘制后屏幕上像素点的数组，在目标像素点上绘制粒子替换掉原来的内容 绘制文字 通过API获取画布的二进制数组 设置粒子的填充步长 添加粒子 循环的遍历粒子，更新粒子的状态 代码实现 绘制文字 context.textAlign &#x3D...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"canvas","slug":"canvas","count":2,"path":"api/categories/canvas.json"}],"tags":[],"toc":"","author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"CocosCreator实现摄像机跟随移动","uid":"38463cdb58c9ed519678c1b1d62b6f8a","slug":"实现摄像机跟随移动","date":"2019-04-07T17:15:48.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/实现摄像机跟随移动.json","keywords":null,"cover":[],"text":"如果只有一个摄像机的话，在Main Camera上添加脚本 这样的话就可以实现摄像机跟随主角移动而移动 ","link":"","photos":[],"count_time":{"symbolsCount":53,"symbolsTime":"1 mins."},"categories":[{"name":"游戏开发","slug":"游戏开发","count":1,"path":"api/categories/游戏开发.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"git把某本地分支的某次修改修改到其他远程分支","uid":"6d5ec0ddb13963c47904e9839c9e31d9","slug":"git把某本地分支的某次修改修改到其他远程分支","date":"2019-03-28T08:18:56.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/git把某本地分支的某次修改修改到其他远程分支.json","keywords":null,"cover":[],"text":"起因 因为一次手残操作，在没看清分支的情况下把代码写在了一个错误分支上，并且把修改提交到了该分支上。在网上找了很多解决办法都不太好用，最后用下面的这个命令解决了这个问题。 目标 git的修改提交到了不是目标分支的另一个分支上，需要将其修正过来。 解决 首先切换到本地的错误分支上 ...","link":"","photos":[],"count_time":{"symbolsCount":390,"symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":3,"path":"api/categories/git.json"}],"tags":[],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}