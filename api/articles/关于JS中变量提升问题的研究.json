{"title":"关于JS中变量提升问题的研究","uid":"147d0b77a639b4360d2d5ae395dbfd1a","slug":"关于JS中变量提升问题的研究","date":"2025-09-29T15:09:13.110Z","updated":"2025-09-29T15:10:31.355Z","comments":true,"path":"api/articles/关于JS中变量提升问题的研究.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/280h/enchanting-forest_1CFKSWRR5X.jpg","content":"<h2 id=\"1-提升\"><a href=\"#1-提升\" class=\"headerlink\" title=\"1. 提升\"></a>1. 提升</h2><p>意思指代码在在代码执行前预处理阶段由解释器对代码进行扫描后，对代码进行的优化处理，把以某些特定关键字声明的变量提前放置到作用域顶层提前声明、创建的行为。</p>\n<h2 id=\"2-声明还是创建？绑定还是初始化还是赋值？\"><a href=\"#2-声明还是创建？绑定还是初始化还是赋值？\" class=\"headerlink\" title=\"2. 声明还是创建？绑定还是初始化还是赋值？\"></a>2. 声明还是创建？绑定还是初始化还是赋值？</h2><p>首先要统一一下概念的认知</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// 声明动作同时创建了一个叫a的变量</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">undefined</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// 初始化a（存在提升时在预处理阶段由解释器进行操作）</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">\"value\"</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// 赋值动作 将value赋值给a</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">\"value\"</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// var声明并创建了a，后又被赋值了value，进行赋值前a会先被初始化为undefined</span></span></code></pre></div><p>在这段代码中 <code>var a</code>是指使用<code>var</code>关键字声明并创建了一个变量<code>a</code>, <code>var a = undefined</code>是将 a 变量进行初始化,而<code>a = 'value'</code>中’value’被赋值给了 a</p>\n<p>在统一好了概念后，下面就进入正题</p>\n<h2 id=\"3-使用-var-声明\"><a href=\"#3-使用-var-声明\" class=\"headerlink\" title=\"3. 使用 var 声明\"></a>3. 使用 var 声明</h2><div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span></code></pre></div><p>这里我们都知道由于变量提升会打印出 undefined，那么是为什么呢？<br>这里大致可以解释为：</p>\n<p>js 解释器在扫描了代码后，把所有以<code>var</code>关键字进行生命的变量拿出来放到了作用域的最上面进行<code>声明</code>并把变量初始化为默认值 undefined</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">undefined</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// 隐藏的，解释器偷偷做的</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span></code></pre></div><p>然后顺序执行代码，在执行到 console 时读取 a 并打印 undefined，继续执行到<code>var a = 1</code>在将 1 赋值给 a，此时如果在下方再次打印则会正确的打印出 1</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">undefined</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// 隐藏的，解释器偷偷做的</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">); </span><span style=\"color: #7F848E; font-style: italic\">// 打印undefined</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">a</span><span style=\"color: #ABB2BF\">); </span><span style=\"color: #7F848E; font-style: italic\">// 打印1</span></span></code></pre></div><p>好的，我们现在知道了在使用 var 声明变量的时候会被解释器偷偷的把变量放到作用域最顶层进行<code>声明</code>和<code>初始化</code>，由此导致了变量提升的问题，那么 function 是如何表现的呢？</p>\n<h2 id=\"4-使用-function-声明\"><a href=\"#4-使用-function-声明\" class=\"headerlink\" title=\"4. 使用 function 声明\"></a>4. 使用 function 声明</h2><p>也是用一个简单例子来进行说明</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #61AFEF\">fn2</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">function</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">fn2</span><span style=\"color: #ABB2BF\">() {</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #D19A66\">2</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div><p>运行代码我们会发现函数是可以正常执行的，控制台也符合预期的打印出了 2，那么就可以说明 function 关键在预处理阶段会进行<code>声明并创建</code>出 fns 函数、然后初始化为 undefined，初始化完成后再讲函数体赋值给 fn2 函数。</p>\n<p>注意<code>function</code>关键字的预处理过程比<code>var</code>关键字多出一个初始化后立即赋值的步骤，这是解开问题的关键点。</p>\n<p>那么在看完了预处理时的过程后我们加深一下难度看一下 function 和 var 结合时会有怎样的结果</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">foo</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">function</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">foo</span><span style=\"color: #ABB2BF\">() {}</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">foo</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">//------------------</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">function</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">foo</span><span style=\"color: #ABB2BF\">() {}</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">var</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">foo</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">foo</span><span style=\"color: #ABB2BF\">);</span></span></code></pre></div><p>还是一段示例，运行这两段代码发现都会打印出<code>function foo(){}</code>来，这又是为什么呢？</p>\n<p>根据上面的推导我们能知道，<code>var</code>关键字比<code>function</code>关键字在预处理时少了一个赋值的过程，那么解答起来就容易的多了，由于两个变量都叫做<code>foo</code>，所以会存在覆盖的情况，在解释器将名为 foo 的变量声明完创建完后，此时<code>foo</code>到底是谁还没有定论，仅仅是内存中一个名为<code>foo</code>的地址而已，而由于<code>var</code>关键字没有赋值动作，所以在创建完变量后任务就到此结束了，而<code>function</code>关键字是有赋值动作的，所以在创建完变量后会尝试将函数<code>foo</code>的函数体赋值给名为<code>foo</code>的变量，正是多了这一步才让变量<code>foo</code>在最后被赋值为了<code>function foo(){}</code>，此时变量也就确定为就是函数<code>foo</code>了，所以也就不难理解为什么我们打印出来也就是函数体<code>function foo(){}</code>了</p>\n<h2 id=\"5-let-到底存不存在提升\"><a href=\"#5-let-到底存不存在提升\" class=\"headerlink\" title=\"5. let 到底存不存在提升\"></a>5. let 到底存不存在提升</h2><p>说了这么多，最后来说一下到底 let 存不存在提升的问题，这个问题在一些群里也看到过讨论，也没有什么定论，所以下面是一个我个人的理解。</p>\n<p>还是上一个示例</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">\"global\"</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">{</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\">); </span><span style=\"color: #7F848E; font-style: italic\">// Uncaught ReferenceError: x is not defined</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div><p>首先 let 是一个块级作用域，所以简单的理解就是之会存在<code>{}</code>，所以此例中 console 的 x 其实值取的<code>{}</code>中的 x。</p>\n<p>然后我们执行以下代码发现抛出异常<code>Uncaught ReferenceError: x is not defined</code>这是一个变量为定义的异常，这里就很有趣了，我们来尝试分析以下：</p>\n<h3 id=\"5-1-假设-let-不存在提升\"><a href=\"#5-1-假设-let-不存在提升\" class=\"headerlink\" title=\"5.1. 假设 let 不存在提升\"></a>5.1. 假设 let 不存在提升</h3><p>假设<code>let</code>不存在变量提升，那么在预处理阶段应该会直接丢弃不进行处理，那么也就是说在执行到<code>console</code>时在<code>{}</code>作用域中并不存在一个名为 x 的变量，如果是这种情况按照 js 引擎的工作方式应该会向上找寻作用域链也就是找到<code>let x = \"global\";</code>这个 x，然后打印出<code>global</code>才对，但是显然结果并不是这样，那我们换一个假设试试；</p>\n<h3 id=\"5-2-假设-let-存在提升\"><a href=\"#5-2-假设-let-存在提升\" class=\"headerlink\" title=\"5.2. 假设 let 存在提升\"></a>5.2. 假设 let 存在提升</h3><p>假设<code>let</code>存在变量提升，那么按照上面的推导在预处理阶段会进行<code>声明</code>、<code>创建</code>、<code>初始化</code>、<code>赋值</code>等操作，又由于 console 并没有按照作用域链向上层查找，那么在调用 console 时<code>{}</code>中的 x 一定是存在的才会停止向上查找，所以可以推导出<code>let x = 1;</code>这一句的声明一定被进行了提升，否则不可能让引擎停止向上层查找。</p>\n<p>那既然推导出了 let 存在变量提升，那为什么还会报错呢？那就要说一下 let 的特性<code>暂存死区</code>了，下面同样是个人的理解。</p>\n<h3 id=\"5-3-暂存死区\"><a href=\"#5-3-暂存死区\" class=\"headerlink\" title=\"5.3. 暂存死区\"></a>5.3. 暂存死区</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。</p></blockquote>\n<p>通过 MDN 这段解释我们可以知道 let 创建的变量在初始化前是处于一个在当前作用域块顶部的区域中，这个区域就是<code>暂存死区</code>，那么这个<code>暂存死区</code>为什么就让 let 和 var 产生了不一样的行为呢？</p>\n<p>原因就是 let 虽然被提升到了当前作用域块的顶部，但是当预处理机制将其提升完后并没有对其进行初始化，而是将其标记为待评估状态，当调用一个待评估状态的变量时就会抛出 ReferenceError 异常，只有当代码执行到了初始化(赋值)语句进行了初始化后再调用就会返回正常值变成为一个正常的变量。</p>\n<p>代码可以理解为：</p>\n<div class=\"language-js\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">js</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">\"global\"</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">{</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// 此时为待评估状态，等待进行初始化，调用会抛出ReferenceError</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #E5C07B\">console</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">log</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\">); </span><span style=\"color: #7F848E; font-style: italic\">// Uncaught ReferenceError: x is not defined</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">  </span><span style=\"color: #C678DD\">let</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75\">x</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">; </span><span style=\"color: #7F848E; font-style: italic\">// 执行到这一行时，对x进行初始化并且值为1此时，状态变为一个正常的变量</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">}</span></span></code></pre></div><h3 id=\"5-4-关于-const\"><a href=\"#5-4-关于-const\" class=\"headerlink\" title=\"5.4. 关于 const\"></a>5.4. 关于 const</h3><p>const 与 let 的行为基本保持一致，区别仅在于 const 没有赋值的操作，只有<code>声明</code>、<code>创建</code>、<code>初始化</code>操作且，并不能对其进行再<code>赋值</code>。</p>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>提升的本质在于将<code>声明</code>和<code>创建</code>的步骤提升了，而关于<code>初始化</code>和<code>赋值</code>动作则根据不同的关键字有不同的评估手段和行为，所以关于 let/const 能不能提升这个问题，我觉得需要分情况而定：</p>\n<ul>\n<li>如果提升被定义为是变量的声明被提前，那么 js 中的这些关键字(<code>var,function,let,const,class,function*</code>)就都能够提升</li>\n<li>如果提升定义为完成了初始化后才算提升，那么 <code>let/const</code>就是不能提升的。</li>\n</ul>\n<h2 id=\"7-参考\"><a href=\"#7-参考\" class=\"headerlink\" title=\"7. 参考\"></a>7. 参考</h2><ul>\n<li>[1] <a href=\"https://zhuanlan.zhihu.com/p/28140450\">我用了两个月的时间才理解 let</a></li>\n<li>[2] <a href=\"https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-hoisted\">Are variables declared with let or const hoisted?</a></li>\n<li>[3] <a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-forbodyevaluation\">Runtime Semantics: LabelledEvaluation</a></li>\n</ul>\n","feature":true,"text":"1. 提升意思指代码在在代码执行前预处理阶段由解释器对代码进行扫描后，对代码进行的优化处理，把以某些特定关键字声明的变量提前放置到作用域顶层提前声明、创建的行为...","permalink":"/post/关于JS中变量提升问题的研究","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">1. 提升</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%A3%B0%E6%98%8E%E8%BF%98%E6%98%AF%E5%88%9B%E5%BB%BA%EF%BC%9F%E7%BB%91%E5%AE%9A%E8%BF%98%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%98%E6%98%AF%E8%B5%8B%E5%80%BC%EF%BC%9F\"><span class=\"toc-text\">2. 声明还是创建？绑定还是初始化还是赋值？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8-var-%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">3. 使用 var 声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8-function-%E5%A3%B0%E6%98%8E\"><span class=\"toc-text\">4. 使用 function 声明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-let-%E5%88%B0%E5%BA%95%E5%AD%98%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">5. let 到底存不存在提升</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E5%81%87%E8%AE%BE-let-%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">5.1. 假设 let 不存在提升</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E5%81%87%E8%AE%BE-let-%E5%AD%98%E5%9C%A8%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">5.2. 假设 let 存在提升</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E6%9A%82%E5%AD%98%E6%AD%BB%E5%8C%BA\"><span class=\"toc-text\">5.3. 暂存死区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E5%85%B3%E4%BA%8E-const\"><span class=\"toc-text\">5.4. 关于 const</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">6. 总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%8F%82%E8%80%83\"><span class=\"toc-text\">7. 参考</span></a></li></ol>","author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"多个div紧密排列的间隙问题","uid":"6d41b9e6354554d3613a2c8170bc7bc4","slug":"多个div紧密排列的间隙问题","date":"2025-09-29T15:27:23.263Z","updated":"2025-10-09T07:25:53.708Z","comments":true,"path":"api/articles/多个div紧密排列的间隙问题.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/280h/enchanting-forest_1CFKSWRR5X.jpg","text":"div 的行间缝隙在绘制cell时出现了 div 行间距非常大的问题 在查找资料后发现原因: 在 line-block 模式下，元素被当成行内元素排版，元素之间...","permalink":"/post/多个div紧密排列的间隙问题","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/tags/JavaScript.json"}],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"js到底要不要加分号？","uid":"066dbf65de05ce712f1d73bffa64257b","slug":"js到底要不要加分号","date":"2025-09-29T15:06:22.035Z","updated":"2025-09-29T15:10:31.355Z","comments":true,"path":"api/articles/js到底要不要加分号.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/280h/alone-background_TJSWWAXG9T.jpg","text":"1. 争吵的由来行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。但是，从今天的角度来看，行尾使用分号其...","permalink":"/post/js到底要不要加分号","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":5,"path":"api/tags/JavaScript.json"}],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}