{"title":"LeetCode：整数反转","uid":"80fa170694c2738a195b06ce828cfe4a","slug":"LeetCode：整数反转","date":"2020-02-29T13:39:30.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/LeetCode：整数反转.json","keywords":null,"cover":null,"content":"<p>LeetCode第7号问题：整数反转</p>\n<h3 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>\n<p><strong>示例：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: 123\n输出: 321\n\n输入: -123\n输出: -321\n\n输入: 120\n输出: 21</code></pre>\n\n<p><strong>注意:</strong><br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>\n<h3 id=\"解法（java）\"><a href=\"#解法（java）\" class=\"headerlink\" title=\"解法（java）\"></a>解法（java）</h3><p>每次弹出数字’x’最后一位，并压入到’res’的后面，全部压入后，’x’与’res’即完全相反；</p>\n<p>在不使用数据结构的情况下可以借助数学方法来实现“弹出/压入”的操作：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 弹出\npop &#x3D; x % 10\nx &#x2F;&#x3D; 10\n\n&#x2F;&#x2F; 压入\ntemp &#x3D; y * 10 + pop\ny &#x3D; temp </code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>此方式有溢出风险，使用时应注意每次反转后是否溢出。</p></blockquote>\n<p>反转后数字的溢出情况可以使用Integer.MAX_VALUE和Integer.MIN_VALUE来实现</p>\n<p><strong>参考代码：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int reverse(int x) &#123;\n        long res &#x3D; 0;\n        while(x !&#x3D; 0) &#123;\n            res &#x3D; res * 10 + x % 10;\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE ? 0 : (int)res;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n","text":"LeetCode第7号问题：整数反转 题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例： 输入: 123 输出: 321 输入: -123 输出: -321 输入: 120 输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数...","link":"","photos":[],"count_time":{"symbolsCount":808,"symbolsTime":"1 mins."},"categories":[{"name":"算法学习","slug":"算法学习","count":2,"path":"api/categories/算法学习.json"}],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%B3%95%EF%BC%88java%EF%BC%89\"><span class=\"toc-text\">解法（java）</span></a></li></ol>","author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"文档导航","uid":"762d57d23f302a5afc8450b6572a5c7f","slug":"文档导航","date":"2020-03-16T09:03:15.000Z","updated":"2021-12-05T16:05:56.000Z","comments":true,"path":"api/articles/文档导航.json","keywords":null,"cover":null,"text":"前端开发 JavaScript/node.js 现代 JavaScript 教程 nodejs中文网 koa2官方文档 eggjs官方文档 w3school 阮一峰博客 ES6 入门教程 MDN loadash文档 前端工程化 Babel官网 webpack官方文档 npm官方网...","link":"","photos":[],"count_time":{"symbolsCount":345,"symbolsTime":"1 mins."},"categories":[{"name":"工具","slug":"工具","count":1,"path":"api/categories/工具.json"}],"tags":[],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"js实现选择排序","uid":"62f4259c1d3df5765faf228a85e43d10","slug":"js实现选择排序","date":"2020-01-04T14:00:07.000Z","updated":"2021-12-05T14:34:08.000Z","comments":true,"path":"api/articles/js实现选择排序.json","keywords":null,"cover":null,"text":" 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"算法学习","slug":"算法学习","count":2,"path":"api/categories/算法学习.json"}],"tags":[],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}