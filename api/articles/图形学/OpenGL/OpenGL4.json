{"title":"OpenGL「四」：在文件中编写Shader","uid":"65e058b963273b5b3e940e3659fb3ebc","slug":"图形学/OpenGL/OpenGL4","date":"2021-12-29T16:00:00.000Z","updated":"2023-12-18T16:50:30.857Z","comments":true,"path":"api/articles/图形学/OpenGL/OpenGL4.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/960w/animal-face_2P4CSFCJYF.jpg","content":"<p>前面用到了Shader绘制了一个红色的三角形，但是Shader是硬编码在代码中的，虽然是OpenGL想让我们这么写的，但是在实际开发中那肯定是不靠谱的，所以这次就尝试把Shader写到独立的文件中使用。</p>\n<h1 id=\"设计Shader文件\"><a href=\"#设计Shader文件\" class=\"headerlink\" title=\"设计Shader文件\"></a>设计Shader文件</h1><p>首先先在工程目录下创建文件<code>res/shader/Basic.shader</code>，用于存放Shader</p>\n<p><img src=\"/image/opengl/%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95.png\" alt=\"创建目录\"></p>\n<p>然后把代码中硬编码的Shader代码拷贝到<code>Basic.shader</code>中</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #E06C75\">#shader</span><span style=\"color: #ABB2BF\"> vertex</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">#version</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">330</span><span style=\"color: #ABB2BF\"> core</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #61AFEF\">layout</span><span style=\"color: #ABB2BF\">(location </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">) in vec4 position;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">main</span><span style=\"color: #ABB2BF\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    gl_Position </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> position;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #E06C75\">#shader</span><span style=\"color: #ABB2BF\"> fragment</span></span>\n<span class=\"line\"><span style=\"color: #E06C75\">#version</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">330</span><span style=\"color: #ABB2BF\"> core</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #61AFEF\">layout</span><span style=\"color: #ABB2BF\">(location </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">) out vec4 color;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">void</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">main</span><span style=\"color: #ABB2BF\">() &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    color </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">vec4</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #D19A66\">1.0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">0.0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">0.0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #D19A66\">1.0</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span></code></pre></div><p>像这样在文件中可以直接像正常写代码一样写两个Shader代码，只需要像声明GLSL版本一样使用<code>#shader fragment</code>和<code>#shader vertex</code>声明一下是那个Shader就可以了，至于cherno为什么这么写而不是把Shader拆分成两个文件来写，猜测可能是因为写在一个文件中可以只需要读取和绑定一次，而代码一般来说代码体积又不会太大，一次加载到内存处理起来很快，犯不上分文件带来的两次绑定的性能消耗吧？也可能就是单纯的学习项目懒的搞复杂…</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">特别注意</p>\n<p><p> <code>#shader fragment</code>和<code>#shader vertex</code>是自定义的用于区分Shader并不是OpenGL的定义。</p>\n</p>\n</div>\n<h1 id=\"使用流加载Shader\"><a href=\"#使用流加载Shader\" class=\"headerlink\" title=\"使用流加载Shader\"></a>使用流加载Shader</h1><p>这里逻辑比较简单，主要是使用<code>fstream</code>来创建文件读&#x2F;写流，然后循环的按行获取文件中的内容，一旦检测到包含<code>#shader xxxx</code>的行就检查具体的类型，确定类型后后续的行都认为是该类型的Shader代码把内容都写入到<code>ss</code>中存起来，最后使用结构体返回Shader的代码字符串。</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">...</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">#include</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">&lt;fstream&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">#include</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">&lt;string&gt;</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">#include</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">&lt;sstream&gt;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// Shader代码结构体，包含了两个Shader的代码字符串</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">struct</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">ShaderProgramSource</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    std::string vertex;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    std::string fragment;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #C678DD\">static</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">ShaderProgramSource</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">ParseShader</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #C678DD\">const</span><span style=\"color: #ABB2BF\"> std::</span><span style=\"color: #E5C07B\">string</span><span style=\"color: #C678DD\">&amp;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E06C75; font-style: italic\">filepath</span><span style=\"color: #ABB2BF\">) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 创建流并绑定文件</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    std::ifstream </span><span style=\"color: #61AFEF\">stream</span><span style=\"color: #ABB2BF\">(filepath);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 判断是否存在文件</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #56B6C2\">!</span><span style=\"color: #E5C07B\">stream</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">is_open</span><span style=\"color: #ABB2BF\">()) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        std::cout </span><span style=\"color: #C678DD\">&lt;&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">&quot;file open failed!&quot;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">&lt;&lt;</span><span style=\"color: #ABB2BF\"> std::endl;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 声明Shader类型枚举 </span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">enum</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #E5C07B\">ShaderType</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E06C75\">NONE</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #56B6C2\">-</span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #E06C75\">VERTEX</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #E06C75\">FRAGMENT</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #D19A66\">1</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 文件行数据</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    std::string line;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 字符串流，用于数据格式转换</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    std::stringstream </span><span style=\"color: #E5C07B\">ss</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">2</span><span style=\"color: #ABB2BF\">];</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // Shader类型</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    ShaderType type </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> ShaderType::NONE;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 按行获取Shader的代码</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">while</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #61AFEF\">getline</span><span style=\"color: #ABB2BF\">(stream, line)) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">        // 如果是声明语句行，获取类型赋值给type</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">line</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #98C379\">&quot;#shader&quot;</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> std::string::npos) &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">line</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #98C379\">&quot;vertex&quot;</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> std::string::npos)</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                type </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> ShaderType::VERTEX;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">if</span><span style=\"color: #ABB2BF\"> (</span><span style=\"color: #E5C07B\">line</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">find</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #98C379\">&quot;fragment&quot;</span><span style=\"color: #ABB2BF\">) </span><span style=\"color: #C678DD\">!=</span><span style=\"color: #ABB2BF\"> std::string::npos)</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">                type </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> ShaderType::FRAGMENT;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">        // 如果不是声明语句，就把当前行数据输入到字符串流中</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #C678DD\">else</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">            </span><span style=\"color: #E5C07B\">ss</span><span style=\"color: #ABB2BF\">[(</span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\">)type] </span><span style=\"color: #C678DD\">&lt;&lt;</span><span style=\"color: #ABB2BF\"> line </span><span style=\"color: #C678DD\">&lt;&lt;</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #98C379\">&quot;</span><span style=\"color: #56B6C2\">\\n</span><span style=\"color: #98C379\">&quot;</span><span style=\"color: #ABB2BF\">;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        &#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 关闭流</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #E5C07B\">stream</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #61AFEF\">close</span><span style=\"color: #ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">    // 返回包含Shader代码字符串的结构体</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    </span><span style=\"color: #C678DD\">return</span><span style=\"color: #ABB2BF\"> &#123;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">ss</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">0</span><span style=\"color: #ABB2BF\">].</span><span style=\"color: #61AFEF\">str</span><span style=\"color: #ABB2BF\">(),</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">        </span><span style=\"color: #E5C07B\">ss</span><span style=\"color: #ABB2BF\">[</span><span style=\"color: #D19A66\">1</span><span style=\"color: #ABB2BF\">].</span><span style=\"color: #61AFEF\">str</span><span style=\"color: #ABB2BF\">()</span><span style=\"color: #7F848E; font-style: italic\"> // 转换成字符串返回</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">    &#125;;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">&#125;</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">...</span></span></code></pre></div><h1 id=\"新的逻辑代码\"><a href=\"#新的逻辑代码\" class=\"headerlink\" title=\"新的逻辑代码\"></a>新的逻辑代码</h1><p>使用刚封装好的方法加载Shader代码</p>\n<div class=\"language-cpp\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">cpp</span><pre class=\"shiki one-dark-pro\" style=\"background-color: #282c34\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #ABB2BF\">...</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 加载Shader代码</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">ShaderProgramSource source </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">ParseShader</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #98C379\">&quot;res/shader/Basic.shader&quot;</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 创建Shader程序</span></span>\n<span class=\"line\"><span style=\"color: #C678DD\">unsigned</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #C678DD\">int</span><span style=\"color: #ABB2BF\"> shader </span><span style=\"color: #C678DD\">=</span><span style=\"color: #ABB2BF\"> </span><span style=\"color: #61AFEF\">CreateShader</span><span style=\"color: #ABB2BF\">(</span><span style=\"color: #E5C07B\">source</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">vertex</span><span style=\"color: #ABB2BF\">, </span><span style=\"color: #E5C07B\">source</span><span style=\"color: #ABB2BF\">.</span><span style=\"color: #E06C75\">fragment</span><span style=\"color: #ABB2BF\">);</span></span>\n<span class=\"line\"><span style=\"color: #7F848E; font-style: italic\">// 使用Shader</span></span>\n<span class=\"line\"><span style=\"color: #61AFEF\">glUseProgram</span><span style=\"color: #ABB2BF\">(shader);</span></span>\n<span class=\"line\"><span style=\"color: #ABB2BF\">...</span></span></code></pre></div><h1 id=\"再见三角形\"><a href=\"#再见三角形\" class=\"headerlink\" title=\"再见三角形\"></a>再见三角形</h1><p>我们可以随便改改片段着色器中的颜色输出为<code>color = vec4(1.0, 1.0, 0.0, 1.0);</code>，再按下<code>F5</code>运行代码验证结果，可以看到一个黄色的三角形，证明我们已经可以正确的使用文件加载Shader代码了。</p>\n<p><img src=\"/image/opengl/%E9%BB%84%E8%89%B2%E4%B8%89%E8%A7%92%E5%BD%A2.png\" alt=\"黄色三角形\"></p>\n","text":"前面用到了Shader绘制了一个红色的三角形，但是Shader是硬编码在代码中的，虽然是OpenGL想让我们这么写的，但是在实际开发中那肯定是不靠谱的，所以这次...","permalink":"/post/图形学/OpenGL/OpenGL4","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"图形学","slug":"图形学","count":5,"path":"api/categories/图形学.json"},{"name":"OpenGL","slug":"图形学/OpenGL","count":5,"path":"api/categories/图形学/OpenGL.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"图形开发","slug":"图形开发","count":5,"path":"api/tags/图形开发.json"},{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/tags/OpenGL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1Shader%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">设计Shader文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%B5%81%E5%8A%A0%E8%BD%BDShader\"><span class=\"toc-text\">使用流加载Shader</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%9A%84%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">新的逻辑代码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%A7%81%E4%B8%89%E8%A7%92%E5%BD%A2\"><span class=\"toc-text\">再见三角形</span></a></li></ol>","author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"d3入门「一」：在项目中使用d3","uid":"65dc118887986eec94800b37afb1763d","slug":"d3/1为什么使用D3","date":"2025-09-28T07:01:07.521Z","updated":"2025-09-28T11:25:59.067Z","comments":true,"path":"api/articles/d3/1为什么使用D3.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/280h/succulent-plant_T57PJUYFWM.jpg","text":"为什么使用D3D3 的全称是 Data-Driven Document 即数据驱动文档，是一个基于数据操作 DOM 的 Javascript 库，也是现有最流行...","permalink":"/post/d3/1为什么使用D3","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"d3","slug":"d3","count":5,"path":"api/categories/d3.json"}],"tags":[{"name":"d3","slug":"d3","count":5,"path":"api/tags/d3.json"},{"name":"数据可视化","slug":"数据可视化","count":5,"path":"api/tags/数据可视化.json"}],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"OpenGL「三」：你好三角形","uid":"7d4eb62a0f031a2c66f45b6854b89b78","slug":"图形学/OpenGL/OpenGL3","date":"2021-12-21T16:00:00.000Z","updated":"2023-12-18T13:15:11.521Z","comments":true,"path":"api/articles/图形学/OpenGL/OpenGL3.json","keywords":null,"cover":"https://images.unsplash.com/photo-1523371153586-b3b8e1782b44?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1632&q=80","text":"在之前的学习中，使用早期OpenGL绘制了一个三角形，以及了解了如何使用GLEW引入现代OpenGL的API,本篇就使用现代API重新的绘制一个三角形。全部代码...","permalink":"/post/图形学/OpenGL/OpenGL3","photos":[],"count_time":{"symbolsCount":"8.3k","symbolsTime":"8 mins."},"categories":[{"name":"图形学","slug":"图形学","count":5,"path":"api/categories/图形学.json"},{"name":"OpenGL","slug":"图形学/OpenGL","count":5,"path":"api/categories/图形学/OpenGL.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"图形开发","slug":"图形开发","count":5,"path":"api/tags/图形开发.json"},{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/tags/OpenGL.json"}],"author":{"name":"天然卷打工战士","slug":"blog-author","avatar":"https://pic-blog-1255296193.cos.ap-beijing.myqcloud.com/touxiang.jpg","link":"/","description":"未看此花时， <br> 此花与汝同归于寂； <br> 来看此花时， <br> 此花颜色一时明白过来。","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}