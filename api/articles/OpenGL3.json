{"title":"OpenGL「三」：你好三角形","uid":"7d4eb62a0f031a2c66f45b6854b89b78","slug":"OpenGL3","date":"2021-12-21T16:00:00.000Z","updated":"2021-12-25T15:50:40.000Z","comments":true,"path":"api/articles/OpenGL3.json","keywords":null,"cover":"https://images.unsplash.com/photo-1523371153586-b3b8e1782b44?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1632&q=80","content":"<p>在之前的学习中，使用早期OpenGL绘制了一个三角形，以及了解了如何使用<code>GLEW</code>引入现代OpenGL的API,本篇就使用现代API重新的绘制一个三角形。全部代码截图放在最末尾了，留作参考。</p>\n<h1 id=\"渲染管线\"><a href=\"#渲染管线\" class=\"headerlink\" title=\"渲染管线\"></a>渲染管线</h1><p>渲染管线指的是渲染的工作流程，不具体指向某一个单独的过程，也不是特指某一段编程代码(如:Shader，Shader只是管线中的一个过程)，感性点的理解可以是<code>从发送绘制指令开始到实际显示到画面里的过程，就是渲染管线</code>，下图展示了渲染管线的各个阶段：</p>\n<p><img src=\"https://learnopengl-cn.github.io/img/01/04/pipeline.png\" alt=\"pipeline\"></p>\n<p>在早期的使用的是固定管线，也就是说整个渲染管线的过程的实现都是固定的，可自定义程度有限，比如：需要开启光照，那我们就只能告诉调用线程的API来开启光照，至于光照的实现效果以及如何实现一个符合需求光照的则与程序员无关。</p>\n<p>在现代API中已经升级为可编程管线，可编程管线开放了部分阶段给程序员，可以使程序员更加灵活的实现项目中所需要的各种效果，而不需要付出太大的成本，上图中蓝色的部分就是可编程管线中可自定义的部分。</p>\n<h1 id=\"了解VAO，VBO\"><a href=\"#了解VAO，VBO\" class=\"headerlink\" title=\"了解VAO，VBO\"></a>了解VAO，VBO</h1><p>这两个概念细说起来很复杂，后面再进行深入的学习，现阶段感性的认知是：</p>\n<p><strong>VBO</strong></p>\n<p>VBO全称：顶点缓冲对象(Vertex Buffer Objects)，它可以在GPU中开辟一块空间用于存储大量的顶点数据，方便我们在使用时一次性发送大量的顶点数据到显卡上，提高性能。</p>\n<p><strong>VAO</strong></p>\n<p>VAO全称：顶点数组对象(Vertex Array Object)，一次完整的VBO的配置使犯错且复杂的，为了避免在切换不同VBO以及重复使用VBO，我们应该将VBO与VAO进行绑定，这样VAO便会记录下所需要的信息，然后在切换与重复使用时操作VAO即可。</p>\n<p>感性理解：一个用于记录描述VBO模型的对象，方便的切换VBO配置。</p>\n<h1 id=\"使用VBO\"><a href=\"#使用VBO\" class=\"headerlink\" title=\"使用VBO\"></a>使用VBO</h1><h2 id=\"创建VBO\"><a href=\"#创建VBO\" class=\"headerlink\" title=\"创建VBO\"></a>创建VBO</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\n&#x2F;&#x2F; 申请缓冲区\nunsigned int vbo; &#x2F;&#x2F; A\nglGenBuffers(1, &amp;vbo); &#x2F;&#x2F; B\nglBindBuffer(GL_ARRAY_BUFFER, vbo); &#x2F;&#x2F; C\n</code></pre>\n\n<p><code>A行</code>申请一个int类型变量，用于存放缓冲区的id。</p>\n<p><code>B行</code>申请一个缓冲区对象，第一个参数表示申请数量，第二个参数是使用哪个变量来存储申请成功后的id。</p>\n<p><code>C行</code>绑定id是vbo的缓冲区到<code>GL_ARRAY_BUFFER</code>类型的缓冲区上，缓冲区有很多种类型，由于我们这里是使用顶点缓冲区所以使用<code>GL_ARRAY_BUFFER</code>，其他缓冲区类型可以在<a href=\"https://docs.gl/gl4/glBindBuffer\">glBindBuffer | docs.gl</a>查看。</p>\n<h2 id=\"绑定数据\"><a href=\"#绑定数据\" class=\"headerlink\" title=\"绑定数据\"></a>绑定数据</h2><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F; A\nfloat vertexs[6] &#x3D; &#123;\n\t-0.5f, -0.5f,\n\t0.0f,   0.5f,\n\t0.5f,  -0.5f\n&#125;;\n\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\n\n&#x2F;&#x2F; B \nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);</code></pre>\n\n\n<p><code>A行</code>声明绘制三角形所需要的顶点位置，类型是一个float数组，每两个数据组成三角形的一个顶点位置信息。</p>\n<p><code>B行</code>绑定顶点数据到指定类型的的缓冲区上，第一个参数指定了绑定到<code>GL_ARRAY_BUFFER</code>类型的缓冲区上，第二个参数是告诉OpenGL缓冲区数据的大小，第三个参数是把实际的顶点数据传入到缓冲区中，第四个参数是缓冲区中数据的预期使用方式，有多种方式可供选择这里选择了<code>GL_STATIC</code>模式，其含义是<code>数据存储内容将被修改一次并多次使用。</code>，其他预期类型可查看:<a href=\"https://docs.gl/gl4/glBufferData\">glBufferData | docs.gl</a>。</p>\n<h2 id=\"解释数据的用途\"><a href=\"#解释数据的用途\" class=\"headerlink\" title=\"解释数据的用途\"></a>解释数据的用途</h2><p>OpenGL的顶点着色器(Vertex Shader)允许使用任何形式的输入，所以这就需要我们手动的告诉OpenGl如何去解释这些数据。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\n   float vertexs[6] &#x3D; &#123;\n\t-0.5f, -0.5f,\n\t0.0f,   0.5f,\n\t0.5f,  -0.5f\n&#125;;\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\n\t\nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);\n\nglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);&#x2F;&#x2F; A\nglEnableVertexAttribArray(0); &#x2F;&#x2F;B</code></pre>\n\n<p><code>A行</code>解释OpenGL如何使用缓冲区中的数据，这个解释只对当前的VBO生效，参数含义：</p>\n<ol>\n<li>第一个参数，表示顶点属性索引的值，与GLSL语言有关，表明本次解释的是某一特定的索引顶点属性，只要在Shader取值时布局索引对应上即可获取期望的数据，最大16；</li>\n<li>属性有几个分量；</li>\n<li>数据所使用的数据类型；</li>\n<li>是否归一化；</li>\n<li>一个分量数据的内存大小；</li>\n<li>在GL_ARRAY_BUFFER 缓冲区中，属性值第一次出现偏移量。</li>\n</ol>\n<p><code>B行</code>在配置好顶点属性后，如果需要使用需要手动开启对应索引的顶点属性，默认是关闭所有的顶点属性的。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果需要其他属性的配置，如颜色，法线等信息，可以多次调用<code>glVertexAttribPointer</code>函数进行解释，并使用<code>glEnableVertexAttribArray</code>来开启顶点属性。</p></blockquote>\n<p>此时按下<code>F5</code>运行项目会发现已经重新绘制出了上一篇的白色三角形。</p>\n<h1 id=\"使用VAO\"><a href=\"#使用VAO\" class=\"headerlink\" title=\"使用VAO\"></a>使用VAO</h1><p>VAO可以存储绑定顶点缓冲区与顶点属性值的信息，然后再绘制物体的时候只需要绑定相应的VAO就行了，可以方便的实现绘制不同物体。</p>\n<p>VAO存储的信息：</p>\n<ol>\n<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>\n<li>通过glVertexAttribPointer设置的顶点属性配置。</li>\n<li>通过glVertexAttribPointer调用与顶点属性关联的VBO。</li>\n</ol>\n<p><img src=\"https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png\" alt=\"VAO\"></p>\n<p>VAO使用起来非常简单就像VBO的创建一样，只需要调用<code>glGenVertexArrays</code>获取索引，然后使用<code>glBindVertexArray</code>绑定即可，绑定成功后任何随后的顶点属性调用都会储存在这个VAO中。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F; 申请VAO\nunsigned int vao;\nglGenVertexArrays(1, &amp;vao);\n&#x2F;&#x2F; 绑定VAO，绑定后所有的调用都会记录到当前VAO中\nglBindVertexArray(vao);\n\n\n&#x2F;&#x2F; 顶点属性调用\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);\nglEnableVertexAttribArray(0);\n\n&#x2F;&#x2F; 绘制循环\n...\n&#x2F;&#x2F; 使用VAO\nglBindVertexArray(vao);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n...\n</code></pre>\n\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">特别注意</p>\n<p>如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</p>\n\n</div>\n<p>再次按下<code>F5</code>运行项目，成功绘制出白色三角形。</p>\n<h1 id=\"使用Shader\"><a href=\"#使用Shader\" class=\"headerlink\" title=\"使用Shader\"></a>使用Shader</h1><p>虽然成功绘制出了白色三角形，但是现代OpenGL最厉害的特性<code>Shader</code>却一点没用上，下面就通过为三角形上色来入手，学习下<code>Shader</code>的使用。</p>\n<p>Shader是一段代码片段，它运行在GPU上，作用是告诉GPU当前处理的图形应该如何绘制，比如：顶点在哪里，当前这个像素应该是什么样的等等，它是整个渲染管线的一部分，只不过是部分开放出来给我们自定义而已。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">粗暴理解</p>\n<p><p>Shader就是OpenGL在绘制时暴露出来的回调函数，其上下文是属于OpenGL的，所以千万不要当做是我们开发程序的部分，就是一个回调函数而已。</p>\n</p>\n</div>\n<h2 id=\"为什么需要Shader\"><a href=\"#为什么需要Shader\" class=\"headerlink\" title=\"为什么需要Shader\"></a>为什么需要Shader</h2><p>因为运行在GPU上效率高，比如我们需要绘制1000个像素的样色并不需要循环访问1000遍而是可以同时访问这1000个像素点。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>但是不能因为GPU快就把全部逻辑都交给GPU来做，很多时候还是要在CPU上计算，最后把结果一口气全部发到GPU上更快。</p></blockquote>\n<h2 id=\"顶点着色器与片段着色器\"><a href=\"#顶点着色器与片段着色器\" class=\"headerlink\" title=\"顶点着色器与片段着色器\"></a>顶点着色器与片段着色器</h2><p>常用的Shader有两个<code>Vertex Shader(顶点着色器)</code>和<code>Fragment Shader(片段着色器)</code>，它们的作用是：</p>\n<p><strong>顶点着色器</strong></p>\n<p>用于描述顶点的位置，在3D空间中一个点具体应该显示在哪里取决于我们如何进行观察，通过顶点着色器就可以让原始的顶点通过矩阵变换显示到屏幕中正确的位置。</p>\n<p>其作用对象是每一个顶点，每一个顶点会调用一次顶点着色器。</p>\n<p><strong>片段着色器</strong></p>\n<p>其作用对象是在确认了顶点信息后，最终会绘制到屏幕上的每一个像素点，每一个像素点会调用一次片段着色器。</p>\n<p>所以也可以叫做<code>像素着色器</code>，我觉得叫像素着色器更好理解，因为其作用就是处理绘制一个图形到屏幕时，该图形在屏幕所占面积的像素该如何显示的逻辑，操作的对象就是屏幕上图形所占面积的所有像素点，叫<code>片段着色器</code>总觉得词不达意，还是<code>像素着色器</code>更形象。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">举例说明</p>\n<p>在纸上画一个三角形并涂满颜色就好比我们使用Shader来绘制一个三角形： </p>\n<p>1.确定三角形在纸上的三个顶点在哪，对应的就是<code>顶点着色器</code>的工作；</p>\n<p>2.给三角形涂满颜色，并且确定都是什么颜色，对应的就是<code>片段着色器</code>的工作，只不过涂色粒度是像素而已。</p>\n\n</div>\n<h2 id=\"编写Shader\"><a href=\"#编写Shader\" class=\"headerlink\" title=\"编写Shader\"></a>编写Shader</h2><p>编写Shader的过程其实和写代码是一样的，<code>编写代码</code>-&gt;<code>编译代码</code>-&gt;<code>连接程序</code>-&gt;<code>喂给OpenGL</code>，只不过这些个过程都内嵌到了我们的工程中作为代码的一部分存在，需要我们手动的来实现。</p>\n<h3 id=\"Shader代码\"><a href=\"#Shader代码\" class=\"headerlink\" title=\"Shader代码\"></a>Shader代码</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">&#x2F;&#x2F; A\nstd::string vertexShader &#x3D;\n\t&#x2F;&#x2F; B\n\t&quot;#version 330 core\\n&quot;\n\t&quot;\\n&quot;\n\t&#x2F;&#x2F; C\n\t&quot;layout(location &#x3D; 0) in vec4 position;\\n&quot;\n\t&quot;\\n&quot;\n\t&quot;void main() &#123;\\n&quot;\n\t&#x2F;&#x2F; D\n\t&quot;\tgl_Position &#x3D; position;\\n&quot;\n\t&quot;&#125;&quot;;\n&#x2F;&#x2F; E \nstd::string fragmentShader &#x3D;\n\t&quot;#version 330 core\\n&quot;\n\t&quot;\\n&quot;\n\t&quot;layout(location &#x3D; 0) out vec4 color;\\n&quot;\n\t&quot;\\n&quot;\n\t&quot;void main() &#123;\\n&quot;\n\t&#x2F;&#x2F; F\n\t&quot;\tcolor &#x3D; vec4(1.0, 0.0, 0.0, 1.0);\\n&quot;\n\t&quot;&#125;&quot;;</code></pre>\n<p><code>A行</code>顶点着色器</p>\n<p><code>B行</code>声明GLSL(OpenGL为开发Shader提供的编程语言)使用的版本</p>\n<p><code>C行</code>layout(location = 0) 确定使用哪一个索引的顶点属性对象，这个索引就是glVertexAttribPointer第一个参数设置的索引，使用一致的索引就可以获取到对应的内存布局的顶点属性。后面的<code>in/out</code>用于定义着色器的输入输出，这里是定义了一个名叫<code>position</code>的向量表示顶点位置，这个变量的值来自于顶点属性对象</p>\n<p><code>D行</code>赋值到GLSL的内建变量上，该变量表示顶点的实际坐标</p>\n<p><code>E行</code>片段着色器</p>\n<p><code>F行</code>设置像素点颜色，OpenGL中颜色值使用vec4的向量表示，四个分量分别是<code>r、g、b、a</code>其区间在<code>0~1</code></p>\n<h3 id=\"编译着色器\"><a href=\"#编译着色器\" class=\"headerlink\" title=\"编译着色器\"></a>编译着色器</h3><pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\nstatic int ComplieShader(unsigned int type, const std::string&amp; source) &#123;\n\t&#x2F;&#x2F; A\n\tunsigned int shader &#x3D; glCreateShader(type);\n\n\t&#x2F;&#x2F; B\n\tconst char* src &#x3D; source.c_str();\n\t&#x2F;&#x2F; C\n\tglShaderSource(shader, 1, &amp;src, nullptr);\n\t&#x2F;&#x2F; D\n\tglCompileShader(shader);\n\n\t&#x2F;&#x2F; E开始\n\tint result;\n\tglGetShaderiv(shader, GL_COMPILE_STATUS, &amp;result);\n\n\n\tif (result &#x3D;&#x3D; GL_FALSE) &#123;\n\t\tint length;\n\t\tglGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);\n\t\tchar* message &#x3D; (char*)alloca(length * sizeof(char));\n\n\t\tglGetShaderInfoLog(shader, length, &amp;length, message);\n\n\t\tstd::cout &lt;&lt; &quot;Failed to Compile&quot; &lt;&lt; (type &#x3D;&#x3D; GL_VERTEX_SHADER ? &quot;vertex&quot; : &quot;fragment&quot;) &lt;&lt; std::endl;\n\t\tstd::cout &lt;&lt; message &lt;&lt; std::endl;\n\n\t\tglDeleteShader(shader);\n\n\t\treturn 0;\n\t&#125;\n\t&#x2F;&#x2F; E结束\n\n\t&#x2F;&#x2F; F\n\treturn shader;\n&#125;\n</code></pre>\n\n<p>编译着色器是一个重复的工作，所以可以封装为一个方法使用</p>\n<p><code>A行</code>申请一个指定类型的着色器，好比于创建一个C++文件</p>\n<p><code>B行</code>把C++风格的字符串转换为C风格的字符串，因为OpenGL是C开发的所以需要转换下</p>\n<p><code>C行</code>给指定的着色器绑定源码，好比把代码写到文件里</p>\n<p><code>D行</code>编译着色器，好比于把C++代码编译成.obj文件</p>\n<p><code>E区域</code>因为Shader是运行在GPU没法直接发送消息到CPU这边，所以需要写一些代码来获取Shader编译的日志信息，如果发生了错误可以打印出错误信息供调试使用</p>\n<p><code>F行</code>返回着色器的id</p>\n<h3 id=\"创建着色器程序\"><a href=\"#创建着色器程序\" class=\"headerlink\" title=\"创建着色器程序\"></a>创建着色器程序</h3><p>Opengl的着色器程序总会让人头晕，在程序里多了一OpenGL就够了，为什么OpenGL里又多个程序，这程序有啥用，为什么这么写之类的疑问，这里其实有几个点捋顺了会好理解很多：</p>\n<ol>\n<li><code>着色器程序</code>类似于编译后链接各个文件的过程，它把多个单独的着色器链接在一起打包成一个整体（就好比C++能编程成<code>.exe</code>的可执行程序或者是<code>.lib</code>的链接库一样），绑定给OpenGL后，在渲染对象的时候激活这个着色器程序，我们可以先创建多个<code>着色器程序</code>等到需要的时候切换到特定的程序上</li>\n<li> OpenGL是一个巨大的状态机，所以它一定是有一个有限的逻辑变化并且根据逻辑状态的变化不停接收输入，产出输出的东西，<code>着色器程序</code>就是这个机器中的一个部分，当OpenGL的状态切换到计算<code>顶点/片段</code>信息时，就需要<code>着色器程序</code>这个工具来操作，所以虽然叫<code>着色器程序</code>但其实相当于OpenGL这个大机器中的一个小部位，甚至直接理解成动态绑定给OpenGL的一个库也不是不行</li>\n</ol>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\n\nstatic int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader) &#123;\n\t&#x2F;&#x2F; A\n\tunsigned int program &#x3D; glCreateProgram();\n\n\t&#x2F;&#x2F; B\n\tunsigned int vs &#x3D; ComplieShader(GL_VERTEX_SHADER, vertexShader);\n\tunsigned int fs &#x3D; ComplieShader(GL_FRAGMENT_SHADER, fragmentShader);\n\n\t&#x2F;&#x2F; C\n\tglAttachShader(program, vs);\n\tglAttachShader(program, fs);\n\n\t&#x2F;&#x2F; D\n\tglLinkProgram(program);\n\n\t&#x2F;&#x2F; E\n\tglValidateProgram(program);\n\n\treturn program;\n\n&#125;\n</code></pre>\n\n<p><code>A行</code>创建一个<code>着色器程序</code>，好比创建一个C++工程</p>\n<p><code>B行</code>调用编译着色器代码，获取到<code>编译后的着色器</code>，好比获取了需要连接的.obj文件</p>\n<p><code>C行</code>把<code>着色器</code>添加到<code>着色器程序</code>里，好比把文件添加到了工程里</p>\n<p><code>D行</code>链接着色器到<code>着色器程序</code>，好比链接程序把多个.obj链接到一个<code>.exe/.lib</code>上，此时就像我们可以直接使用可执行程序或者运行库一样，直接使用这个<code>着色器程序</code>就以为着所有相关信息都能获取到</p>\n<p><code>E行</code>校验<code>着色器程序</code>是否正确</p>\n<h3 id=\"启用着色器程序\"><a href=\"#启用着色器程序\" class=\"headerlink\" title=\"启用着色器程序\"></a>启用着色器程序</h3><p>在代码里我们只需要调用CreateShader并传入前面编写的Shader代码模板获取到一个可用<code>着色器程序</code>id，并通过<code>glUseProgram</code>函数启用即可。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">\n&#x2F;&#x2F; 定义CreateShader与ComplieShader函数\n\n&#x2F;&#x2F; 编写vertexShader与fragmentShader的代码\n\nunsigned int shader &#x3D; CreateShader(vertexShader, fragmentShader);\nglUseProgram(shader);\n\n\n&#x2F;&#x2F; 在绘制循环中，正常调用draw call\nglDrawArrays(GL_TRIANGLES, 0, 3);\n</code></pre>\n\n<p>此时按下<code>F5</code>会看到一个红色的三角形，至此使用Shader编程开发一个简(复)单(杂)的三角形就完成啦。</p>\n<p><img src=\"/image/opengl/%E4%B8%89%E8%A7%92%E5%BD%A2.png\" alt=\"红色三角形\"></p>\n<h1 id=\"容易晕的点\"><a href=\"#容易晕的点\" class=\"headerlink\" title=\"容易晕的点\"></a>容易晕的点</h1><p>我们在代码中所有对OpenGL的调用都是一些命令函数，其具体过程都是在GPU中实现且最后并不会返回实际的东西回来，都是返回我们调用的函数所期望产生的对象的唯一标识id（也可能是索引）</p>\n<p>所以不像正常面向对象时的逻辑：</p>\n<ol>\n<li>我有一个缓冲区对象</li>\n<li>我要操作什么，缓冲区对象.xxx();</li>\n</ol>\n<p>而是这样：</p>\n<ol>\n<li>程序：GPU给我搞一个缓冲区对象</li>\n<li>GPU：搞完了，id是xxx</li>\n<li>程序：OK，GPU我有一个缓冲区对象id是xxx，帮我把它绑定到<code>GL_ARRAY_BUFFER</code>这个缓冲区上</li>\n<li>GPU：搞完了</li>\n<li>程序：我有一个缓冲区对象id是xxx，我要这样这样描述…</li>\n<li>GPU：OK</li>\n<li>程序：我有一个缓冲区对象id是xxx…</li>\n<li>GPU: OK</li>\n</ol>\n<!-- ![红色三角形](/image/opengl/code.png) -->\n<h1 id=\"参考代码\"><a href=\"#参考代码\" class=\"headerlink\" title=\"参考代码\"></a>参考代码</h1><center>\n<img style=\"height: 800px;\" src=\"/image/opengl/code.png\"/>\n在新标签页中打开查看高清图\n</center>","feature":true,"text":"在之前的学习中，使用早期OpenGL绘制了一个三角形，以及了解了如何使用GLEW引入现代OpenGL的API,本篇就使用现代API重新的绘制一个三角形。全部代码截图放在最末尾了，留作参考。 渲染管线渲染管线指的是渲染的工作流程，不具体指向某一个单独的过程，也不是特指某一段编程代码...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/categories/OpenGL.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"图形开发","slug":"图形开发","count":5,"path":"api/tags/图形开发.json"},{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/tags/OpenGL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF\"><span class=\"toc-text\">渲染管线</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%86%E8%A7%A3VAO%EF%BC%8CVBO\"><span class=\"toc-text\">了解VAO，VBO</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8VBO\"><span class=\"toc-text\">使用VBO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BAVBO\"><span class=\"toc-text\">创建VBO</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">绑定数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E7%94%A8%E9%80%94\"><span class=\"toc-text\">解释数据的用途</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8VAO\"><span class=\"toc-text\">使用VAO</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8Shader\"><span class=\"toc-text\">使用Shader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Shader\"><span class=\"toc-text\">为什么需要Shader</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E4%B8%8E%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8\"><span class=\"toc-text\">顶点着色器与片段着色器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99Shader\"><span class=\"toc-text\">编写Shader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Shader%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">Shader代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E7%9D%80%E8%89%B2%E5%99%A8\"><span class=\"toc-text\">编译着色器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">创建着色器程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%AF%E7%94%A8%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">启用着色器程序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E6%98%93%E6%99%95%E7%9A%84%E7%82%B9\"><span class=\"toc-text\">容易晕的点</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">参考代码</span></a></li></ol>","author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"OpenGL「四」：在文件中编写Shader","uid":"65e058b963273b5b3e940e3659fb3ebc","slug":"OpenGL4","date":"2021-12-29T16:00:00.000Z","updated":"2021-12-30T15:23:34.000Z","comments":true,"path":"api/articles/OpenGL4.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/960w/animal-face_2P4CSFCJYF.jpg","text":"前面用到了Shader绘制了一个红色的三角形，但是Shader是硬编码在代码中的，虽然是OpenGL想让我们这么写的，但是在实际开发中那肯定是不靠谱的，所以这次就尝试把Shader写到独立的文件中使用。 设计Shader文件首先先在工程目录下创建文件res/shader/Basi...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/categories/OpenGL.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"图形开发","slug":"图形开发","count":5,"path":"api/tags/图形开发.json"},{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/tags/OpenGL.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"关于0.1+0.2!=0.3这件事","uid":"6160cc6d102bffa77808f7eb2e12f02e","slug":"浮点数的定义","date":"2021-12-13T16:00:00.000Z","updated":"2022-01-16T08:52:19.636Z","comments":true,"path":"api/articles/浮点数的定义.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/960w/curious-sheep_QNQ5HNPDTJ.jpg","text":"0.1 + 0.2 === 0.3吗？在JavaScript有一个经典的面试题，那就是”0.1 + 0.2 === 0.3吗？” 这个题看起来非常的弱智哈，只要小本毕业了肯定都秒答”必须的啊”，啊，要这么认为那这题肯定是挂了，嗯。 然后简单敲一下，啊，还真就错了。 原因是计算结果...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"分享","slug":"分享","count":1,"path":"api/categories/分享.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/tags/JavaScript.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}