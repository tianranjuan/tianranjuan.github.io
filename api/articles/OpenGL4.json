{"title":"OpenGL「四」：在文件中编写Shader","uid":"65e058b963273b5b3e940e3659fb3ebc","slug":"OpenGL4","date":"2021-12-29T16:00:00.000Z","updated":"2021-12-30T15:23:34.000Z","comments":true,"path":"api/articles/OpenGL4.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/960w/animal-face_2P4CSFCJYF.jpg","content":"<p>前面用到了Shader绘制了一个红色的三角形，但是Shader是硬编码在代码中的，虽然是OpenGL想让我们这么写的，但是在实际开发中那肯定是不靠谱的，所以这次就尝试把Shader写到独立的文件中使用。</p>\n<h1 id=\"设计Shader文件\"><a href=\"#设计Shader文件\" class=\"headerlink\" title=\"设计Shader文件\"></a>设计Shader文件</h1><p>首先先在工程目录下创建文件<code>res/shader/Basic.shader</code>，用于存放Shader</p>\n<p><img src=\"/image/opengl/04/%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95.png\" alt=\"创建目录\"></p>\n<p>然后把代码中硬编码的Shader代码拷贝到<code>Basic.shader</code>中</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#shader vertex\n#version 330 core\n\nlayout(location &#x3D; 0) in vec4 position;\n\nvoid main() &#123;\n\tgl_Position &#x3D; position;\n&#125;;\n\n\n#shader fragment\n#version 330 core\n\nlayout(location &#x3D; 0) out vec4 color;\n\nvoid main() &#123;\n\tcolor &#x3D; vec4(1.0, 0.0, 0.0, 1.0);\n&#125;;</code></pre>\n\n<p>像这样在文件中可以直接像正常写代码一样写两个Shader代码，只需要像声明GLSL版本一样使用<code>#shader fragment</code>和<code>#shader vertex</code>声明一下是那个Shader就可以了，至于cherno为什么这么写而不是把Shader拆分成两个文件来写，猜测可能是因为写在一个文件中可以只需要读取和绑定一次，而代码一般来说代码体积又不会太大，一次加载到内存处理起来很快，犯不上分文件带来的两次绑定的性能消耗吧？也可能就是单纯的学习项目懒的搞复杂…</p>\n<div class=\"custom-quote danger\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M19.76 5.23C15.84 5.23 12 2 12 2C12 2 8.15996 5.23 4.23996 5.23C4.23996 5.23 1.86996 16.99 12 22C22.13 16.99 19.76 5.23 19.76 5.23Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12 8V13\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 16H12\"></path>\n</svg>\n</span>\n<p class=\"custom-quote-title\">特别注意</p>\n<p><p> <code>#shader fragment</code>和<code>#shader vertex</code>是自定义的用于区分Shader并不是OpenGL的定义。</p>\n</p>\n</div>\n<h1 id=\"使用流加载Shader\"><a href=\"#使用流加载Shader\" class=\"headerlink\" title=\"使用流加载Shader\"></a>使用流加载Shader</h1><p>这里逻辑比较简单，主要是使用<code>fstream</code>来创建文件读/写流，然后循环的按行获取文件中的内容，一旦检测到包含<code>#shader xxxx</code>的行就检查具体的类型，确定类型后后续的行都认为是该类型的Shader代码把内容都写入到<code>ss</code>中存起来，最后使用结构体返回Shader的代码字符串。</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">...\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n\n&#x2F;&#x2F; Shader代码结构体，包含了两个Shader的代码字符串\nstruct ShaderProgramSource &#123;\n\tstd::string vertex;\n\tstd::string fragment;\n&#125;;\n\nstatic ShaderProgramSource ParseShader(const std::string&amp; filepath) &#123;\n    &#x2F;&#x2F; 创建流并绑定文件\n\tstd::ifstream stream(filepath);\n    \n    &#x2F;&#x2F; 判断是否存在文件\n\tif (!stream.is_open()) &#123;\n\t\tstd::cout &lt;&lt; &quot;file open failed!&quot; &lt;&lt; std::endl;\n\t&#125;\n\n    &#x2F;&#x2F; 声明Shader类型枚举 \n\tenum ShaderType &#123;\n\t\tNONE &#x3D; -1, VERTEX &#x3D; 0, FRAGMENT &#x3D; 1\n\t&#125;;\n\n    &#x2F;&#x2F; 文件行数据\n\tstd::string line;\n    &#x2F;&#x2F; 字符串流，用于数据格式转换\n\tstd::stringstream ss[2];\n    &#x2F;&#x2F; Shader类型\n\tShaderType type &#x3D; ShaderType::NONE;\n    &#x2F;&#x2F; 按行获取Shader的代码\n\twhile (getline(stream, line)) &#123;\n        &#x2F;&#x2F; 如果是声明语句行，获取类型赋值给type\n\t\tif (line.find(&quot;#shader&quot;) !&#x3D; std::string::npos) &#123;\n\t\t\tif (line.find(&quot;vertex&quot;) !&#x3D; std::string::npos)\n\t\t\t\ttype &#x3D; ShaderType::VERTEX;\n\t\t\telse if (line.find(&quot;fragment&quot;) !&#x3D; std::string::npos)\n\t\t\t\ttype &#x3D; ShaderType::FRAGMENT;\n\t\t&#125;\n        &#x2F;&#x2F; 如果不是声明语句，就把当前行数据输入到字符串流中\n\t\telse &#123;\n\t\t\tss[(int)type] &lt;&lt; line &lt;&lt; &quot;\\n&quot;;\n\t\t&#125;\n\t&#125;\n    &#x2F;&#x2F; 关闭流\n\tstream.close();\n    &#x2F;&#x2F; 返回包含Shader代码字符串的结构体\n\treturn &#123;\n\t\tss[0].str(),\n\t\tss[1].str() &#x2F;&#x2F; 转换成字符串返回\n\t&#125;;\n&#125;\n...</code></pre>\n\n\n<h1 id=\"新的逻辑代码\"><a href=\"#新的逻辑代码\" class=\"headerlink\" title=\"新的逻辑代码\"></a>新的逻辑代码</h1><p>使用刚封装好的方法加载Shader代码</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">...\n&#x2F;&#x2F; 加载Shader代码\nShaderProgramSource source &#x3D; ParseShader(&quot;res&#x2F;shader&#x2F;Basic.shader&quot;);\n&#x2F;&#x2F; 创建Shader程序\nunsigned int shader &#x3D; CreateShader(source.vertex, source.fragment);\n&#x2F;&#x2F; 使用Shader\nglUseProgram(shader);\n...</code></pre>\n\n<h1 id=\"再见三角形\"><a href=\"#再见三角形\" class=\"headerlink\" title=\"再见三角形\"></a>再见三角形</h1><p>我们可以随便改改片段着色器中的颜色输出为<code>color = vec4(1.0, 1.0, 0.0, 1.0);</code>，再按下<code>F5</code>运行代码验证结果，可以看到一个黄色的三角形，证明我们已经可以正确的使用文件加载Shader代码了。</p>\n<p><img src=\"/image/opengl/04/%E9%BB%84%E8%89%B2%E4%B8%89%E8%A7%92%E5%BD%A2.png\" alt=\"黄色三角形\"></p>\n","feature":true,"text":"前面用到了Shader绘制了一个红色的三角形，但是Shader是硬编码在代码中的，虽然是OpenGL想让我们这么写的，但是在实际开发中那肯定是不靠谱的，所以这次就尝试把Shader写到独立的文件中使用。 设计Shader文件首先先在工程目录下创建文件res/shader/Basi...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/categories/OpenGL.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"图形开发","slug":"图形开发","count":5,"path":"api/tags/图形开发.json"},{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/tags/OpenGL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1Shader%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">设计Shader文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%B5%81%E5%8A%A0%E8%BD%BDShader\"><span class=\"toc-text\">使用流加载Shader</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%9A%84%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">新的逻辑代码</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%8D%E8%A7%81%E4%B8%89%E8%A7%92%E5%BD%A2\"><span class=\"toc-text\">再见三角形</span></a></li></ol>","author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"WebGL简介","uid":"aca999fb1d2ad3a7f97e1cef456c301b","slug":"[分享]WebGL简介","date":"2022-04-24T16:00:00.000Z","updated":"2022-04-25T13:59:17.912Z","comments":true,"path":"api/articles/[分享]WebGL简介.json","keywords":null,"cover":"https://cdn.stocksnap.io/img-thumbs/960w/crescent-moon_CO08LAFBTH.jpg","text":"OpenGLOpenGL一般被认为是一套跨平台的图形开发API，本质上是一套标准，所以和类似编程语言的标准一样OpenGL是没有代码实现的，其具体实现由显卡厂商进行实现。 OpenGL规范只是严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现的，将由O...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"分享","slug":"分享","count":2,"path":"api/categories/分享.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":3,"path":"api/tags/JavaScript.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"OpenGL「三」：你好三角形","uid":"7d4eb62a0f031a2c66f45b6854b89b78","slug":"OpenGL3","date":"2021-12-21T16:00:00.000Z","updated":"2021-12-25T15:50:40.000Z","comments":true,"path":"api/articles/OpenGL3.json","keywords":null,"cover":"https://images.unsplash.com/photo-1523371153586-b3b8e1782b44?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1632&q=80","text":"在之前的学习中，使用早期OpenGL绘制了一个三角形，以及了解了如何使用GLEW引入现代OpenGL的API,本篇就使用现代API重新的绘制一个三角形。全部代码截图放在最末尾了，留作参考。 渲染管线渲染管线指的是渲染的工作流程，不具体指向某一个单独的过程，也不是特指某一段编程代码...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/categories/OpenGL.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"图形开发","slug":"图形开发","count":5,"path":"api/tags/图形开发.json"},{"name":"OpenGL","slug":"OpenGL","count":5,"path":"api/tags/OpenGL.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}