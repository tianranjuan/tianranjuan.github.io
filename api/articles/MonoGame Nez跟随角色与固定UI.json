{"title":"MonoGame Nez跟随角色与固定UI","uid":"e045146adaed8a16cc8d2f3b3398f352","slug":"MonoGame Nez跟随角色与固定UI","date":"2020-06-17T16:00:00.000Z","updated":"2021-12-07T13:57:26.000Z","comments":true,"path":"api/articles/MonoGame Nez跟随角色与固定UI.json","keywords":null,"cover":"https://images.pexels.com/photos/598917/pexels-photo-598917.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260","content":"<h2 id=\"摄像机跟随角色\"><a href=\"#摄像机跟随角色\" class=\"headerlink\" title=\"摄像机跟随角色\"></a>摄像机跟随角色</h2><p>框架提供了FollowCamera摄像机来方便的创建跟随摄像机，只需要传入一个实体即可实现对该实体的跟踪。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">Camera.Entity.AddComponent(new FollowCamera(soneEntity));</code></pre>\n\n<p>在使用了这个摄像机后UI组件会出现虽然显示在正确的位置但是并不能正确响应的问题，该问题的原因是在不使用任何渲染器的情况下，UI组件也会被摄像机进行了视口与游戏世界的坐标转换，导致UI看似显示正常但是不能正确响应交互的现象，为了解决这个问题我们需要把UI与游戏世界使用不同渲染器分开渲染来达到目标效果，下面就通过使用<code>ScreenSpaceRenderer</code>渲染器来解决这个问题。</p>\n<h2 id=\"固定UI\"><a href=\"#固定UI\" class=\"headerlink\" title=\"固定UI\"></a>固定UI</h2><p><strong>ScreenSpaceRenderer渲染器</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Renderer that renders using its own Camera which doesnt move.</p>\n<p>使用一个渲染器，渲染器拥有自己的摄像机，该摄像机不会进行移动。</p></blockquote>\n<p>通过渲染器的描述我们能发现这个渲染器在渲染时拥有自己的摄像机并且该摄像机也不会进行移动，正好符合我们的要求所以我们尝试用这个渲染器来进行UI的渲染。</p>\n<p>下面开始搞起来。</p>\n<p>添加一个<code>ScreenSpaceRenderer</code>到场景中。</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\n&#x2F;&#x2F; ScreenSpaceRenderer(int renderOrder, params int[] renderLayers)\n&#x2F;&#x2F; renderOrder: 渲染器的渲染时的顺序\n&#x2F;&#x2F; renderLayers: 使用此渲染器渲染时的层级，如果组件设置的RenderLayer不在列表中则不会被这个渲染器渲染，而是被默认渲染器渲染\n\nAddRenderer(new ScreenSpaceRenderer(1, 1, 2));\n</code></pre>\n<p>设置<code>RenderLayer</code>(渲染层)</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">\nvar Canvas &#x3D; CreateEntity(&quot;Canvas&quot;).AddComponent&lt;UICanvas&gt;(new UICanvas());\nCanvas.RenderLayer &#x3D; 1;\n&#x2F;&#x2F; draw UI</code></pre>\n\n<h3 id=\"RenderLayer\"><a href=\"#RenderLayer\" class=\"headerlink\" title=\"RenderLayer\"></a>RenderLayer</h3><p>并不是所有组件都会有RenderLayer属性，只有集成在RenderableComponent的组件才会有这个属性, 如UICanvas组件</p>\n<pre class=\"line-numbers language-c#\" data-language=\"c#\"><code class=\"language-c#\">public class UICanvas : RenderableComponent, IUpdatable\n</code></pre>\n\n\n","text":"摄像机跟随角色框架提供了FollowCamera摄像机来方便的创建跟随摄像机，只需要传入一个实体即可实现对该实体的跟踪。 Camera.Entity.AddComponent(new FollowCamera(soneEntity)); 在使用了这个摄像机后UI组件会出现虽然显示...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"MonoGame","slug":"MonoGame","count":4,"path":"api/categories/MonoGame.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"MonoGame","slug":"MonoGame","count":4,"path":"api/tags/MonoGame.json"},{"name":"Nez","slug":"Nez","count":2,"path":"api/tags/Nez.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%91%84%E5%83%8F%E6%9C%BA%E8%B7%9F%E9%9A%8F%E8%A7%92%E8%89%B2\"><span class=\"toc-text\">摄像机跟随角色</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%BA%E5%AE%9AUI\"><span class=\"toc-text\">固定UI</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RenderLayer\"><span class=\"toc-text\">RenderLayer</span></a></li></ol></li></ol>","author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MonoGame Nez分辨率切换ui定位不准","uid":"4733d01d48a0a10d2db65c3579578d4b","slug":"MonoGame Nez分辨率切换ui定位不准","date":"2020-06-18T16:00:00.000Z","updated":"2021-12-07T13:57:24.000Z","comments":true,"path":"api/articles/MonoGame Nez分辨率切换ui定位不准.json","keywords":null,"cover":"https://images.pexels.com/photos/598917/pexels-photo-598917.jpeg?auto=compress&cs=tinysrgb&dpr=3&h=750&w=1260","text":"在设置Stage.IsFullScreen属性为true时，切换分辨率会导致ui点击位置发生偏移，所以只需要把该属性设置为false或者不设置即可。 在设置Canvas.IsFullScreen属性为true时，在原分辨率下ui点击位置同样发生偏移，同时在切换分辨率时ui的定位也...","link":"","photos":[],"count_time":{"symbolsCount":172,"symbolsTime":"1 mins."},"categories":[{"name":"MonoGame","slug":"MonoGame","count":4,"path":"api/categories/MonoGame.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"MonoGame","slug":"MonoGame","count":4,"path":"api/tags/MonoGame.json"},{"name":"Nez","slug":"Nez","count":2,"path":"api/tags/Nez.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MonoGame官方文档(二)","uid":"acf46439f7beafe8650eed8a03f181c0","slug":"MonoGame官方文档(二)","date":"2020-06-11T16:00:00.000Z","updated":"2021-12-07T13:55:18.000Z","comments":true,"path":"api/articles/MonoGame官方文档(二).json","keywords":null,"cover":"https://images.pexels.com/photos/1030977/pexels-photo-1030977.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=500","text":"添加内容这部分内容会添加内容到我们的游戏中去，有关于项目的创建可以参考创建新项目，我们现在需要一些内容放置到我们的游戏中去，对于本教程我们使用下面这个球： 点击鼠标”右键-&gt;图片另存为”命名为ball.png并保存到任意文件夹。 现在打开项目文件夹并看向左边(也可能是右边)...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MonoGame","slug":"MonoGame","count":4,"path":"api/categories/MonoGame.json"}],"tags":[{"name":"游戏开发","slug":"游戏开发","count":10,"path":"api/tags/游戏开发.json"},{"name":"MonoGame","slug":"MonoGame","count":4,"path":"api/tags/MonoGame.json"}],"author":{"name":"打工战士","slug":"blog-author","avatar":"https://cdn.u1.huluxia.com/g4/M03/19/CD/rBAAdmGuLfyAds0SAACW7BZxpZU096.jpg","link":"/","description":"未看此花时，此花与汝同归于寂 <br> 来看此花时，此花颜色一时明白过来","socials":{"github":"https://github.com/tianranjuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}