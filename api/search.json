[{"id":"af2d422907556d678d4afd213578db93","title":"leaflet回放插件 leaflet-replayer","content":"插件仓库地址\n根据之前项目中遇到的场景需求，开发了此插件，已发布到npm，欢迎大家使用。\n介绍Leaflet Replayer 是一个基于 Leaflet 的回放图层插件，允许你在地图上回放历史数据。\n安装bashnpm install leaflet-replayer或者直接下载项目中的 index.js 文件并在项目中引入。\n使用方法基本使用javascript// 引入插件\nimport &#39;leaflet-replayer&#39;;\n\n// 创建回放图层实例\nconst replayer = L.replayer(&#123;\n  data: myData,         // 回放数据\n  step: 1000,           // 时间步长(毫秒)\n  speed: 1,             // 播放速度\n  autoPlay: false,      // 是否自动播放\n  loop: false,          // 是否循环播放\n  smoothSpeed: false,   // 是否启用平滑倍速\n  onTick: function(timestamp, data) &#123;\n    // 每个时间点的回调函数\n    console.log(&#39;当前时间:&#39;, timestamp, &#39;数据:&#39;, data);\n  &#125;\n&#125;).addTo(map);\n\n// 控制播放\nreplayer.play();   // 开始播放\nreplayer.pause();  // 暂停播放\nreplayer.stop();   // 停止播放数据格式数据应按照以下格式组织：\njavascriptconst myData = [\n  &#123;\n    timestamp: 1609459200000, // 时间戳\n    data: [...]               // 该时间点对应的数据\n  &#125;,\n  &#123;\n    timestamp: 1609459300000,\n    data: [...]\n  &#125;\n];配置选项\n\n\n选项\n类型\n默认值\n描述\n\n\n\ndata\nArray\n[]\n需要回放的数据\n\n\nstartTime\nNumber\nnull\n回放数据的开始时间\n\n\nendTime\nNumber\nnull\n回放数据的结束时间\n\n\nstep\nNumber\n1000\n回放数据的标准步长(毫秒)\n\n\nspeed\nNumber\n1\n回放数据的倍速\n\n\nautoPlay\nBoolean\nfalse\n是否自动播放\n\n\nloop\nBoolean\nfalse\n是否循环播放\n\n\nsmoothSpeed\nBoolean\nfalse\n是否启用平滑倍速模式\n\n\nonTick\nFunction\nnull\n时间推进时的回调函数\n\n\nonStop\nFunction\nnull\n停止时的回调函数\n\n\nonPause\nFunction\nnull\n暂停时的回调函数\n\n\nonJumpTo\nFunction\nnull\n跳转时间时的回调函数\n\n\nAPI 方法\nplay() - 开始播放\npause() - 暂停播放\nstop() - 停止播放并回到起始位置\nsetSpeed(speed) - 设置播放速度\njumpTo(time) - 跳转到指定时间点\ngetState() - 获取播放器当前状态\n\n回调函数\nonTick(timestamp, data) - 每个时间点触发，参数为当前时间戳和数据\nonStop(timestamp) - 停止播放时触发\nonPause(timestamp) - 暂停播放时触发\nonJumpTo(timestamp) - 跳转时间时触发\n\n","slug":"leaflet-replayer插件","date":"2025-10-11T09:10:19.283Z","categories_index":"","tags_index":"leaflet","author_index":"天然卷打工战士"},{"id":"6d41b9e6354554d3613a2c8170bc7bc4","title":"多个div紧密排列的间隙问题","content":"div 的行间缝隙在绘制cell时出现了 div 行间距非常大的问题\n\n在查找资料后发现原因:\n\n\n\n\n\n\n\n\n\n在 line-block 模式下，元素被当成行内元素排版，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 white-space 的处理方式（默认是 normal，合并多余空白），原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 的情况下，空白符占据一定宽度，所以 inline-block 的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素 font-size:16px 时，间距为 8px。\n解决方案\n方案一、元素间不换行\njs&lt;div class=\"box\"&gt;\n  &lt;span&gt;111&lt;/span&gt;\n  &lt;span&gt;111&lt;/span&gt;\n&lt;/div&gt;此方案不具备可读性，且为生成 div 没法控制这个问题，所以不考虑。\n方案二、font-size:0;\ncss#container {\n  font-size: 0px;\n  width: 701px;\n}给父元素设置一个font-size:0;的样式，这个方案是根据在字体不为 0 的情况下，空白符占据一定宽度，同时这些元素之间的间距会随着字体的大小而变化。这一规则着手，将 div 间存在的空白字符字体设置为 0 让其显示不出来即可。\n如果子元素中有需要显示的文字，则给子元素单独设置正确的字体大小即可。\n最终实现时，使用了这个方案。\n方案三、负 margin 方法\n这个方案没能成功，同时这个方案由于在字体不为 0 的情况下，空白符占据一定宽度，同时这些元素之间的间距会随着字体的大小而变化。这个问题导致 margin 的值也是一个浮动的值，不灵活所以所以不考虑。\n\n在群里看到助教老师提出了一种不知道的方案记录下\n方案四、去掉&lt;!DOCTYPE html&gt;\n根据 winter 老师的《重学前端》[1]专栏和[MDN][2],[3]可知&lt;!DOCTYPE html&gt;是一种 DTD，它现在唯一的作用就是启用标准模式。\n在尝试去掉了以后，div 间的缝隙真的不见了，在找寻了一些资料后，得知在Quirks Mode下，为body设置一个margin是无效的，所以推测浏览器是使用的标准模式之外的另种模式中的一种，在该模式下 div 间的 margin 也被取消掉了；\n继续找到如下方法验证：\njswindow.alert(\n  \"You are in \" +\n    (document.compatMode === \"CSS1Compat\" ? \"Standards\" : \"Quirks\") +\n    \" mode.\"\n);结果为You are in Quirks mode.，印证了猜想。\n结论日常工作中遇到这个问题，可以根据实际情况选择一个解决方案进行修改。\n参考\n[1] 重学前端-HTML 语言：DTD 到底是什么？\n[2] MDN-DTD\n[3] MDN-怪异模式和标准模式\n[4] 简书-quirks 模式是什么？它和 standards 模式有什么区别\n\n","slug":"多个div紧密排列的间隙问题","date":"2025-09-29T15:27:23.263Z","categories_index":"","tags_index":"JavaScript","author_index":"天然卷打工战士"},{"id":"147d0b77a639b4360d2d5ae395dbfd1a","title":"关于JS中变量提升问题的研究","content":"1. 提升意思指代码在在代码执行前预处理阶段由解释器对代码进行扫描后，对代码进行的优化处理，把以某些特定关键字声明的变量提前放置到作用域顶层提前声明、创建的行为。\n2. 声明还是创建？绑定还是初始化还是赋值？首先要统一一下概念的认知\njsvar a; // 声明动作同时创建了一个叫a的变量\n\nvar a = undefined; // 初始化a（存在提升时在预处理阶段由解释器进行操作）\n\na = \"value\"; // 赋值动作 将value赋值给a\n\nvar a = \"value\"; // var声明并创建了a，后又被赋值了value，进行赋值前a会先被初始化为undefined在这段代码中 var a是指使用var关键字声明并创建了一个变量a, var a = undefined是将 a 变量进行初始化,而a = 'value'中’value’被赋值给了 a\n在统一好了概念后，下面就进入正题\n3. 使用 var 声明jsconsole.log(a);\nvar a = 1;这里我们都知道由于变量提升会打印出 undefined，那么是为什么呢？这里大致可以解释为：\njs 解释器在扫描了代码后，把所有以var关键字进行生命的变量拿出来放到了作用域的最上面进行声明并把变量初始化为默认值 undefined\njsvar a = undefined; // 隐藏的，解释器偷偷做的\n\nconsole.log(a);\nvar a = 1;然后顺序执行代码，在执行到 console 时读取 a 并打印 undefined，继续执行到var a = 1在将 1 赋值给 a，此时如果在下方再次打印则会正确的打印出 1\njsvar a = undefined; // 隐藏的，解释器偷偷做的\n\nconsole.log(a); // 打印undefined\nvar a = 1;\nconsole.log(a); // 打印1好的，我们现在知道了在使用 var 声明变量的时候会被解释器偷偷的把变量放到作用域最顶层进行声明和初始化，由此导致了变量提升的问题，那么 function 是如何表现的呢？\n4. 使用 function 声明也是用一个简单例子来进行说明\njsfn2();\n\nfunction fn2() {\n  console.log(2);\n}运行代码我们会发现函数是可以正常执行的，控制台也符合预期的打印出了 2，那么就可以说明 function 关键在预处理阶段会进行声明并创建出 fns 函数、然后初始化为 undefined，初始化完成后再讲函数体赋值给 fn2 函数。\n注意function关键字的预处理过程比var关键字多出一个初始化后立即赋值的步骤，这是解开问题的关键点。\n那么在看完了预处理时的过程后我们加深一下难度看一下 function 和 var 结合时会有怎样的结果\njsvar foo;\nfunction foo() {}\nconsole.log(foo);\n\n//------------------\nfunction foo() {}\nvar foo;\nconsole.log(foo);还是一段示例，运行这两段代码发现都会打印出function foo(){}来，这又是为什么呢？\n根据上面的推导我们能知道，var关键字比function关键字在预处理时少了一个赋值的过程，那么解答起来就容易的多了，由于两个变量都叫做foo，所以会存在覆盖的情况，在解释器将名为 foo 的变量声明完创建完后，此时foo到底是谁还没有定论，仅仅是内存中一个名为foo的地址而已，而由于var关键字没有赋值动作，所以在创建完变量后任务就到此结束了，而function关键字是有赋值动作的，所以在创建完变量后会尝试将函数foo的函数体赋值给名为foo的变量，正是多了这一步才让变量foo在最后被赋值为了function foo(){}，此时变量也就确定为就是函数foo了，所以也就不难理解为什么我们打印出来也就是函数体function foo(){}了\n5. let 到底存不存在提升说了这么多，最后来说一下到底 let 存不存在提升的问题，这个问题在一些群里也看到过讨论，也没有什么定论，所以下面是一个我个人的理解。\n还是上一个示例\njslet x = \"global\";\n{\n  console.log(x); // Uncaught ReferenceError: x is not defined\n  let x = 1;\n}首先 let 是一个块级作用域，所以简单的理解就是之会存在{}，所以此例中 console 的 x 其实值取的{}中的 x。\n然后我们执行以下代码发现抛出异常Uncaught ReferenceError: x is not defined这是一个变量为定义的异常，这里就很有趣了，我们来尝试分析以下：\n5.1. 假设 let 不存在提升假设let不存在变量提升，那么在预处理阶段应该会直接丢弃不进行处理，那么也就是说在执行到console时在{}作用域中并不存在一个名为 x 的变量，如果是这种情况按照 js 引擎的工作方式应该会向上找寻作用域链也就是找到let x = \"global\";这个 x，然后打印出global才对，但是显然结果并不是这样，那我们换一个假设试试；\n5.2. 假设 let 存在提升假设let存在变量提升，那么按照上面的推导在预处理阶段会进行声明、创建、初始化、赋值等操作，又由于 console 并没有按照作用域链向上层查找，那么在调用 console 时{}中的 x 一定是存在的才会停止向上查找，所以可以推导出let x = 1;这一句的声明一定被进行了提升，否则不可能让引擎停止向上层查找。\n那既然推导出了 let 存在变量提升，那为什么还会报错呢？那就要说一下 let 的特性暂存死区了，下面同样是个人的理解。\n5.3. 暂存死区\n\n\n\n\n\n\n\n\n与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。\n通过 MDN 这段解释我们可以知道 let 创建的变量在初始化前是处于一个在当前作用域块顶部的区域中，这个区域就是暂存死区，那么这个暂存死区为什么就让 let 和 var 产生了不一样的行为呢？\n原因就是 let 虽然被提升到了当前作用域块的顶部，但是当预处理机制将其提升完后并没有对其进行初始化，而是将其标记为待评估状态，当调用一个待评估状态的变量时就会抛出 ReferenceError 异常，只有当代码执行到了初始化(赋值)语句进行了初始化后再调用就会返回正常值变成为一个正常的变量。\n代码可以理解为：\njslet x = \"global\";\n{\n  let x; // 此时为待评估状态，等待进行初始化，调用会抛出ReferenceError\n  console.log(x); // Uncaught ReferenceError: x is not defined\n  let x = 1; // 执行到这一行时，对x进行初始化并且值为1此时，状态变为一个正常的变量\n}5.4. 关于 constconst 与 let 的行为基本保持一致，区别仅在于 const 没有赋值的操作，只有声明、创建、初始化操作且，并不能对其进行再赋值。\n6. 总结提升的本质在于将声明和创建的步骤提升了，而关于初始化和赋值动作则根据不同的关键字有不同的评估手段和行为，所以关于 let/const 能不能提升这个问题，我觉得需要分情况而定：\n\n如果提升被定义为是变量的声明被提前，那么 js 中的这些关键字(var,function,let,const,class,function*)就都能够提升\n如果提升定义为完成了初始化后才算提升，那么 let/const就是不能提升的。\n\n7. 参考\n[1] 我用了两个月的时间才理解 let\n[2] Are variables declared with let or const hoisted?\n[3] Runtime Semantics: LabelledEvaluation\n\n","slug":"关于JS中变量提升问题的研究","date":"2025-09-29T15:09:13.110Z","categories_index":"","tags_index":"JavaScript","author_index":"天然卷打工战士"},{"id":"066dbf65de05ce712f1d73bffa64257b","title":"js到底要不要加分号？","content":"1. 争吵的由来行尾使用分号的风格来自于 Java，也来自于 C 语言和 C++，这一设计最初是为了降低编译器的工作负担。但是，从今天的角度来看，行尾使用分号其实是一种语法噪音，恰好 JavaScript 语言又提供了相对可用的分号自动补全规则，所以，很多 JavaScript 的程序员都是倾向于不写分号。 于是乎两伙人在同时写 js 的时候就打了起来。\n2. 优劣其实并没有什么优劣，加分号代码更清晰，自己控制的分号肯定不会出错；不加分号，js 引擎可以自动插入，但是要注意自动插入的规则，在规则内不加分号也是完全不会有问题。\n2.1. 自动插入分号规则自动插入分号规则其实独立于所有的语法产生式定义，它的规则说起来非常简单，只有三条。\n\n要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。\n有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。\n源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。\n\n什么意思呢，下面几个例子来说明下\n2.1.1. 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。jslet a = 1;\nvoid (function (a) {\n  console.log(a);\n})(a);这个例子中本意是想在声明变量 a 后，执行一个 IIFE，由于 1 后面紧跟的是 void，这是不符合语法规则的，所以根据第一条规则，这里会自动插入一个分号。\n2.1.2. 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。jsvar a = 1,\n  b = 1,\n  c = 1;\na;\n++b;\n++c;这个例子中呢，本意是想在声明完 a，b，c 三个变量后，对 a，b 进行自增(++)操作，但是由于 a 后面紧跟了换行符，而 a++(后自增)的语法时不允许存在换行符的（根据 no LineTerminator here 规则）所以会在 a 后面自动插入一个分号，此时就变成了\njsvar a = 1,\n  b = 1,\n  c = 1;\na;\n++b;\n++c;这明显是不符合预期的，所以在这个示例中，不写分号是影响开发的。\n2.1.3. 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。js(function (a) {\n  console.log(a);\n})()(function (a) {\n  console.log(a);\n})();这个例子中我们原本的意图是先后执行两个 IIFE 可以却会报错，原因是在第一个 IIFE 执行完毕后，解析第二个 IIFE 时，js 引擎会认为第一个 IIFE 有可能返回一个函数，那么在函数后面紧跟了一个(符号就有可能是调用传参操作，而这种操作是合法的，也就不会在这里自动插入符号，导致报错。\n\n\n\n\n\n\n\n\n\n避免这种情况的方法有在第二个 IIFE 钱加;，或者是使用一些表达式加以区分，如： 0, function() {}(), true &amp;&amp; function(){}(), +function() {}(), (0, function(){}())()等\n3. 那么什么是 no LineTerminator here 规则\n凡是符合上图规则的都不会自动插入分号，如 a 自增的例子中，就是因为不符合后自增、后自减运算符前不能插入换行的规则导致的自动插入错误。\n4. 其他坑4.1. 以数组开头jsvar a = [[]] /*这里没有被自动插入分号*/ [3, 2, 1, 0]\n  .forEach((e) =&gt; console.log(e));这里的问题是由于[[]]中的最后一个]后没有写分号，导致第二哥开始的[和,会被认为是下标运算符和逗号表达式,而在这个例子中甚至都不会报错，所以排查起来也会非常的困难。\n4.2. 正则表达式开头(自面量形式)jsvar x = 1,\n  g = { test: () =&gt; 0 },\n  b = 1 /*这里没有被自动插入分号*/ /a/g.test(\"abc\");\nconsole.log(RegExp.$1);这个例子中在本意是想在声明完 x，g，b 三个变量后使用正则表达式对字符串进行 test 测试，而由于在声明完变量 b 以后没有写分号，所以正则表达式开头的/被认为是一个除法运算符，所以后面会被当成一个表达式运行，会抛出 a is not defined的异常，而后面如果 g 是以个正常的对象，同时又拥有 test 方法的情况甚至还会被正常执行 test 方式，所以排查起来也会很困难。\n4.3. 以 Template 开头的语句jsvar f = function () {\n  return \"\";\n};\nvar g = f/*这里没有被自动插入分号*/ `Template`.match(/(a)/);\nconsole.log(RegExp.$1);这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。排查起来同样非常困难。\n5. 总结一下看了这么多示例后，想必对自动插入分号的规则也有了了解，那么就通过引用尤雨溪尤大在知乎的一个回答来快速的记住如何避免不写分号所带来的坑：\n\n\n\n\n\n\n\n\n\n没有应该不应该，只有你自己喜欢不喜欢。JavaScript 语法长得 C-like 不代表它本质上和 C 是一类语言，所有直觉性的 “当然应该加分号” 都是保守的、未经深入思考的草率结论。后来新设计的语言里可选分号的多得去了，光是 “可以加分号但是大家都不加” 的语言就有：Go, Scala, Ruby, Python, Swift, Groovy…\n至于说 “很难总结什么时候加不加”，其实真的很简单。真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。\n","slug":"js到底要不要加分号","date":"2025-09-29T15:06:22.035Z","categories_index":"","tags_index":"JavaScript","author_index":"天然卷打工战士"},{"id":"5e69e1cf00eccada627cba6c5b3a1509","title":"d3的7步开发法","content":"根据《Fullstack D3 and Data Visualization》的核心方法论，开发数据可视化通常遵循以下 7 步流程，这些步骤结合了数据驱动文档（D3.Js）的核心思想和实际开发实践。以下是对每一步的详细解析及示例说明：\n\n1. 获取数据（Access Data）目标：加载并预处理数据，确保格式符合可视化需求。实现：  \n\n使用 D3 的 d3.csv()、d3.json() 等方法加载数据，或直接定义本地数据集。  \n对数据进行清洗（如处理缺失值、类型转换）。\n\n示例：  \njavascript// 从JSON文件加载天气数据\nconst dataset = await d3.json(\"./weather_data.json\");\n// 数据预处理：转换温度值为数字\nconst processedData = dataset.map(d =&gt; ({ ...d, temperature: +d.temperature }));2. 定义图表尺寸（Create Chart Dimensions）目标：确定图表容器的尺寸及边距，确保内容适配画布。实现：  \n\n定义包含画布宽高、边距的 dimensions 对象，并计算绘图区（bounded area）尺寸。\n\n示例：  \njavascriptconst dimensions = {\n  width: 800,\n  height: 600,\n  margin: { top: 20, right: 30, bottom: 50, left: 60 },\n  boundedWidth: 0,\n  boundedHeight: 0\n};\n// 计算绘图区尺寸\ndimensions.boundedWidth = dimensions.width - dimensions.margin.left - dimensions.margin.right;\ndimensions.boundedHeight = dimensions.height - dimensions.margin.top - dimensions.margin.bottom;3. 绘制画布（Draw Canvas）目标：创建 [[SVG]] 容器并设置坐标系。实现：  \n\n使用 d3.select() 选择 DOM 元素，添加 SVG 并设置宽高。  \n添加 &lt;g&gt; 元素作为绘图区，通过 transform 调整边距偏移。\n\n示例：  \njavascriptconst svg = d3.select(\"#chart-container\")\n  .append(\"svg\")\n  .attr(\"width\", dimensions.width)\n  .attr(\"height\", dimensions.height);\n\nconst bounds = svg.append(\"g\")\n  .style(\"transform\", `translate(${dimensions.margin.left}px, ${dimensions.margin.top}px)`);4. 创建比例尺（Create Scales）目标：将数据域映射到视觉空间（如像素坐标）。实现：  \n\n根据数据类型选择比例尺（如 scaleLinear、scaleBand）。  \n设置 domain（数据范围）和 range（输出范围）。\n\n示例（温度折线图）：  \njavascriptconst xScale = d3.scaleTime()\n  .domain(d3.extent(dataset, d =&gt; d.date))\n  .range([0, dimensions.boundedWidth]);\n\nconst yScale = d3.scaleLinear()\n  .domain([0, d3.max(dataset, d =&gt; d.temperature)])\n  .range([dimensions.boundedHeight, 0]);5. 绘制数据（Draw Data）目标：将数据绑定到 DOM 元素并生成可视化图形。实现：  \n\n使用 selection.data() 绑定数据，通过 enter() 处理新增数据。  \n调用图形生成器（如 d3.line()、d3.arc()）绘制图表。\n\n示例（折线图）：  \njavascriptconst lineGenerator = d3.line()\n  .x(d =&gt; xScale(d.date))\n  .y(d =&gt; yScale(d.temperature));\n\nbounds.append(\"path\")\n  .datum(dataset)\n  .attr(\"d\", lineGenerator)\n  .attr(\"fill\", \"none\")\n  .attr(\"stroke\", \"steelblue\");6. 绘制外围元素（Draw Peripherals）目标：添加坐标轴、标签、图例等辅助元素。实现：  \n\n使用 d3.axisBottom() 和 d3.axisLeft() 生成坐标轴。  \n通过 .call() 方法将坐标轴添加到画布。\n\n示例：  \njavascript// 添加X轴\nconst xAxis = bounds.append(\"g\")\n  .attr(\"transform\", `translate(0, ${dimensions.boundedHeight})`)\n  .call(d3.axisBottom(xScale));\n\n// 添加Y轴标签\nbounds.append(\"text\")\n  .attr(\"transform\", \"rotate(-90)\")\n  .attr(\"y\", -dimensions.margin.left + 10)\n  .attr(\"x\", -dimensions.boundedHeight / 2)\n  .text(\"温度 (°C)\");7. 添加交互与动画（Add Interactions &amp; Animations）目标：通过事件监听和过渡效果增强用户体验。实现：  \n\n使用 .on() 绑定鼠标事件（如悬停、点击）。  \n通过 .transition() 实现平滑动画。\n\n示例（悬停提示）：  \njavascriptbounds.selectAll(\".data-point\")\n  .data(dataset)\n  .enter().append(\"circle\")\n  .attr(\"cx\", d =&gt; xScale(d.date))\n  .attr(\"cy\", d =&gt; yScale(d.temperature))\n  .attr(\"r\", 3)\n  .on(\"mouseover\", function(event, d) {\n    d3.select(this).attr(\"r\", 6); // 放大点\n    // 显示提示框\n    tooltip.style(\"opacity\", 1)\n      .html(`日期：${d.date}&lt;br&gt;温度：${d.temperature}°C`);\n  })\n  .on(\"mouseout\", function() {\n    d3.select(this).attr(\"r\", 3);\n    tooltip.style(\"opacity\", 0);\n  });总结这 7 步方法覆盖了从数据准备到交互设计的全流程，适用于大多数图表类型（如柱状图、散点图、地图等）。实际开发中可根据需求调整步骤顺序或合并操作，例如将比例尺定义与数据预处理结合。更多高级技巧（如响应式设计、性能优化）可参考《Fullstack D3》的进阶章节。\n参考安利一些不错的D3.js数据可视化资源\n","slug":"d3/07步开发法","date":"2025-09-28T14:01:52.646Z","categories_index":"d3","tags_index":"d3,数据可视化","author_index":"天然卷打工战士"},{"id":"abcf6118dce936e2c54c5f477d37d6f7","title":"SVG基础","content":"概述SVG 全称为：可缩放矢量图形（Scalable Vector Graphics） 是一种用于描述二维图形的 XML 标记语言，对于图形的描述基于数学描述而不是像素，因此可以缩放到任意大小而不会失真。\nSVG 在 HTML 中的使用\n所有的 SVG 元素都和 HTML 元素一样，使用标签来与属性表示，不同的是，SVG 元素必须写在 SVG 标签中才能生效，像下面这样：\nhtml&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt;\n    &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /&gt; \n&lt;/svg&gt;SVG 基本语法\n使用标签标识元素和内容\n元素的属性不需要写在 style 里，直接写在标签上就可以\n支持 id、class 属性，所以支持使用部分 CSS 样式直接控制元素的样式\n数值单位（宽高、位置等）没有像素单位，直接使用数值即可\n\nhtml&lt;svg\n id=\"svg\"\n  width=\"200\"     &lt;!-- 指定SVG画布的宽度 --&gt;\n  height=\"200\"    &lt;!-- 指定SVG画布的高度 --&gt;\n  xmlns=\"http://www.w3.org/2000/svg\"&gt;   &lt;!-- 指定SVG命名空间，一般可以忽略 --&gt;\n  &lt;!-- SVG图形内容 --&gt;\n&lt;/svg&gt;基本图形SVG 提供了多种图形元素标签来绘制各种图形:\n\nRect：绘制矩形\nCircle：绘制圆形\nEllipse：绘制椭圆\nLine：绘制直线\nPolyline：绘制折线\nPolygon：绘制多边形\nPath：绘制路径\nText：插入文本\n\n下面是这些使用这些标签的演示：\nhtml&lt;!-- 使用 &lt;rect&gt; 元素绘制矩形，可以指定矩形的位置、大小、圆角等属性 --&gt;\n&lt;rect x=\"50\" y=\"50\" width=\"100\" height=\"50\" rx=\"10\" ry=\"10\" fill=\"blue\"  /&gt;\n\n&lt;!-- 使用 &lt;circle&gt; 元素绘制圆形，可以指定圆心坐标和半径 --&gt;\n&lt;circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"red\" /&gt;\n\n&lt;!-- 使用 &lt;ellipse&gt; 元素绘制椭圆，可以指定椭圆的中心坐标和长短轴的半径 --&gt;\n&lt;ellipse cx=\"100\" cy=\"100\" rx=\"80\" ry=\"50\" fill=\"green\" /&gt;\n\n&lt;!-- 使用 &lt;line&gt; 元素绘制直线，需要指定起点和终点坐标 --&gt;\n&lt;line x1=\"50\" y1=\"50\" x2=\"150\" y2=\"150\" stroke=\"black\" stroke-width=\"2\" /&gt;\n\n&lt;!-- 使用 &lt;polygon&gt; 元素绘制多边形，需要指定多个顶点的坐标 --&gt;\n&lt;polygon points=\"100,50 150,150 50,150\" fill=\"orange\" /&gt;\n\n&lt;!-- 使用 &lt;polyline&gt; 元素绘制折线，需要指定多个点的坐标 --&gt;\n&lt;polyline points=\"100,50 150,150 50,150\" fill=\"none\" stroke=\"blue\" stroke-width=\"2\" /&gt;\n\n&lt;!-- 使用 &lt;path&gt; 元素绘制路径，可以通过指定一系列的路径命令来绘制各种形状 --&gt;\n&lt;path d=\"M10 10 L90 10 L90 90 Z\" fill=\"none\" stroke=\"black\" stroke-width=\"2\" /&gt;\n\n&lt;!-- - 使用 &lt;text&gt; 元素插入文本，使用 `font-family`、`font-size` 等属性控制文本样式 --&gt;\n &lt;text x=\"150\" y=\"115\" font-size=\"16\" text-anchor=\"middle\" fill=\"white\"&gt;RUNOOB SVG TEST&lt;/text&gt;有时候还需要实现一些特殊效果，比如滤镜，渐变色等效果，则可以使用下面几个标签：\n\nFilter：创建滤镜应用到其他元素，可是实现类似 CSS 的滤镜效果\nLinearGradient：创建线性渐变应用到其他元素\nRadialGradient：创建径向渐变应用到其他元素\n\n\n\n\n\n\n\n\n\n\nNOTE\nCSS 属性中的渐变色背景在 SVG 中并不生效，所以需要使用 LinearGradient、RadialGradient 两个标签来实现类似的效果。\n同时需要注意到描述中有提到这几种效果是应用到其他元素的，也就以为着需要被其他元素引用，所有需要被其他元素引用的标签需要定义在 defs 标签中，后面会提到如何使用。\n通用属性\n\n\n\n属性\n描述\n\n\n\nfill\n定义元素的填充颜色。\n\n\nstroke\n定义元素的描边颜色。\n\n\nstroke-width\n定义描边的宽度。\n\n\nfill-opacity\n定义填充颜色的透明度，取值范围为 [0,1]。\n\n\nstroke-opacity\n定义描边颜色的透明度，取值范围为 [0,1]。\n\n\ntransform\n\n\n\ncircle\n\n\n\n属性\n描述\n\n\n\ncx\n圆心的 x 坐标\n\n\ncy\n圆心的 y 坐标\n\n\nr\n圆的半径\n\n\nrect\n\n\n\n属性\n描述\n\n\n\nx\n矩形左上角的 x 坐标\n\n\ny\n矩形左上角的 y 坐标\n\n\nwidth\n矩形的宽度\n\n\nheight\n矩形的高度\n\n\nrx\n矩形圆角的 x 半径（可选）\n\n\nry\n矩形圆角的 y 半径（可选）\n\n\nline\n\n\n\n属性\n描述\n\n\n\nx1\n线起点的 x 坐标\n\n\ny1\n线起点的 y 坐标\n\n\nx2\n线终点的 x 坐标\n\n\ny2\n线终点的 y 坐标\n\n\npolyline\n\n\n\n属性\n描述\n\n\n\npoints\n多个点的坐标，用空格分隔，用于绘制折线\n\n\npolygon\n\n\n\n属性\n描述\n\n\n\npoints\n多个点的坐标，用空格分隔，用于绘制闭合多边形\n\n\ntext\n\n\n\n属性\n描述\n\n\n\nx\n文本的起始 x 坐标\n\n\ny\n文本的起始 y 坐标\n\n\nfont-family\n字体\n\n\nfont-size\n字体大小\n\n\nimage\n\n\n\n属性\n描述\n\n\n\nx\n图像的起始 x 坐标\n\n\ny\n图像的起始 y 坐标\n\n\nwidth\n图像的宽度\n\n\nheight\n图像的高度\n\n\nxlink:href\n图像的路径\n\n\ng\n\n\n\n属性\n描述\n\n\n\ntransform\n对组内的所有元素应用变换\n\n\nid\n组的唯一标识符\n\n\n路径 Path属性\n\n\n\n属性\n描述\n用例\n\n\n\n\nd\n定义路径的路径数据，是一系列命令和参数的组合\n\n\n\n\n路径语法\n\n\n\n命令\n参数\n描述\n\n\n\nM\nM x y 或 m dx dy 大写表示绝对坐标，小写表示相对坐标\n将画笔移动到指定的点，不绘制任何内容\n\n\nL\nL x y 或 l dx dy 大写表示绝对坐标，小写表示相对坐标\n从当前位置绘制一条直线到指定的点\n\n\nH\nH x 或 h dx大写表示绝对坐标，小写表示相对坐标\n从当前位置水平绘制一条直线到指定的 x 坐标\n\n\nV\nV y 或 v dy 大写表示绝对坐标，小写表示相对坐标\n从当前位置垂直绘制一条直线到指定的 y 坐标\n\n\nC\nC x1 y1, x2 y2, x, y 或 c dx1 dy1, dx2 dy2, dx dy 大写表示绝对坐标，小写表示相对坐标\n绘制三次贝塞尔曲线，需要两个控制点 (x1,y1) 和 (x2,y2)，以及终点 (x,y)\n\n\nS\nS x1 y2, x y 或 s dx2 dy2, dx dy 大写表示绝对坐标，小写表示相对坐标\n绘制平滑的三次贝塞尔曲线，第一个控制点是前一个控制点的反射点\n\n\nQ\nQ x 1 y 2, x y 或 q dx1 dy1, dx dy 大写表示绝对坐标，小写表示相对坐标\n绘制二次贝塞尔曲线，需要一个控制点 (x1,y1) 和终点 (x,y)\n\n\nT\nT x y 或 t dx dy 大写表示绝对坐标，小写表示相对坐标\n绘制平滑的二次贝塞尔曲线，控制点是前一个控制点的反射点\n\n\nA\nA rx ry x-axis-rotation large-arc-flag sweep-flag x y 或  a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy大写表示绝对坐标，小写表示相对坐标\n绘制椭圆弧，需要椭圆的半径 (rx,ry)、旋转角度、弧的大小标志和方向标志\n\n\nZ\n无参数\n关闭路径，将画笔返回到路径的起始点\n\n\n组与元素复用类似 HTML 有时候需要分组各种元素方便管理标签，或者是复用一些通用的元素，此时可以使用一下两个标签：\n\nG：用于创建一个分组\nDefs：创建可复用元素容器，任何 SVG 元素都可以定义在里面，包括：基础图形、滤镜、渐变等\n\nhtml\n&lt;svg width=\"80px\" height=\"30px\" viewBox=\"0 0 80 30\"\n     xmlns=\"http://www.w3.org/2000/svg\"&gt;\n &lt;!-- -使用defs定义需要复用的元素容器  --&gt;\n  &lt;defs&gt;\n     &lt;!-- 定义一个线性渐变色 --&gt;\n    &lt;linearGradient id=\"Gradient01\"&gt;\n      &lt;stop offset=\"20%\" stop-color=\"#39F\" /&gt;\n      &lt;stop offset=\"90%\" stop-color=\"#F3F\" /&gt;\n    &lt;/linearGradient&gt;\n  &lt;/defs&gt;\n \n  &lt;!-- 元素使用url(#id) 来引用指定的渐变元素 --&gt;\n   &lt;rect x=\"10\" y=\"10\" width=\"60\" height=\"10\"\n        fill=\"url(#Gradient01)\"  /&gt;\n&lt;/svg&gt;\n\n\n\n\n\n\n\n\n\nNOTE\n这里需要注意 SVG 元素在使用 url 的语法引用其他元素时必须使用 id 索引！\n其他元素一些项目中使用比较少的元素\n\nImage：加载一个位图\nClipPath：根据内部的元素元素形状，裁剪一个区域，常用于动画效果制作\nMask：根据内部的元素元素形状，遮罩一个区域，常用于动画效果制作\nForeignObject：嵌入任意的 XML 内容并使用浏览器对内容进行渲染\n\n坐标系对于所有元素，SVG 使用的坐标系统或者说网格系统，与 Canvas 和 DOM 元素是一致的，是一种名叫 W3C 坐标系的规范。\nW3C 坐标系的定义为：以页面的左上角为 (0,0) 坐标点，坐标以像素为单位，x 轴正方向是向右，y 轴正方向是向下。\n\n 元素的定位\n在 SVG 中所有的元素定位都是相对父元素的 0,0 点进行定位的，这一点与 DOM 元素的定位类似，使用 G 标签类似使用一个 div 包括元素，其内部的子元素也是根据 G 的位置进行相对移动的。\n\n零度向量\n在数学中的零度向量是沿 X 轴水平向右的，但是在图形学中的零度向量是沿 Y 轴垂直向下的。\n\n","slug":"svg/svg","date":"2025-09-28T11:49:36.904Z","categories_index":"svg","tags_index":"SVG","author_index":"天然卷打工战士"},{"id":"19913a561c17745f039cc9be34bd6d4b","title":"d3入门「二」：坐标轴","content":"概述[[D3JS|D3]] 内置的坐标轴组件，用于快速渲染坐标轴到屏幕上，适用于大多数的[[比例尺-scale|比例尺]] 类型，包括线性比例尺、对数比例尺、波段比例尺和时间比例尺等。\n在选定的 [[SVG]] 容器 (通常是单个 G 元素) 上调用轴组件会填充轴。轴在原点处呈现。\n\n\n\n\n\n\n\n\n\nNOTE要更改轴相对于图表的位置，需要再包含元素上指定 transform 属性。\n使用坐标轴组件D3 一共提供了 4 种坐标轴组件，分别对应了 上、下、左、右 四个方向的坐标轴：\n\n上：axisTop\n下：axisBottom\n左：axisLeft\n右：axisRight\n\n坐标轴组件需要提供一个比例尺作为参数，并根据比例尺的定义域和值域计算出坐标轴的位置：\njs// 根据比例尺计算坐标轴\nconst bottomAxis = d3.axisBottom(xScale);上面只是计算出了坐标轴组件的位置信息，还没有实际的绘制到屏幕上，要真正渲染到屏幕上需要提供一个容器使用 call 进行绘制，像下面这样：\njs// 在提供的g标签中进行渲染\nmainGroup.append('g').call(bottomAxis);这样就可以在提供的 G 标签中渲染出 D3 提供的默认样式的坐标轴。\n\n默认样式的坐标轴结构大致如下：\nhtml&lt;g fill=\"none\" font-size=\"10\" font-family=\"sans-serif\" text-anchor=\"middle\"&gt;\n  &lt;path class=\"domain\" stroke=\"currentColor\" d=\"M0.5,6V0.5H880.5V6\"&gt;&lt;/path&gt;\n  &lt;g class=\"tick\" opacity=\"1\" transform=\"translate(0.5,0)\"&gt;\n    &lt;line stroke=\"currentColor\" y2=\"6\"&gt;&lt;/line&gt;\n    &lt;text fill=\"currentColor\" y=\"9\" dy=\"0.71em\"&gt;0.0&lt;/text&gt;\n  &lt;/g&gt;\n  &lt;g class=\"tick\" opacity=\"1\" transform=\"translate(176.5,0)\"&gt;\n    &lt;line stroke=\"currentColor\" y2=\"6\"&gt;&lt;/line&gt;\n    &lt;text fill=\"currentColor\" y=\"9\" dy=\"0.71em\"&gt;0.2&lt;/text&gt;\n  &lt;/g&gt;\n  &lt;g class=\"tick\" opacity=\"1\" transform=\"translate(352.5,0)\"&gt;\n    &lt;line stroke=\"currentColor\" y2=\"6\"&gt;&lt;/line&gt;\n    &lt;text fill=\"currentColor\" y=\"9\" dy=\"0.71em\"&gt;0.4&lt;/text&gt;\n  &lt;/g&gt;\n  &lt;g class=\"tick\" opacity=\"1\" transform=\"translate(528.5,0)\"&gt;\n    &lt;line stroke=\"currentColor\" y2=\"6\"&gt;&lt;/line&gt;\n    &lt;text fill=\"currentColor\" y=\"9\" dy=\"0.71em\"&gt;0.6&lt;/text&gt;\n  &lt;/g&gt;\n  &lt;g class=\"tick\" opacity=\"1\" transform=\"translate(704.5,0)\"&gt;\n    &lt;line stroke=\"currentColor\" y2=\"6\"&gt;&lt;/line&gt;\n    &lt;text fill=\"currentColor\" y=\"9\" dy=\"0.71em\"&gt;0.8&lt;/text&gt;\n  &lt;/g&gt;\n  &lt;g class=\"tick\" opacity=\"1\" transform=\"translate(880.5,0)\"&gt;\n    &lt;line stroke=\"currentColor\" y2=\"6\"&gt;&lt;/line&gt;\n    &lt;text fill=\"currentColor\" y=\"9\" dy=\"0.71em\"&gt;1.0&lt;/text&gt;\n  &lt;/g&gt;\n&lt;/g&gt;","slug":"d3/2坐标轴","date":"2025-09-28T11:17:00.458Z","categories_index":"d3","tags_index":"d3,数据可视化","author_index":"天然卷打工战士"},{"id":"0541b8b181491af42712df40ab16bcdd","title":"d3入门「四」：实现交互","content":"实现交互Zoom 缩放交互行为 (缩放、平移)D3 提供了一种灵活的抽象，提供了缩放、平移的能力，可以处理各种各样的输入模式和浏览器异常。缩放行为与 DOM 无关，因此可以将其与 HTML、 SVG 或 Canvas 一起使用，或者其他任何需要缩放的地方。\n要使用缩放交互行为，分为一下几个步骤：\n1、创建缩放行为\njsd3.zoom()2、注册缩放事件\njsconst zoom  = d3.zoom().on(\"zoom\", zoomed) // 注册缩放事件3、绑定到元素\n此处必须使用选择器调用，所以先使用选择器选择一下。\njsselection.call(zoomed)4、缩放事件处理\n事件会传入一个缩放对象，包含了一个 transform 对象，这个对象就是 svg 中的 transform 属性，其中包含了：x，y，k (缩放率) 三个参数，可以根据情况自行使用。\njsfunction zoomed({transform}) {\n  circle.attr(\"transform\", d =&gt; `translate(${transform.apply(d)})`);\n}5、画布的缩放和平移\n上面的例子只是缩放、移动了一个元素，有时候我们更多的需要的是缩放和平移整个画布，所以我们会想到，直接处理 svg 元素移动。\njsfunction zoomed({transform}) {\n  svg.attr(\"transform\", d =&gt; `translate(${transform.apply(d)})`);\n}但是这种实现是不可以的，因为 svg 元素一移动的话，会导致页面布局的混乱，并且实际操作体验也是一卡一卡的。\n为了避免这种情况，需要添加一个 g 元素作为顶层的元素，代替 svg 的位置，然后移动这个 g 就可以实现丝滑的移动效果。\n所以正确的实现是：\n\n在 svg 元素上监听行为事件\n在事件处理中处理顶层的 g 元素进行平移和缩放\n\njsfunction zoomed({transform}) {\n  rootG.attr(\"transform\", d =&gt; `translate(${transform.apply(d)})`);\n}\n\n\n\n\n\n\n\n\nNOTE\n有时候这种实现会导致元素的布局不符合需求，比如一部分需要一定一部分不需要移动，所以如何选择顶层的 g 元素，是需要根据是业务场景进行灵活应用的。\n默认的缩放与平移\njs svg.call(zoom.transform, d3.zoomIdentity.translate(initialTranslate[0], initialTranslate[1]).scale(initialScale));Drag 拖曳行为拖曳元素也是经常出现的业务场景，D3 也提供了一个交互行为来方便开发。\n其注册方式与缩放行为一致，只不过调用的元素多为页面中明确的一个元素。\njs// 注册拖曳行为\nconst drag = d3.drag();\n\n// 给全部的node添加拖曳行为\nd3.selectAll(\".node\").call(d3.drag().on(\"start\", started));事件列表\n拖曳提供了三种钩子事件：\n\nStart：拖曳开始\nDrag：拖曳中\nEnd：拖曳结束\n\n过渡效果D3 提供了一个简易的过渡效果 Api，可以实现大部分简单的动效。\njsd3.select(\"body\") \n    .transition() \n    .style(\"background-color\", \"red\");写起来非常的简单，在 transition 方法后写过渡后的属性值即可。\n延迟执行\njsd3.transition()\n    .duration(750) // 延迟750毫秒执行设置缓动曲线\njsconst t = d3.transition()\n    .duration(750)\n    .ease(d3.easeLinear); // 设置线性变换复用\n有时候写了一个动效的规则，但是想应用到多重元素上，比如延迟 750 秒后执行，使用线性变换，此时可以这么写：\njsconst t = d3.transition()\n    .duration(750)\n    .ease(d3.easeLinear);\n\nd3.selectAll(\".apple\").transition(t)\n    .style(\"fill\", \"red\");\n\nd3.selectAll(\".orange\").transition(t)\n    .style(\"fill\", \"orange\");其他能力\nD3 的过渡效果还提供了很多功能，比如中断，效果合并，动效事件等功能，但是目前来看项目中需求不大，等到后续需要或者有时间再详细研究。\n如果真的需要做非常复杂的动画时，更多的建议是使用专业动画库 GSAP \n自定义事件D3 也提供了一套事件机制，开发时可以使用该机制定制一些自定义的事件或触发一个 D3 内部的事件。\njs// 创建一个事件派发器\nconst dispatch = d3.dispatch(\"start\", \"end\");\n\n// 监听事件\ncircle.on(\"start\", started)\n\n// 触发事件并发送参数\ndispatch.call(\"start\", {about: \"I am a context object\"}, \"I am an argument\");","slug":"d3/4实现交互","date":"2025-09-28T11:13:23.519Z","categories_index":"d3","tags_index":"d3,数据可视化","author_index":"天然卷打工战士"},{"id":"232b42d69dd976bd6905d7c3b08f3b90","title":"d3入门「三」：比例尺","content":"比例尺比例尺在可视化开发中有非常多的应用，比如：一段时间映射到时间轴、一段比例映射到一个宽度、将一个范围以对数方式映射到界面中等，本小节简单介绍一下项目中常用的几种比例尺和应用场景。\n定义一个比例尺，返回一个函数，支持设置比例尺的 定义域(domain) 与 值域(range)。\n比例尺的本质是一个函数，经常结合 d3.max 等函数使用。\n定义域与值域定义域\n定义域是指：需要可视化的数据的定义范围，比如可视化数据是考试分数，那么定义域就是 0~100。\n值域\n值域是指：定义域需要投影到的具体数值范围，在可视化中指投影到屏幕上的像素范围，比如把定义域中的 0~100 的分数投影到屏幕上 20~100 的像素区间上。\njsd3.scaleLinear().domain([0,100]).range([20,100]);\n\n\n\n\n\n\n\n\nNOTE\n定义域与值域可以是全部连续的，也可以是全部离散的，也可以离散、连续搭配使用，具体定义根据不同的比例尺而已。\nscaleLinear (线性比例尺)线性比例尺包含两个部分：\n\ndomain (输入域) 用来表示待映射的数值范围\nrange (映射范围) 输入域经过映射后得到的输出范围，一般是绘图区域的像素或颜色等\n\njs// 旧版使用方法\nconst scale = d3.scaleLinear().range([0,500]).domain([0,100]);\n\nconsole.log(scale(0));   // 输出 0\nconsole.log(scale(50));  // 输出 250\nconsole.log(scale(100)); // 输出 500\n\n// 新版使用方法\nconst x = d3.scaleLinear([10, 130], [0, 960]);\n\nx(20); // 80\nx(50); // 320\n\n// 数值映射到颜色\nconst color = d3.scaleLinear([10, 100], [\"brown\", \"steelblue\"]);\n\ncolor(20); // \"rgb(154, 52, 57)\"\ncolor(50); // \"rgb(123, 81, 103)\"目前实际的开发中，映射到颜色是比较少的，一般是应用在数值间的映射，一般有这么几种应用场景：\n1、自定义图表时，X 轴、 Y 轴的映射：\n这个是很标准的用法，比如把数轴的数值范围[01]映射到页面像素上{width:0100}上。\n2、映射到时间轴：\n这种场景其实正常应该使用 scaleTime 比例尺实现，但是有时候使用线性比例尺也可以实现（时间操作太频繁，转换太麻烦的时候可以使用线性比例尺简化开发）。\n具体实现思路是：\n\n先把开始结束时间的范围转换成时间戳 \n计算两个时间间的毫秒差距（根据需要的单位计算即可，比如秒级、分钟级、小时级等）\n把开始时间当做输入域的 0，时间差当做输入域的最大值\n设置映射范围\n转换数值\n\n\n3、A 数据范围映射到 B 数据范围：\n这种情况相对比较少，但是偶尔也是有的\n\n场景一：比如外部系统的系统使用 0~100 的数据，但是该数据并没有统一的规范，在本系统中使用 300~500 区间，此时就可以使用线性比例尺进行映射\n场景二：需要实现一个小地图系统，此时需要把大画布中的横纵坐标转换到小地图中，但是两个的宽高并不一样，此时使用线性比例尺可以高效且完美的转换\n\n\ninvert(还原映射)\n可以映射过去就可以映射回来，使用 invert 方法可以把输出的值还原会输入范围\njsconst x = d3.scaleLinear([10, 130], [0, 960]);\nx.invert(80); // 20\nx.invert(320); // 50带比例尺用法类似线性比例尺, 场景使用场景在柱状图上，每个柱子或每组柱子可以占用一个带的宽度。\njavascriptconst x = d3.scaleBand([\"1\", \"2\", \"3\", \"4\"], [0, 100]);\n获取宽度\n带有两种方式获取宽度，这两种方式略有不同：\n\nBandWidth: 获取带本身的宽度大小\nStep：获取当前带起始位置到下一个带的起始位置的宽度大小\n\n\nalign\n带比例尺与线性比例尺的使用多了一些间距的配置：\n\n内间距：每个带之间的间距\n外间距：所有带与坐标轴两端的间距\nAlign：0~1 的数字，表示外间距如何分配\n\njavascriptx.align(0.5)当 align = 0 时所有的外间距都会分配给带的右侧，带的位置在坐标轴上左对齐。\n\n当 align = 0.5 时所有的外间距都会均匀的分配给带的两侧，带的位置在坐标轴上居中。\n\n当 align = 1 时所有的外间距都会均匀的分配给带的左侧，带的位置在坐标轴上右对齐。\n\n时间比例尺与线性比例尺使用方法一致，区别只在于输入域为时间类型数据。\njsconst x = d3.scaleTime([new Date(2000, 0, 1), new Date(2000, 0, 2)], [0, 960]);\nx(new Date(2000, 0, 1, 5)); // 200\nx(new Date(2000, 0, 1, 16)); // 640\nx.invert(200); // Sat Jan 01 2000 05:00:00 GMT-0800 (PST)\nx.invert(640); // Sat Jan 01 2000 16:00:00 GMT-0800 (PST)对数比例尺与线性比例尺使用方法一致，主要的区别在于使用场景。\n有一些时候映射区域过大，操作非常的不方便，比如：以 1 px 映射 1 米作为规则进行映射，此时输入范围为 0~100000 m 此时界面几乎无法操作，数据无法展示全貌，这种情况下可以使用对数比例尺，进行压缩。\njsconst x = d3.scaleLog([1, 10], [0, 960]);\n上面为对数数轴，可以看出越往后相同的数据宽度表示的数值范围越大。\n阈值比例尺与线性比例尺使用方法一致，主要的区别在于当达到某一个阈值后得到的值都是固定的。\njsconst color = d3.scaleThreshold([0, 1], [\"red\", \"white\", \"green\"]);\ncolor(-1); // \"red\"\ncolor(0); // \"white\"\ncolor(0.5); // \"white\"\ncolor(1); // \"green\"\ncolor(1000); // \"green\"这种比例尺比较适合在等高线图颜色、热力图颜色、变化趋势等级颜色、警戒线等级颜色等场景。\n","slug":"d3/3比例尺","date":"2025-09-28T07:38:44.886Z","categories_index":"d3","tags_index":"d3,数据可视化","author_index":"天然卷打工战士"},{"id":"65dc118887986eec94800b37afb1763d","title":"d3入门「一」：在项目中使用d3","content":"为什么使用D3D3 的全称是 Data-Driven Document 即数据驱动文档，是一个基于数据操作 DOM 的 Javascript 库，也是现有最流行、社区规模最大、支持图元级定制化的可视化开发框架。\n主要用途是用来进行可视化图形的生成和处理，其核心理念是：将抽象的数据绑定到特定的 DOM 元素，通过数据的变动来驱动 DOM 文档的变化。\n在项目中引入 D3 的考量主要是有以下一些原因：\n提升开发效率\nD3 的基本功能在原生的 DOM API 中都可以实现，之所以引入 D3 是因为原生 API 操作太过于繁琐且有些功能需要自己实现，而 D3 对 [[SVG]] 的操作快速，功能齐全，因此引入 D3 对涉及操作 [[SVG]] 的场景的开发效率提升是非常明显的。\n实现图片无法实现的精确状态展示\n在一些有设备状态监控需求的项目中，一般使用复杂的 [[SVG]] 图可视化的展示设备（比如飞机选座），此时需要对图中的元素有精确的控制，这个是图片无法做到的。\n图表的高度定制化\n图表虽说一般使用 Echarts、G2 等库实现，但是通用库还是一些痛点：\n\n表达效果不满足客户需求，需要定制化图表\n没有提供对应的配置接口，无法实现设计的效果，使用接口自定义又太麻烦\n某些业务场景限制无法集成图表库或集成成本太高\n本身没有相关实现，比如可操作的甘特图、关系图等\n不能仅使用图表中的一部分组件功能\n\n因此提供了图元级定制化能力的D3就可以在这些场景下很好的补充空缺。\n强大的可视化工具库\nD3 中提供了大量功能强大的工具库，这些库在开发数据可视化以及其他数据联动的场景时都是非常好用且高效的，比如：\n\n强大的选择器功能\nGeo 库，提供了场景的投影、坐标转换工具\n各种开箱即用的布局工具，比如树状图、折线图、饼图等\n数据处理工具，提供了随机数据生成、时间处理、通用数据处理成可视化可用的数据等\n缓动效果 \n各种算法的实现，比如：四叉树、等高线计算、多边形切分、力导向算法等\n\n因为这些工具库的存在，使得D3在即使不是可视化业务场景下也可以用来提升开发效率。\n使用 D3在项目中使用 D3 是非常简单的，简单的引入就可以了\njs// npm install d3  或  yarn add d3\n\n// 在页面中\n// 全量引入\nimport * as d3 from \"d3\"\n// 按需引入\nimport { scaleLinear } from \"d3\"选择器的使用D3 的选择器由于其面向可视化开发的设计内核，在 API 设计上提供很强大的元素选择能力和跨父元素组选能力，极大的提升了数据映射到文档时的处理效率。\n\n\n\n\n\n\n\n\n\nNOTE\nD3 的选择器是最常用的 API，一定要熟练使用才能发挥出最大的威力。\n选择元素基础选择器\nD3 在操作元素上类似 JQuery，是链式的:\njavascript// D3 选择器\nd3.select(\"body\").append(\"div\")\nd3.selectAll(\"div\").append(\"span\")\n\n// JQuery 选择器\n$(\"button\").click(function(){ $(\"p\")})同样的 D3 选择器也是基于 [[CSS选择器]] 实现的:\njs // ID 选择器\nd3.select(\"#chart\");\n\n// 类选择器\nd3.select(\".chart\");\n\n// 标签选择器\nd3.select(\"svg\");\n\n// 组合选择器\nd3.select(\".chart-container svg.chart\");D3 中提供了两种选择器 API 用于满足各种场景，select(单元素选择器) 和 **selectAll(多元素选择器)**：\njs// 返回第一个class为chart的元素\nd3.select(\".chart\");\n\n// 返回全部class为chart的元素\nd3.selectAll(\".chart\");\nSelect：选择与指定的选择器字符串匹配的第一个元素\nSelectAll：选择与指定的选择器字符串匹配的所有元素\n\n\n\n\n\n\n\n\n\n\nNOTE\n当使用选择器选中一个元素时会返回一个 选择器对象 (Selelction) ，这个选择器对象是使用 D3 API 的基础\n跨父元素组选\n当使用选择器选中了某一组元素并且想操作这一组元素中的相同子元素时，可以这样做：\njs// 对于每个选定的元素p，选择与指定的选择器字符串匹配的第一个子代元素b\nd3.selectAll(\"p\").select(\"b\"); \n\n// 对于每个选定的元素p，选择与指定的选择器字符串匹配的子代元素b\nd3.selectAll(\"p\").selectAll(\"b\"); 添加元素D3 提供了 append 方法来添加元素：\njs// 添加一个矩形\nd3.select(\"g\") .append(\"rect\")\n\n// 给每一个g都添加一个矩形\nd3.selectAll(\"g\") .append(\"rect\")可以看到配合选择器可以快速的实现批量添加元素\n编辑属性&amp;样式D3 针对于 DOM 元素和 [[SVG]] 元素提供了不同的 API 来编辑属性&amp;样式：\nSVG 元素\n使用 attr 来获取和设置属性\njs// 创建一个矩形，并且给他设置width:920，height:460\nd3.select(\"g\")\n    .append(\"rect\")\n    .attr(\"width\", 920)\n    .attr(\"height\", 460);\n    \n // 获取rect的width属性 返回值为920\n d3.select(\"rect\").attr(\"width\") DOM 元素\njs// 创建一个div，并且给他设置宽高并写入文本\nd3.select(\"body\")\n    .append(\"div\")\n    .style(\"width\", \"920px\")\n    .style(\"height\", \"460px\")\n    .html(\"Hello World!\")\n    \n // 获取div的宽度，返回指为 \"920px\"\n d3.select(\"div\").style(\"width\")配合选择器批量编辑属性\njs // 每一个div下的第一个class包含red-color的p标签都被设置成了红色\n  d3.selectAll(\"div.list-container\")\n    .select(\"p.list-item.red-color\")\n    .style(\"color\", \"red\")\n    .style(\"font-size\", \"18px\")\n    .html(\"每一个div下的第一个class包含red-color的p标签都被设置成了红色\");\n    \n// 每一个div下的全部class包含red-color的p标签都被设置成了红色\nd3.selectAll(\"div.list-container\")\n    .selectAll(\"p.list-item.red-color\")\n    .style(\"color\", \"red\")\n    .style(\"font-size\", \"18px\")\n    .html(\"每一个div下的全部class包含red-color的p标签都被设置成了红色\");","slug":"d3/1为什么使用D3","date":"2025-09-28T07:01:07.521Z","categories_index":"d3","tags_index":"d3,数据可视化","author_index":"天然卷打工战士"},{"id":"65e058b963273b5b3e940e3659fb3ebc","title":"OpenGL「四」：在文件中编写Shader","content":"前面用到了Shader绘制了一个红色的三角形，但是Shader是硬编码在代码中的，虽然是OpenGL想让我们这么写的，但是在实际开发中那肯定是不靠谱的，所以这次就尝试把Shader写到独立的文件中使用。\n设计Shader文件首先先在工程目录下创建文件res/shader/Basic.shader，用于存放Shader\n\n然后把代码中硬编码的Shader代码拷贝到Basic.shader中\ncpp#shader vertex\n#version 330 core\n\nlayout(location = 0) in vec4 position;\n\nvoid main() &#123;\n    gl_Position = position;\n&#125;;\n\n\n#shader fragment\n#version 330 core\n\nlayout(location = 0) out vec4 color;\n\nvoid main() &#123;\n    color = vec4(1.0, 0.0, 0.0, 1.0);\n&#125;;像这样在文件中可以直接像正常写代码一样写两个Shader代码，只需要像声明GLSL版本一样使用#shader fragment和#shader vertex声明一下是那个Shader就可以了，至于cherno为什么这么写而不是把Shader拆分成两个文件来写，猜测可能是因为写在一个文件中可以只需要读取和绑定一次，而代码一般来说代码体积又不会太大，一次加载到内存处理起来很快，犯不上分文件带来的两次绑定的性能消耗吧？也可能就是单纯的学习项目懒的搞复杂…\n\n\n\n\n\n\n\n特别注意\n #shader fragment和#shader vertex是自定义的用于区分Shader并不是OpenGL的定义。\n\n\n使用流加载Shader这里逻辑比较简单，主要是使用fstream来创建文件读&#x2F;写流，然后循环的按行获取文件中的内容，一旦检测到包含#shader xxxx的行就检查具体的类型，确定类型后后续的行都认为是该类型的Shader代码把内容都写入到ss中存起来，最后使用结构体返回Shader的代码字符串。\ncpp...\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n\n// Shader代码结构体，包含了两个Shader的代码字符串\nstruct ShaderProgramSource &#123;\n    std::string vertex;\n    std::string fragment;\n&#125;;\n\nstatic ShaderProgramSource ParseShader(const std::string&amp; filepath) &#123;\n    // 创建流并绑定文件\n    std::ifstream stream(filepath);\n    \n    // 判断是否存在文件\n    if (!stream.is_open()) &#123;\n        std::cout &lt;&lt; &quot;file open failed!&quot; &lt;&lt; std::endl;\n    &#125;\n\n    // 声明Shader类型枚举 \n    enum ShaderType &#123;\n        NONE = -1, VERTEX = 0, FRAGMENT = 1\n    &#125;;\n\n    // 文件行数据\n    std::string line;\n    // 字符串流，用于数据格式转换\n    std::stringstream ss[2];\n    // Shader类型\n    ShaderType type = ShaderType::NONE;\n    // 按行获取Shader的代码\n    while (getline(stream, line)) &#123;\n        // 如果是声明语句行，获取类型赋值给type\n        if (line.find(&quot;#shader&quot;) != std::string::npos) &#123;\n            if (line.find(&quot;vertex&quot;) != std::string::npos)\n                type = ShaderType::VERTEX;\n            else if (line.find(&quot;fragment&quot;) != std::string::npos)\n                type = ShaderType::FRAGMENT;\n        &#125;\n        // 如果不是声明语句，就把当前行数据输入到字符串流中\n        else &#123;\n            ss[(int)type] &lt;&lt; line &lt;&lt; &quot;\\n&quot;;\n        &#125;\n    &#125;\n    // 关闭流\n    stream.close();\n    // 返回包含Shader代码字符串的结构体\n    return &#123;\n        ss[0].str(),\n        ss[1].str() // 转换成字符串返回\n    &#125;;\n&#125;\n...新的逻辑代码使用刚封装好的方法加载Shader代码\ncpp...\n// 加载Shader代码\nShaderProgramSource source = ParseShader(&quot;res/shader/Basic.shader&quot;);\n// 创建Shader程序\nunsigned int shader = CreateShader(source.vertex, source.fragment);\n// 使用Shader\nglUseProgram(shader);\n...再见三角形我们可以随便改改片段着色器中的颜色输出为color = vec4(1.0, 1.0, 0.0, 1.0);，再按下F5运行代码验证结果，可以看到一个黄色的三角形，证明我们已经可以正确的使用文件加载Shader代码了。\n\n","slug":"图形学/OpenGL/OpenGL4","date":"2021-12-29T16:00:00.000Z","categories_index":"图形学,OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"天然卷打工战士"},{"id":"7d4eb62a0f031a2c66f45b6854b89b78","title":"OpenGL「三」：你好三角形","content":"在之前的学习中，使用早期OpenGL绘制了一个三角形，以及了解了如何使用GLEW引入现代OpenGL的API,本篇就使用现代API重新的绘制一个三角形。全部代码截图放在最末尾了，留作参考。\n渲染管线渲染管线指的是渲染的工作流程，不具体指向某一个单独的过程，也不是特指某一段编程代码(如:Shader，Shader只是管线中的一个过程)，感性点的理解可以是从发送绘制指令开始到实际显示到画面里的过程，就是渲染管线，下图展示了渲染管线的各个阶段：\n\n在早期的使用的是固定管线，也就是说整个渲染管线的过程的实现都是固定的，可自定义程度有限，比如：需要开启光照，那我们就只能告诉调用线程的API来开启光照，至于光照的实现效果以及如何实现一个符合需求光照的则与程序员无关。\n在现代API中已经升级为可编程管线，可编程管线开放了部分阶段给程序员，可以使程序员更加灵活的实现项目中所需要的各种效果，而不需要付出太大的成本，上图中蓝色的部分就是可编程管线中可自定义的部分。\n了解VAO，VBO这两个概念细说起来很复杂，后面再进行深入的学习，现阶段感性的认知是：\nVBO\nVBO全称：顶点缓冲对象(Vertex Buffer Objects)，它可以在GPU中开辟一块空间用于存储大量的顶点数据，方便我们在使用时一次性发送大量的顶点数据到显卡上，提高性能。\nVAO\nVAO全称：顶点数组对象(Vertex Array Object)，一次完整的VBO的配置使犯错且复杂的，为了避免在切换不同VBO以及重复使用VBO，我们应该将VBO与VAO进行绑定，这样VAO便会记录下所需要的信息，然后在切换与重复使用时操作VAO即可。\n感性理解：一个用于记录描述VBO模型的对象，方便的切换VBO配置。\n使用VBO创建VBOcpp\n// 申请缓冲区\nunsigned int vbo; // A\nglGenBuffers(1, &amp;vbo); // B\nglBindBuffer(GL_ARRAY_BUFFER, vbo); // C\nA行申请一个int类型变量，用于存放缓冲区的id。\nB行申请一个缓冲区对象，第一个参数表示申请数量，第二个参数是使用哪个变量来存储申请成功后的id。\nC行绑定id是vbo的缓冲区到GL_ARRAY_BUFFER类型的缓冲区上，缓冲区有很多种类型，由于我们这里是使用顶点缓冲区所以使用GL_ARRAY_BUFFER，其他缓冲区类型可以在glBindBuffer | docs.gl查看。\n绑定数据cpp// A\nfloat vertexs[6] = &#123;\n    -0.5f, -0.5f,\n    0.0f,   0.5f,\n    0.5f,  -0.5f\n&#125;;\n\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\n\n// B \nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);A行声明绘制三角形所需要的顶点位置，类型是一个float数组，每两个数据组成三角形的一个顶点位置信息。\nB行绑定顶点数据到指定类型的的缓冲区上，第一个参数指定了绑定到GL_ARRAY_BUFFER类型的缓冲区上，第二个参数是告诉OpenGL缓冲区数据的大小，第三个参数是把实际的顶点数据传入到缓冲区中，第四个参数是缓冲区中数据的预期使用方式，有多种方式可供选择这里选择了GL_STATIC模式，其含义是数据存储内容将被修改一次并多次使用。，其他预期类型可查看:glBufferData | docs.gl。\n解释数据的用途OpenGL的顶点着色器(Vertex Shader)允许使用任何形式的输入，所以这就需要我们手动的告诉OpenGl如何去解释这些数据。\ncpp\n    float vertexs[6] = &#123;\n        -0.5f, -0.5f,\n        0.0f,   0.5f,\n        0.5f,  -0.5f\n    &#125;;\n    unsigned int vbo;\n    glGenBuffers(1, &amp;vbo);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n        \n    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);\n\n    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);// A\n    glEnableVertexAttribArray(0); //BA行解释OpenGL如何使用缓冲区中的数据，这个解释只对当前的VBO生效，参数含义：\n\n第一个参数，表示顶点属性索引的值，与GLSL语言有关，表明本次解释的是某一特定的索引顶点属性，只要在Shader取值时布局索引对应上即可获取期望的数据，最大16；\n属性有几个分量；\n数据所使用的数据类型；\n是否归一化；\n一个分量数据的内存大小；\n在GL_ARRAY_BUFFER 缓冲区中，属性值第一次出现偏移量。\n\nB行在配置好顶点属性后，如果需要使用需要手动开启对应索引的顶点属性，默认是关闭所有的顶点属性的。\n\n\n\n\n\n\n\n\n\n如果需要其他属性的配置，如颜色，法线等信息，可以多次调用glVertexAttribPointer函数进行解释，并使用glEnableVertexAttribArray来开启顶点属性。\n此时按下F5运行项目会发现已经重新绘制出了上一篇的白色三角形。\n使用VAOVAO可以存储绑定顶点缓冲区与顶点属性值的信息，然后再绘制物体的时候只需要绑定相应的VAO就行了，可以方便的实现绘制不同物体。\nVAO存储的信息：\n\nglEnableVertexAttribArray和glDisableVertexAttribArray的调用。\n通过glVertexAttribPointer设置的顶点属性配置。\n通过glVertexAttribPointer调用与顶点属性关联的VBO。\n\n\nVAO使用起来非常简单就像VBO的创建一样，只需要调用glGenVertexArrays获取索引，然后使用glBindVertexArray绑定即可，绑定成功后任何随后的顶点属性调用都会储存在这个VAO中。\ncpp// 申请VAO\nunsigned int vao;\nglGenVertexArrays(1, &amp;vao);\n// 绑定VAO，绑定后所有的调用都会记录到当前VAO中\nglBindVertexArray(vao);\n\n\n// 顶点属性调用\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);\nglEnableVertexAttribArray(0);\n\n// 绘制循环\n...\n// 使用VAO\nglBindVertexArray(vao);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n...\n\n\n\n\n\n\n\n特别注意\n如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。\n\n\n再次按下F5运行项目，成功绘制出白色三角形。\n使用Shader虽然成功绘制出了白色三角形，但是现代OpenGL最厉害的特性Shader却一点没用上，下面就通过为三角形上色来入手，学习下Shader的使用。\nShader是一段代码片段，它运行在GPU上，作用是告诉GPU当前处理的图形应该如何绘制，比如：顶点在哪里，当前这个像素应该是什么样的等等，它是整个渲染管线的一部分，只不过是部分开放出来给我们自定义而已。\n\n\n\n\n\n\n粗暴理解\nShader就是OpenGL在绘制时暴露出来的回调函数，其上下文是属于OpenGL的，所以千万不要当做是我们开发程序的部分，就是一个回调函数而已。\n\n\n为什么需要Shader因为运行在GPU上效率高，比如我们需要绘制1000个像素的样色并不需要循环访问1000遍而是可以同时访问这1000个像素点。\n\n\n\n\n\n\n\n\n\n但是不能因为GPU快就把全部逻辑都交给GPU来做，很多时候还是要在CPU上计算，最后把结果一口气全部发到GPU上更快。\n顶点着色器与片段着色器常用的Shader有两个Vertex Shader(顶点着色器)和Fragment Shader(片段着色器)，它们的作用是：\n顶点着色器\n用于描述顶点的位置，在3D空间中一个点具体应该显示在哪里取决于我们如何进行观察，通过顶点着色器就可以让原始的顶点通过矩阵变换显示到屏幕中正确的位置。\n其作用对象是每一个顶点，每一个顶点会调用一次顶点着色器。\n片段着色器\n其作用对象是在确认了顶点信息后，最终会绘制到屏幕上的每一个像素点，每一个像素点会调用一次片段着色器。\n所以也可以叫做像素着色器，我觉得叫像素着色器更好理解，因为其作用就是处理绘制一个图形到屏幕时，该图形在屏幕所占面积的像素该如何显示的逻辑，操作的对象就是屏幕上图形所占面积的所有像素点，叫片段着色器总觉得词不达意，还是像素着色器更形象。\n\n\n\n\n\n\n举例说明\n在纸上画一个三角形并涂满颜色就好比我们使用Shader来绘制一个三角形： \n1.确定三角形在纸上的三个顶点在哪，对应的就是顶点着色器的工作；\n2.给三角形涂满颜色，并且确定都是什么颜色，对应的就是片段着色器的工作，只不过涂色粒度是像素而已。\n\n\n编写Shader编写Shader的过程其实和写代码是一样的，编写代码-&gt;编译代码-&gt;连接程序-&gt;喂给OpenGL，只不过这些个过程都内嵌到了我们的工程中作为代码的一部分存在，需要我们手动的来实现。\nShader代码cpp    // A\n    std::string vertexShader =\n        // B\n        &quot;#version 330 core\\n&quot;\n        &quot;\\n&quot;\n        // C\n        &quot;layout(location = 0) in vec4 position;\\n&quot;\n        &quot;\\n&quot;\n        &quot;void main() &#123;\\n&quot;\n        // D\n        &quot;\tgl_Position = position;\\n&quot;\n        &quot;&#125;&quot;;\n    // E \n    std::string fragmentShader =\n        &quot;#version 330 core\\n&quot;\n        &quot;\\n&quot;\n        &quot;layout(location = 0) out vec4 color;\\n&quot;\n        &quot;\\n&quot;\n        &quot;void main() &#123;\\n&quot;\n        // F\n        &quot;\tcolor = vec4(1.0, 0.0, 0.0, 1.0);\\n&quot;\n        &quot;&#125;&quot;;A行顶点着色器\nB行声明GLSL(OpenGL为开发Shader提供的编程语言)使用的版本\nC行layout(location &#x3D; 0) 确定使用哪一个索引的顶点属性对象，这个索引就是glVertexAttribPointer第一个参数设置的索引，使用一致的索引就可以获取到对应的内存布局的顶点属性。后面的in/out用于定义着色器的输入输出，这里是定义了一个名叫position的向量表示顶点位置，这个变量的值来自于顶点属性对象\nD行赋值到GLSL的内建变量上，该变量表示顶点的实际坐标\nE行片段着色器\nF行设置像素点颜色，OpenGL中颜色值使用vec4的向量表示，四个分量分别是r、g、b、a其区间在0~1\n编译着色器cpp\nstatic int ComplieShader(unsigned int type, const std::string&amp; source) &#123;\n    // A\n    unsigned int shader = glCreateShader(type);\n\n    // B\n    const char* src = source.c_str();\n    // C\n    glShaderSource(shader, 1, &amp;src, nullptr);\n    // D\n    glCompileShader(shader);\n\n    // E开始\n    int result;\n    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;result);\n\n\n    if (result == GL_FALSE) &#123;\n        int length;\n        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);\n        char* message = (char*)alloca(length * sizeof(char));\n\n        glGetShaderInfoLog(shader, length, &amp;length, message);\n\n        std::cout &lt;&lt; &quot;Failed to Compile&quot; &lt;&lt; (type == GL_VERTEX_SHADER ? &quot;vertex&quot; : &quot;fragment&quot;) &lt;&lt; std::endl;\n        std::cout &lt;&lt; message &lt;&lt; std::endl;\n\n        glDeleteShader(shader);\n\n        return 0;\n    &#125;\n    // E结束\n\n    // F\n    return shader;\n&#125;\n编译着色器是一个重复的工作，所以可以封装为一个方法使用\nA行申请一个指定类型的着色器，好比于创建一个C++文件\nB行把C++风格的字符串转换为C风格的字符串，因为OpenGL是C开发的所以需要转换下\nC行给指定的着色器绑定源码，好比把代码写到文件里\nD行编译着色器，好比于把C++代码编译成.obj文件\nE区域因为Shader是运行在GPU没法直接发送消息到CPU这边，所以需要写一些代码来获取Shader编译的日志信息，如果发生了错误可以打印出错误信息供调试使用\nF行返回着色器的id\n创建着色器程序Opengl的着色器程序总会让人头晕，在程序里多了一OpenGL就够了，为什么OpenGL里又多个程序，这程序有啥用，为什么这么写之类的疑问，这里其实有几个点捋顺了会好理解很多：\n\n着色器程序类似于编译后链接各个文件的过程，它把多个单独的着色器链接在一起打包成一个整体（就好比C++能编程成.exe的可执行程序或者是.lib的链接库一样），绑定给OpenGL后，在渲染对象的时候激活这个着色器程序，我们可以先创建多个着色器程序等到需要的时候切换到特定的程序上\nOpenGL是一个巨大的状态机，所以它一定是有一个有限的逻辑变化并且根据逻辑状态的变化不停接收输入，产出输出的东西，着色器程序就是这个机器中的一个部分，当OpenGL的状态切换到计算顶点/片段信息时，就需要着色器程序这个工具来操作，所以虽然叫着色器程序但其实相当于OpenGL这个大机器中的一个小部位，甚至直接理解成动态绑定给OpenGL的一个库也不是不行\n\ncpp\n\nstatic int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader) &#123;\n    // A\n    unsigned int program = glCreateProgram();\n\n    // B\n    unsigned int vs = ComplieShader(GL_VERTEX_SHADER, vertexShader);\n    unsigned int fs = ComplieShader(GL_FRAGMENT_SHADER, fragmentShader);\n\n    // C\n    glAttachShader(program, vs);\n    glAttachShader(program, fs);\n\n    // D\n    glLinkProgram(program);\n\n    // E\n    glValidateProgram(program);\n\n    return program;\n\n&#125;\nA行创建一个着色器程序，好比创建一个C++工程\nB行调用编译着色器代码，获取到编译后的着色器，好比获取了需要连接的.obj文件\nC行把着色器添加到着色器程序里，好比把文件添加到了工程里\nD行链接着色器到着色器程序，好比链接程序把多个.obj链接到一个.exe/.lib上，此时就像我们可以直接使用可执行程序或者运行库一样，直接使用这个着色器程序就以为着所有相关信息都能获取到\nE行校验着色器程序是否正确\n启用着色器程序在代码里我们只需要调用CreateShader并传入前面编写的Shader代码模板获取到一个可用着色器程序id，并通过glUseProgram函数启用即可。\ncpp\n// 定义CreateShader与ComplieShader函数\n\n// 编写vertexShader与fragmentShader的代码\n\nunsigned int shader = CreateShader(vertexShader, fragmentShader);\nglUseProgram(shader);\n\n\n// 在绘制循环中，正常调用draw call\nglDrawArrays(GL_TRIANGLES, 0, 3);\n此时按下F5会看到一个红色的三角形，至此使用Shader编程开发一个简(复)单(杂)的三角形就完成啦。\n\n容易晕的点我们在代码中所有对OpenGL的调用都是一些命令函数，其具体过程都是在GPU中实现且最后并不会返回实际的东西回来，都是返回我们调用的函数所期望产生的对象的唯一标识id（也可能是索引）\n所以不像正常面向对象时的逻辑：\n\n我有一个缓冲区对象\n我要操作什么，缓冲区对象.xxx();\n\n而是这样：\n\n程序：GPU给我搞一个缓冲区对象\nGPU：搞完了，id是xxx\n程序：OK，GPU我有一个缓冲区对象id是xxx，帮我把它绑定到GL_ARRAY_BUFFER这个缓冲区上\nGPU：搞完了\n程序：我有一个缓冲区对象id是xxx，我要这样这样描述…\nGPU：OK\n程序：我有一个缓冲区对象id是xxx…\nGPU: OK\n\n\n参考代码\n\n在新标签页中打开查看高清图\n","slug":"图形学/OpenGL/OpenGL3","date":"2021-12-21T16:00:00.000Z","categories_index":"图形学,OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"天然卷打工战士"},{"id":"6160cc6d102bffa77808f7eb2e12f02e","title":"关于0.1+0.2!=0.3这件事","content":"\n0.1 + 0.2 === 0.3吗？在JavaScript有一个经典的面试题，那就是”0.1 + 0.2 === 0.3吗？”\n这个题看起来非常的弱智哈，只要小本毕业了肯定都秒答”必须的啊”，啊，要这么认为那这题肯定是挂了，嗯。\n然后简单敲一下，啊，还真就错了。\n\n原因是计算结果并不是正好的0.3而是0.30000000000000004\n\n很明显这是一个浮点型计算精度的问题，这就需要讨论一下JS中是如何存储数字的了。\nJS中的Number类型在JS中不区分整型和浮点型（没有int，float，double区分），所有的数字都会统一使用Number这个类型来表示；\nNumber如何存储数字的因为要兼顾整型与浮点型，所以JS中的Number类型采用的是IEEE754标准（二进制浮点数算术标准）的浮点数存储标准，这个标准也是20世纪80年代以来最广泛使用的浮点数运算标准，这个标准一共规定了4种表示浮点数值的方式其中就有我们常见的float和double两个类型：\n\nbinary32: 单精度\nbinary64: 双精度\n\n其中binary32是需要强制实现的，其他的类型都可以选择实现，JS在这里采取了binary64来实现Number类型\nbinary64的定义与内存布局数学定义IEEE754中对二进制浮点数的数学定义如下：\n\n各项的含义分别是：\n\nValue：二进制原值；\nsign(s)：符号位 取值 0，1代表正负；\nexponent(e)：阶码（指数偏移值） = 阶码真值 ± 127/1023（32/64位情况）；\nfraction(f)：尾数(分数值) = 去除最高位后的小数部分。\n\n\n\n\n\n\n\n\n\n\n对细节感兴趣的可以点击这里IEEE754 wiki（需科学上网）\n内存布局对应的内存布局\ntxt0 |  1 0 0 0 0 0 0 0 0 0 0 | 1 | 0 0 0 0 0 0 ... 0 0 0 0\ns |  ---exponent(11bit)--- | h | ----fraction(52bit)----最高位是符号位，后面是 11 的阶码，最后是 52 位尾数，在尾数前有 1 位的隐藏位。\n这里涉及到一个概念问题，不同于我们常说的小数（十进制下），在计算机只认识[0,1]是没有小数点这个概念的，所以才会用IEEE 745来定义如何表达小数，这个方式被称作浮点数，浮点数的关键就在于这个阶码(exponent)，它表示了小数点应该在这53位尾数中的哪一位。\n要理解这个阶码先看下十进制小数转换为二进制的规则。\n十进制小数的二进制表达公式：\n其中：\n\n指数的基数是 2\n|a| &gt;= 1&amp;&amp; |a| &lt; 2 (就是永远为1)\nn 为正整数\n\n举例:\n\n对应这个结果重新看浮点数的定义\n\n阶码 对应的是 n = 2 + \n隐藏位对应的是 有效位 = 1.0\n尾数对应的是 小数部分 = 0.0111\n\n对应的内存布局\n\n测试地址 | IEEE-754 Floating Point Converter\n\n\n\n\n\n\n\n\n\n看过如何把十进制数字转换为二进制表示后可以发现二进制的小数整数位永远都是1（二进制的世界里没有0开头的数字），所以就隐藏掉了，这样还能多出来一位来表示小数位加大一点精度。\n总结0.1 + 0.2 != 0.3这个问题，其本身是小数与浮点数两个概念的带来的混淆所产生的，即：我们意识中的小数的有效位数是明确的，所以在写代码时也会下意识的认为只计算有效位的结果，而计算机并不能存储小数而是浮点数的形式进行存储，其精度不能得到保证，在这个问题中0.3作为显式定义的浮点数必然与由0.1 + 0.2计算得到的新浮点数精度不一致，导致计算结果出现错误。\n\n0.3显式声明的内存布局\n\n想要规避这个问题可以采用放大的方式来保证有效位的计算，比如所有数字乘10: 1 + 2 === 3，然后在需要的时候再还原回来即可保证精度的计算。 \n[Bonus]在其他语言中的浮点数在Java和C/C++里float使用了binary32，double使用了binary64，这两个语言中都对浮点数计算时进行了特殊的处理保证计算结果精度的正确性。\n值得一提的是在Java中如果不显示声明数字是float类型计算时也同样会产生和JS一样的bug，显式声明后则不会出现\n\njava运行结果（不显式声明为浮点型）\n\n\njava运行结果（显式声明为浮点型）\n\n\n在C++中则不存在这个问题\n\nC++运行结果\n\n\n","slug":"浮点数的定义","date":"2021-12-13T16:00:00.000Z","categories_index":"","tags_index":"JavaScript","author_index":"天然卷打工战士"},{"id":"48f3ebc985f2f9c9c1a27375e29f50ed","title":"OpenGL「二」：使用现代OpenGL","content":"在上一篇中我们已经使用OpenGL成功的在窗口中绘制了一个白色三角形，虽然非常简单，但是使用的代码却是OpenGL1.1版本的老代码，在2021的今天那肯定是不满足我们了，所以在这篇我们来看看如何引入现代的OpenGL API。\n现在OpenGL在哪？前面说过OpenGL的本质是一个跨平台的图形标准，并没有实现代码，其具体实现是由显卡厂商具体实现的，所以各个版本的实现都是存在于我们的GPU中，正常情况下我们是无法定位到函数的位置，我们需要一种手段获取到存在GPU中的函数的地址让我们可以正常的调用它们，常规情况下我们可以借助系统函数来实现这一需求，比如：\ncpp...\n\n// 查询名为apiName的函数\nvoid *p = (void *) wglGetProcAddress(apiName);\n// 如果p存在则调用\nif (p) &#123;\n    p();\n&#125;\n// 如果没有可能还要判断是否在1.1版本中，实现兼容方案等\n...可以看到手段是很繁琐的，就算是封装为函数了也需要考虑这样那样的兼容，非常的让人头大。\n但是我们作为一个一般的开发者，要是全部的函数都封装一遍还要跟上OpenGL的版本更新，那显然是不太现实的，所以我们就需要用到一些大佬们封装的库来降低开发成本，本次使用的GLEW就是其中广泛使用的库，下面就来学习下GLEW的配置和使用。\nGLEW先来看下官网对于GLEW的描述：\nThe OpenGL Extension Wrangler Library (GLEW) is a cross-platform open-source C&#x2F;C++ extension loading library. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. OpenGL core and extension functionality is exposed in a single header file. GLEW has been tested on a variety of operating systems, including Windows, Linux, Mac OS X, FreeBSD, Irix, and Solaris.\nOpenGL扩展Wrangler库（GLEW）是一个跨平台的开源C&#x2F;C扩展加载库。GLEW提供了高效的运行时机制，用于确定目标平台上支持哪些OpenGL扩展。OpenGL核心和扩展功能在单个头文件中公开。GLEW已经在多种操作系统上进行了测试，包括Windows、Linux、Mac OS X、FreeBSD、Irix和Solaris。\n根据官网的描述，可以知道GLEW是一个高效的确定目标平台上支持那些OpenGL的扩展，使用这个库可以保证我们平台无关的获取到想要的API，这里就包括我们说的现代API。\n这就是库就非常好的地方，就像JQuery之于前端一样，可以让我们完全的从各种版本和平台的兼容性中解放出来，专注于开发业务，而不是去写那无穷尽的hack。\n配置GLEW环境1.首先下载GLEW库\nGLEW下载地址\n\n\n\n\n\n\n\n\n\n\n这里下载编译好的包即可，如果是开发项目可以选择下载源码方便进行调试。\n2.解压文件\n\n3.VS中的配置\n3.1添加到工程\n把解压好的文件夹复制到工程的\\Dependencies下\n3.2配置\n配置附加目录\n\n配置附加依赖库\n\n配置附加依赖项\n\n由于GLEW在运行时区分动态库和静态库，所以我们还需要配置一下宏，\n\nGLEW_STATIC：静态库宏\nGLEW_BUILD：动态库宏\n\n\n右键点击工程-&gt;C/C++-&gt;预处理器-&gt;预处理器定义\n\n编写测试代码我们使用GLEW调用glGenBuffers函数并打印当前OpenGL版本号来进行测试。\ncpp#include &lt;iostream&gt;\n// 引入GLEW\n#include &lt;GL/glew.h&gt;\n#include &lt;GLFW/glfw3.h&gt;\n\nint main(void)\n&#123;\n    GLFWwindow *window;\n\n    // ... 省略窗口创建过程\n\n    /* Make the window&#39;s context current */\n    glfwMakeContextCurrent(window);\n    // 初始化GLEW\n    if (glewInit() != GLEW_OK)\n    &#123;\n        std::cout &lt;&lt; &quot;GLEW is Error&quot; &lt;&lt; std::endl;\n    &#125;\n    //申请缓冲区\n    unsigned int a;\n    glGenBuffers(1, &amp;a);\n    //打印OpenGL版本\n    std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;\n    //  ...省略绘制b部分\n \n    glfwTerminate();\n    return 0;\n&#125;运行结果\n\nQ&amp;Agl.h included before glew.h\n\n\n\n\n\n\n\n\n\n通过查阅官网的Usage可以得知，在调用glewInit前需要先创建一个有效的OpenGL渲染上下文，所以调用时间应在glfwMakeContextCurrent函数后再调用。\n无法解析的外部符号 __imp__glewInit@0，函数 _main 中引用了该符号\n\n\n\n\n\n\n\n\n\n没有定义宏。\n","slug":"图形学/OpenGL/OpenGL2","date":"2021-12-10T16:00:00.000Z","categories_index":"图形学,OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"天然卷打工战士"},{"id":"8d43fa0304d1f9bd1b2ad6d1921fba3a","title":"OpenGL「一」：使用C++编写第一个OpenGL窗口程序","content":"环境准备\nVS2019\nGLFW\n\n下载GLFW一个轻量级的，开源的，跨平台的library。支持OpenGL及OpenGL ES，用来管理窗口，读取输入，处理事件等功能。需要这个库的原因是OpenGL本身只是标准，所以并没有提供窗口管理的功能，所以需要使用工具来帮助我们开发，而GLFW就是其中不错的选择。\n\n\n\n\n\n\n\n\n\nGLFW名称具体含义没有查到，但是看功能应该是OpenGl for window，这里window不是指windows系统而是应用程序窗口的window。\n下载GLFW官方下载地址\n\n选择下载32位的程序\n下载完成后解压文件，这里我们主要关注include和lib-vs2019两个目录，分别是头文件位置和链接库位置。\n\n\n\n\n\n\n\n提示\n如果使用的不是VS2019，选择对应版本的即可。\n\n\n在VS中创建C++工程打开VS，点击创建新项目-&gt;C++空项目点击下一步，起名OpenGL并选择好工程目录后点击创建。\n\n工程创建成功后，点击红框按钮切换视图并创建src文件夹以及Application.cpp文件\n\n输入以下代码，按F5，测试工程是否能正常启动\ncpp#include &lt;iostream&gt;\n\nint main(void) &#123;\n    std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;\n    std::cin.get();\n&#125;确认启动正常后，复制GLFW的示例代码到Application.cpp中\n官方示例地址\ncpp#include &lt;GLFW/glfw3.h&gt;\n\nint main(void)\n&#123;\n    GLFWwindow* window;\n\n    /* Initialize the library */\n    if (!glfwInit())\n        return -1;\n\n    /* Create a windowed mode window and its OpenGL context */\n    window = glfwCreateWindow(640, 480, &quot;Hello World&quot;, NULL, NULL);\n    if (!window)\n    &#123;\n        glfwTerminate();\n        return -1;\n    &#125;\n\n    /* Make the window&#39;s context current */\n    glfwMakeContextCurrent(window);\n\n    /* Loop until the user closes the window */\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        /* Render here */\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        /* Swap front and back buffers */\n        glfwSwapBuffers(window);\n\n        /* Poll for and process events */\n        glfwPollEvents();\n    &#125;\n\n    glfwTerminate();\n    return 0;\n&#125;此时代码会全是异常，无法运行，所以开始配置GLFW环境。\n配置GLFW环境首先，打开工程目录并在当前项目的上一级也就是解决方案的目录下(包含OpenGL.sln文件的目录)创建文件夹Dependencies用于存放各种依赖库。\n创建好Dependencies文件夹后，再创建GLFW文件夹，并把之前下载的GLFW压缩包中的include和lib-vc2019文件夹复制到Dependencies\\GLFW下\n\n同时由于我们希望GLFW库是静态链接到我们的项目中，所以lib-vc2019文件夹中的glfw3.dll和glfw3dll.lib都可以删除掉，保持项目的干净。\n\n第二步，右键点击工程-&gt;属性打开属性页。\n\n然后点击C/C++-&gt;常规-&gt;附加包含目录配置包含目录为Dependencies\\GLFW\\include目录\n\n第三步，类似附加包含目录我们继续配置链接器的目录\n点击链接器-&gt;常规-&gt;附加库目录配置包含目录为Dependencies\\GLFW\\lib-vc2019目录\n\n再选择链接器-&gt;输入-&gt;附加依赖项，添加glfw3.lib作为附加库\n\n至此回到Application.cpp按F7间编译会发现没有报错了，再次按下F5可以正确的弹出OpenGL窗口。\n\n绘制第一个三角形为了体验OpenGL所以这里简单绘制了一个三角形在窗口中，代码如下：\ncpp#include &lt;GLFW/glfw3.h&gt;\n\nint main(void) &#123;\n    ...\n    /* Loop until the user closes the window */\n    while (!glfwWindowShouldClose(window)) &#123;\n        /* Render here */\n        glClear(GL_COLOR_BUFFER_BIT);\n        // 绘制三角形\n        glBegin(GL_TRIANGLES);\n\n        glVertex2f(-0.5f, -0.5f);\n        glVertex2f(0.0f, 0.5f);\n        glVertex2f(0.5f, -0.5f);\n\n        glEnd();\n        // 绘制结束\n        ...\n    &#125;\n    ...\n    return 0;\n&#125;启动项目可以看到一个白色的三角形在窗口中央\n\n\n\n\n\n\n\n\n特别注意\n这里绘制三角形的代码使用的是已经淘汰的legacy OpenGL(早期的固定管线时期)代码，并非是现代OpenGL语法，这里仅供展示用。\n\n\n至此关于GLFW的环境就全部搭建完毕了，以后会在此基础上开始后面的学习。\n\n[Bonus]关于链接器Cherno在这里进行了一个演示，就是把附加依赖项中的附加库全部删除掉了，只添加glfw3.lib作为附加库，此时代码不会报错，但是按下F5后在链接阶段会报很多错\n\n这是由于缺少一些系统依赖库所导致的，面对这种情况只需要报错信息中蓝框中的部分（_之后，@之前）复制出来到百度搜索一下就可以很快的找到解决方案（其实就是微软官方文档）\n\n点击进入文档后，滑动到最下面，找到对应的库名重新添加到附加依赖项即可\n\n此例中报错原因是缺少User32.lib所导致的，所以将其添加到附加依赖项就可以解决问题。\n","slug":"图形学/OpenGL/OpenGL1","date":"2021-12-06T16:00:00.000Z","categories_index":"图形学,OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"天然卷打工战士"},{"id":"9297302560a828b99950be98432fa02c","title":"OpenGL「零」：什么是OpenGL","content":"\n\n\n\n\n\n提示\n本系列内容全部来自Cherno的OpenGL系列视频，是对该系列内容的一个学习和总结，这个系列视频的目的是学习OpenGL的使用和思想，可能会使用非现代OpenGL的内容同时并不会实际开发一些可投入生产的库，所以代码仅供参考。\n\n什么是OpenGLOpenGL一般被认为是一套跨平台的图形开发API，本质上是一套标准，所以和类似编程语言的标准一样OpenGL是没有代码实现的，其具体实现由显卡厂商进行实现。\nOpenGL规范只是严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现的，将由OpenGL库的开发者自行决定。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配即可。\n正是由于具体实现由显卡厂商进行实现，所以在实际场景中各家显卡对OpenGL的支持以及实现方式都有所不同，导致同样的代码在不同显卡上会有不同表现，甚至是出现Bug。\n\n\n\n\n\n\n\n\n\n虽然OpenGL中带个Open字样，因为只是标准没有实现，同时具体实现都是由显卡厂商提供，而显卡厂商根本不会把自家驱动开源出来，所以其实根本没有开源一说。\n其他竞品其他图形API还有诸如Direct3D、Vulkan、Metal等。\n优缺点Metal苹果独占，抬走下一位。\nDirect3D优点\n微软开发，Win平台自带，所以对Win平台极度优化，API友好，在Win上的不二之选，同时可以使用C#开发，上手门槛也并不高。\n缺点\n不支持跨平台，Win独占\nVulkan优点\n和OpenGL同门，是最新一代的API，同样支持跨平台\n缺点\n出现时间比较晚，没有OpenGL，D3D这么成熟；上手难度高，需要有一定的功底才能玩的明白(菜鸡劝退)。\n为什么还是选择OpenGL对比OpenGL这些API的缺点，OpenGL上手难度适中，在可跨平台上也比较成熟，所以综合来说是成本最小的一个，所以在选择它来入门是非常合适的。\n\n\n\n\n\n\n提示\n对于实际项目相对于直接使用OpenGL的API而言，很多人会把API封装成D3D风格，这样就能又使用OpenGL又能有一个人性化的API来使用了。\nps: 如果目标平台只有Win，那么大可不必用OpenGL找罪受，直接D3D起飞更合适。\n\n\n","slug":"图形学/OpenGL/OpenGL0","date":"2021-12-05T16:00:00.000Z","categories_index":"图形学,OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"天然卷打工战士"},{"id":"36c783b7f07c9ef5c2531a5b03a12c76","title":"享元模式","content":"描述享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。\n通俗的说就是把相似对象的通用部分进行抽离成为元对象，并在原对象中进行引用，此时所有对象持有的元对象指针都指向同一内存地址，所以大大减少内存开销。\n\n\n\n\n\n\n\n\n\n注意，共享的元对象应只包括上下文无关的属性，也就是说不包含任何状态的通用属性。\n应用场景存在大量相似对象时的内存溢出和效率问题。\n游戏中的实例\n瓷砖地图\n重复物体渲染\n\n模式角色\n共享元对象（meta-object）存放不包含任何状态的属性；\n元对象工厂（factory）创建并缓存元对象；\n实体类（entity）存放具有状态的属性，并持有元对象指针。\n\n","slug":"享元模式","date":"2020-08-17T16:00:00.000Z","categories_index":"","tags_index":"设计模式,游戏设计模式","author_index":"天然卷打工战士"},{"id":"5bb8772a21d2fa7313e330cd8614eb64","title":"v8如何存储对象属性","content":"v8中属性的存放分为快慢属性两种，如果是数字索引则会分配在elements属性中使用线性查询，如果是慢属性则要复杂一些：当属性个数少于10个（这个数字可能根据对象申请时空间而变化）则这些属性会分配到对象内空间；如果属性个数多于10个则会把多出来的属性放到properties属性中并使用线性方式存储；如果多于10个且远远多于10个则会将多出来的属性存储在properties上并使用非线性的存储方式（词典）\n思考题：为什么不推荐使用delete删除属性?\n原因1 delete并不是直接释放内存，而是切断引用从而间接的达到内存释放。原因2 因为线性存储查改快，增删慢的特点，所以在使用delete的情况下，会从快慢属性的列表中移除该属性，导致线性存储触发增删操作，降低效率。原因3 因为delete会移除快慢属性，所以在操作慢属性时，如果属性个数在临界值，可能会在增删的同时触发存储结构的重排（字典变化为线性）导致消耗更多的性能。\n","slug":"v8如何存储对象属性","date":"2020-08-14T16:00:00.000Z","categories_index":"","tags_index":"JavaScript","author_index":"天然卷打工战士"},{"id":"51d32e32729eed215a5d3851fb64aa7c","title":"发布订阅模式与观察者模式的区别","content":"角色上的区别观察者模式:\n\nsubject(被观察者)\nobserver(观察者)\n\n发布订阅模式:\n\nPublisher(发布者)\nSubscriber(订阅者)\nBroker(中介人)\n\n对于观察者(订阅者)的区别观察者模式:\n直接存储在被观察者中，由被观察者直接的遍历通知观察者，对于某一被观察者而言需要维护自身的全部观察者。\n发布订阅模式:\n所有的订阅者通过订阅一个或多个topic(主题)的方式讲自身注册到中介人中。\n对于被观察者(发布者)的区别观察者模式:\n在自身中存储全部的观察者对象，对于某一被观察者而言需要维护自身的全部观察者的监听状态。\n发布订阅模式:\n发布者不需要持有订阅者对象，只需要持有中介人对象即可，发布者可以不关心订阅者的存在与具体状态。\n状态发生改变时的区别观察者模式:\n由被观察者直接遍历所有观察者并发送通知。\n发布订阅模式:\n发布者只需要告诉中介人自己需要更新那个topic(主题)即可，由中介人遍历通知所有订阅了该主题的订阅者。\n总结发布订阅与观察者相似，但区别在于观察者模式中，subject(被观察者)、observer(观察者)都是派生自基类之中，其中被观察者直接持有观察者的指针，当被观察者状态发生改变时，由自身遍历所有观察者并发出通知。而在发布订阅模式中则是多出一个中介人(broker)的角色与topic(主题)来进行消息的分发，也就是说当Publisher(相当于被观察者)发生变化时主动的调用中介人类并告知中介人自己要更新哪个主题下的状态此后由中介人来查找对应的主题下的Subscriber(相当于观察者)进行状态的更新，而Subscriber也只需要把自身注册到中介人中并告知中介人自己需要订阅哪些主题即可，此时订阅者与发布者只知道中介人存在而不知道彼此的存在。\n","slug":"发布订阅模式与观察者模式的区别","date":"2020-08-12T16:00:00.000Z","categories_index":"","tags_index":"设计模式","author_index":"天然卷打工战士"},{"id":"cd55e9d94b94ab2ca447027ce4beeca6","title":"观察者模式","content":"描述观察者模式通过“主题”与“观察者”以低耦合的方式来解决对象间存在的一对多关系，如某一对象状态发生改变时，对其他依赖组件发送通知并自动更新。\n应用场景具有一对多关系且需要同时更新的场景\n游戏中的实例\n数据变化与ui的绑定\n成就系统\n\n\n\n\n\n\n\n\n思考题: 观察者模式与发布订阅的区别\n\n\n模式中的角色\nsubject(被观察者、主题)是一个基类，包含notify、addObjserver、removeObserver等接口，用来注册观察者，并在状态发生改变时通知所有观察者;\nobserver(观察者)是一个基类，包含update接口，将自身注册到被观察者类中，并在收到通知后进行状态的更新。\n\n","slug":"观察者模式","date":"2020-08-11T16:00:00.000Z","categories_index":"","tags_index":"设计模式,游戏设计模式","author_index":"天然卷打工战士"},{"id":"35b7e7d45f0bf660fac88351c60754e3","title":"命令模式","content":"描述命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n应用场景gui 交互时可以使用。\n\n快捷键所触发的指令\ncmd类指令式交互界面\n\n游戏中的实例\n回放功能: 只需要记录指令栈即可；\n宏命令功能: 将指令进行压缩，变成一个指令队列顺序执行；\n撤销（上一步）功能: 在命令中添加undo接口，并记录最后一次状态改变的值；\n键盘按键释放技能: 按下指定按键时，触发指定命令请求指定功能；\n技能按键绑定。\n\n模式角色\n指令基类（command）\n\n接收器（received）\n\n请求发生器（invoker）\n\n具体命令，继承自指令基类（ConcreteCommand）\n\n\n实现接收器，收音机\njavapublic class AudioPlayer &#123;\n    public void play() &#123;\n        System.out.println(&quot;播放...&quot;);\n    &#125;\n    public void rewind() &#123;\n        System.out.println(&quot;倒带...&quot;);\n    &#125;\n    public void stop() &#123;\n        System.out.println(&quot;停止...&quot;);\n    &#125;\n&#125;命令基类\njavapublic interface Command &#123;\n    /**\n     * 执行方法\n     */\n    void execute();\n&#125;命令具体实现类\njavapublic class PlayCommand implements Command &#123;\n    private AudioPlayer myAudio;\n    public PlayCommand(AudioPlayer audioPlayer) &#123;\n        myAudio = audioPlayer;\n    &#125;\n    /**\n     * 执行方法\n     */\n    @Override\n    public void execute() &#123;\n        myAudio.play();\n    &#125;\n&#125;javapublic class RewindCommand implements Command &#123;\n    private AudioPlayer myAudio;\n    public RewindCommand(AudioPlayer myAudio) &#123;\n        this.myAudio = myAudio;\n    &#125;\n    @Override\n    public void execute() &#123;\n        myAudio.rewind();\n    &#125;\n&#125;请求发生器，键盘输入\njavapublic class Keypad &#123;\n    private Command playCommand;\n    private Command rewindCommand;\n    private Command stopCommand;\n    public void setPlayCommand(Command playCommand) &#123;\n        this.playCommand = playCommand;\n    &#125;\n    public void setRewindCommand(Command rewindCommand) &#123;\n        this.rewindCommand = rewindCommand;\n    &#125;\n    public void setStopCommand(Command stopCommand) &#123;\n        this.stopCommand = stopCommand;\n    &#125;\n    /**\n     * 执行播放方法\n     */\n    public void play() &#123;\n        playCommand.execute();\n    &#125;\n    /**\n     * 执行倒带方法\n     */\n    public void rewind() &#123;\n        rewindCommand.execute();\n    &#125;\n    /**\n     * 执行播放方法\n     */\n    public void stop() &#123;\n        stopCommand.execute();\n    &#125;\n&#125;客户端调用\njavapublic class Julia &#123;\n    public static void main(String[] args) &#123;\n        // 创建接收者对象\n        AudioPlayer audioPlayer = new AudioPlayer();\n        // 创建命令对象\n        Command playCommand = new PlayCommand(audioPlayer);\n        Command rewindCommand = new RewindCommand(audioPlayer);\n        Command stopCommand = new StopCommand(audioPlayer);\n        // 创建请求对象\n        Keypad keypad = new Keypad();\n        keypad.setPlayCommand(playCommand);\n        keypad.setRewindCommand(rewindCommand);\n        keypad.setStopCommand(stopCommand);\n        // 测试\n        keypad.play();\n        keypad.rewind();\n        keypad.stop();\n        keypad.play();\n        keypad.stop();\n    &#125;\n&#125;","slug":"命令模式","date":"2020-08-04T16:00:00.000Z","categories_index":"","tags_index":"设计模式,游戏设计模式","author_index":"天然卷打工战士"},{"id":"4733d01d48a0a10d2db65c3579578d4b","title":"MonoGame Nez分辨率切换ui定位不准","content":"在设置Stage.IsFullScreen属性为true时，切换分辨率会导致ui点击位置发生偏移，所以只需要把该属性设置为false或者不设置即可。\n在设置Canvas.IsFullScreen属性为true时，在原分辨率下ui点击位置同样发生偏移，同时在切换分辨率时ui的定位也会发生偏移，所以只需要把该属性设置为false或者不设置即可。\n","slug":"MonoGame Nez分辨率切换ui定位不准","date":"2020-06-18T16:00:00.000Z","categories_index":"","tags_index":"游戏开发,MonoGame,Nez","author_index":"天然卷打工战士"},{"id":"e045146adaed8a16cc8d2f3b3398f352","title":"MonoGame Nez跟随角色与固定UI","content":"摄像机跟随角色框架提供了FollowCamera摄像机来方便的创建跟随摄像机，只需要传入一个实体即可实现对该实体的跟踪。\ncsCamera.Entity.AddComponent(new FollowCamera(soneEntity));在使用了这个摄像机后UI组件会出现虽然显示在正确的位置但是并不能正确响应的问题，该问题的原因是在不使用任何渲染器的情况下，UI组件也会被摄像机进行了视口与游戏世界的坐标转换，导致UI看似显示正常但是不能正确响应交互的现象，为了解决这个问题我们需要把UI与游戏世界使用不同渲染器分开渲染来达到目标效果，下面就通过使用ScreenSpaceRenderer渲染器来解决这个问题。\n固定UIScreenSpaceRenderer渲染器\n\n\n\n\n\n\n\n\n\nRenderer that renders using its own Camera which doesnt move.\n使用一个渲染器，渲染器拥有自己的摄像机，该摄像机不会进行移动。\n通过渲染器的描述我们能发现这个渲染器在渲染时拥有自己的摄像机并且该摄像机也不会进行移动，正好符合我们的要求所以我们尝试用这个渲染器来进行UI的渲染。\n下面开始搞起来。\n添加一个ScreenSpaceRenderer到场景中。\ncs\n// ScreenSpaceRenderer(int renderOrder, params int[] renderLayers)\n// renderOrder: 渲染器的渲染时的顺序\n// renderLayers: 使用此渲染器渲染时的层级，如果组件设置的RenderLayer不在列表中则不会被这个渲染器渲染，而是被默认渲染器渲染\n\nAddRenderer(new ScreenSpaceRenderer(1, 1, 2));\n设置RenderLayer(渲染层)\ncs\nvar Canvas = CreateEntity(&quot;Canvas&quot;).AddComponent&lt;UICanvas&gt;(new UICanvas());\nCanvas.RenderLayer = 1;\n// draw UIRenderLayer并不是所有组件都会有RenderLayer属性，只有集成在RenderableComponent的组件才会有这个属性, 如UICanvas组件\ncspublic class UICanvas : RenderableComponent, IUpdatable\n","slug":"MonoGame Nez跟随角色与固定UI","date":"2020-06-17T16:00:00.000Z","categories_index":"","tags_index":"游戏开发,MonoGame,Nez","author_index":"天然卷打工战士"},{"id":"acf46439f7beafe8650eed8a03f181c0","title":"MonoGame官方文档(二)","content":"添加内容这部分内容会添加内容到我们的游戏中去，有关于项目的创建可以参考创建新项目，我们现在需要一些内容放置到我们的游戏中去，对于本教程我们使用下面这个球：\n\n点击鼠标”右键-&gt;图片另存为”命名为ball.png并保存到任意文件夹。\n现在打开项目文件夹并看向左边(也可能是右边)，找到”解决方案资源管理器”窗口。展开content文件夹然后双击打开Content.mgcb文件。\n\n我们现在可以看到MGCB编辑器窗口已经打开，如果没有正确打开，需要用”右键-&gt;打开方式-&gt;MonoGame Pipeline Tool”方式打开。\n\n游戏中的内容都是通过这个外部工具来进行管理的。可以通过一下方式为游戏添加内容：\n\n在工具栏的”Add Existing Item”按钮\n在菜单栏的”Edit &gt; Add &gt; Existing Item…”\n在左侧菜单中”right-click &gt; Add &gt; Existing Item…”按钮\n\n现在我们使用工具栏中的”Add Existing Item”按钮来添加内容。\n\n现在会出现一个选择文件的提示框。选择刚才下载”ball.png”。选择后系统将会询问添加文件是的策略，可以选择设置为默认，然后点击”确定”即可。\n\n现在点击工具栏上的”保存”按钮，然后关闭工具。\n\n现在我们已经把资源引入进来了，现在我们来加载它们。首先我们先声明一个变量，这让我们可以图片加载到内存中。\ncspublic class Game1 : Game\n&#123;\n    Texture2D ballTexture;\n\n    GraphicsDeviceManager graphics;接下来找到LoadContent函数并初始化ballTexture变量：\ncsprotected override void LoadContent()\n&#123;\n    // Create a new SpriteBatch, which can be used to draw textures.\n    spriteBatch = new SpriteBatch(GraphicsDevice);\n\n    // TODO: use this.Content to load your game content here\n    ballTexture = Content.Load&lt;Texture2D&gt;(&quot;ball&quot;);\n&#125;最后找到Draw方法，然后将球绘制到屏幕上：\ncsprotected override void Draw(GameTime gameTime)\n&#123;\n    graphics.GraphicsDevice.Clear(Color.CornflowerBlue);\n\n    // TODO: Add your drawing code here\n    spriteBatch.Begin();\n    spriteBatch.Draw(ballTexture, new Vector2(0, 0), Color.White);\n    spriteBatch.End();\n\n    base.Draw(gameTime);\n&#125;现在启动项目，可以看到下图：\n\n","slug":"MonoGame官方文档(二)","date":"2020-06-11T16:00:00.000Z","categories_index":"","tags_index":"游戏开发,MonoGame","author_index":"天然卷打工战士"},{"id":"5f6f6649742c70ec6ba94bdb691b49e4","title":"MonoGame官方文档(一)","content":"了解代码引用包csusing Microsoft.Xna.Framework;\nusing Microsoft.Xna.Framework.Graphics;\nusing Microsoft.Xna.Framework.Storage;\nusing Microsoft.Xna.Framework.Input;这些是使用MonoGame 时的一些必要的包。\n之所以使用Microsoft.Xna.Framework框架是，因为MonoGame是Xna的开源实现，并且为了兼容Xna使用了与之相同的命名空间。\nGame1 类cspublic class Game1 : Game类Game1继承自Game类，Game提供了游戏框架全部的核心方法（加载&#x2F;卸载内容，刷新，绘制等）。通常情况下一个游戏只有一个Game类，所以此类的命名显得并不是那么重要。\n构造器cspublic Game1()\n&#123;\n    graphics = new GraphicsDeviceManager(this);\n    Content.RootDirectory = &quot;Content&quot;;\n&#125;在构造函数里我们通常会初始化一些起始变量。在这里我们为我们的游戏创建了一个新的GraphicsDeviceManager（图形设备管理器），并为其设置一个了资源文件夹。\n初始化方法csprotected override void Initialize()\n&#123;\n    // TODO: Add your initialization logic here\n\n    base.Initialize();\n&#125;初始化方法在构造函数后游戏循环（刷新与绘制）前进行调用，在这里可以加载任何服务和非图形资源。\nLoadContent方法csprotected override void LoadContent()\n&#123;\n    // Create a new SpriteBatch, which can be used to draw textures.\n    spriteBatch = new SpriteBatch(GraphicsDevice);\n\n    // TODO: use this.Content to load your game content here\n&#125;此方法Initialize方法后游戏循环之前调用，用于加载我们的游戏内容，只会在每次游戏启动后调用一次。\nUpdate方法csprotected override void Update(GameTime gameTime)\n&#123;\n    if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))\n        Exit();\n\n    // TODO: Add your update logic here\n\n    base.Update(gameTime);\n&#125;每秒调用多次，并用于刷新游戏中的状态（碰撞检查，输入收集，播放音频等）。\nDraw方法cs\nprotected override void Draw(GameTime gameTime)\n&#123;\n    graphics.GraphicsDevice.Clear(Color.CornflowerBlue);\n\n    // TODO: Add your drawing code here\n\n    base.Draw(gameTime);\n&#125;\n和Update相同也是每秒调用多次（用于绘制资源到窗口中）。\n","slug":"MonoGame官方文档(一)","date":"2020-06-09T16:00:00.000Z","categories_index":"","tags_index":"游戏开发,MonoGame","author_index":"天然卷打工战士"},{"id":"bf73a3194c54663868f6611faeab02f3","title":"webpack4学习笔记","content":"配套学习demo源码toypack\nwebpack 功能\nwebpack 支持 0 配置使用，但是功能支持偏弱；\nwebpack 的指责之一是将代码打包成 js 模块；\nwebpack 打包命令与执行流程：\n使用npx webpack执行打包命令；\n此时 webapck 会自动寻找node_modules/.bin下的webpack.cmd；\n如果当前目录下存在node.exe则执行node.exe与webpack.js；\n否则执行当前目录下的上级目录下的（也就是node_modules文件夹）webpack.js。\n\n\n打包的意义：可以对 js 代码进行模块化等问题的兼容和转换，同时也可以对发布的代码进行压缩。\n\n手动配置根目录下创建文件：webpack.config.js\n打包原理/机制运行npx webpack执行打包命令\n查看打包后的文件可以发现，该文件的主要结构为:\njs(\n  function(modules) {\n    var installedModules = {}; // 缓存依赖\n    function __webpack_require__ (moduleId) { // webpack实现的require\n      if(installedModules[moduleId]) {\n        return installedModules[moduleId].exports;\n      }\n      var module = installedModules[moduleId] = {\n        i: moduleId,\n        l: false, // 是否以经安装依赖\n        exports: {} // 导出的对象\n           };\n      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n      module.l = true;\n      return module.exports;\n    }\n    ... // 一些打包模式等代码\n    return __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n  }\n)({\n   \"./src/index.js\": (\n     function(module, exports, __webpack_require__) {\n       eval(\"let testMode = __webpack_require__(/*! ./testMode */ \\\"./src/testMode.js\\\");\\r\\n\\r\\nconst a = 1;\\r\\nconst b = 2;\\r\\n\\r\\nconst c = a + b;\\r\\n\\r\\nconsole.log(\\\"webpack first\\\");\\r\\nconsole.log(c);\\r\\nconsole.log(testMode);\\r\\n\\n\\n//# sourceURL=webpack:///./src/index.js?\") //\n     }\n   ),\n   \"./src/testMode.js\": (\n     function(module, exports) {\n       eval(\"\\r\\nmodule.exports = 'test mode'\\n\\n//# sourceURL=webpack:///./src/testMode.js?\");\n     }\n   )\n   ... // 其他依赖\n});通过该结构可以发现，webpack 是以一个立即执行函数注册全部的依赖，通过递归的方式将所有的依赖注册完成后，会将导出的内容依次的返回到上层调用。\n具体流程为：\n\n立即执行函数注册全部依赖；\n调用webpack_require()传入入口文件的 key(路径)，并返回其执行结果；\nwebpack_require函数根据 key 找到依赖调用其文件内容（文件内容通过函数内部的 eval 执行）并传入 module, module.exports, webpack_require(这个参数如果当前文件有依赖时才会传入)等参数；\n\nwebpack4.0流程示意\n\nhtml 服务器与插件html 服务器该插件是开始时常用插件，可以使 html 页面以服务器的形式发布，方便调试\n\n使用yarn add webpack-dev-server -D安装；\n在 webpack.config.js 中添加 devServer 对象进行配置；\nport：8080 //端口\nprogress： true //进度条\ncontentBase： ‘./dist’ //配置目录\n\n\n使用 npx webpack-dev-server 命令启动服务器\n\nhtml 插件该插件可以在每次打包和运行时服务器将 html 模板文件复制到输出目录下并自动引入打包后的文件，同时该插件还支持对 html 进行压缩处理，减小打包体积\n\n使用yarn add html-webpack-plugin -D安装插件；\n在 webpack.config.js 中引入该插件；\n在 plugins 中注册改插件并配置；\ntemplate： “./public/index.html” // html 打包模板\nfilename： “index.html” // 打包后的 html 名称,\nhash: true // 是否添加 hash 戳\nminify: {collapseWhitespace: true} // 体积压缩配置\n\n\n\npluginsplugins是一系列的webpack功能扩展的工具包，实现将一些webpack之外的功能集成到webpack中；plugins定义在plugins属性中；plugins一定是一个导出类；plugins的定义格式为\njs plugins: [\n  new HtmlWebpackPlugin({\n    // 插件的配置项\n    template: \"./public/index.html\",\n    filename: \"index.html\",\n  }),\n  new MiniCssExtractPlugin({\n    filename: 'index.css'\n  })\n],plugins的调用顺序不会被注册顺序影响\nloaderloader 的作用就是解析一些本事不支持的文件类型；loader 定义在 webpack.config.js 的 module.rules 属性中;loader 的定义格式为\njsmodule: {\n  rules: [\n    // 第一种对象方式定义，loader字段为注册loader，options为loader的配置对象\n    {\n      test: /\\.css$/,\n      use: [\n        {\n          loader: \"style-loader\",\n          options: {\n            insertAt: 'top'\n          }\n        },\n        \"css-loader\"\n      ]\n    },\n    // 第二种方式，直接在数组中添加loader的名称来注册loader\n    {\n      test: /\\.less$/,\n      use: [\"style-loader\", \"css-loader\", \"less-loader\"]\n    }\n  ];\n}loader的调用规则：当有多个loader时，从右向左执行，比如解析less文件需要先使用less-loader编译为css再使用css-loader转换成模块，最后用style-loader插入到html模板中\nloader的一些配置项\ninclude作用的文件夹\nexclude排除的文件夹\n\ncss的兼容优化部分css属性存在浏览器兼容问题，所以需要加上浏览器前缀来进行兼容，使用postcss-loader和autoprefixer插件可以实现自动对css属性添加前缀\njs module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', ,'css-loader', 'postcss-loader']\n      },\n    ]\n  }postcss-loader需要在css-loader之前进行处理，所以要添加在css-loader的后面，同时为了让postcss-loader知道使用哪个插件来进行添加前缀，需要在根目录下添加配置文件postcss.config.js\ncss的抽离和压缩css的抽离在使用style-loader时css样式会被插入到html文档的头部，这对页面的加载很不友好，所以需要提取出一个或多个的css文件以引用的方式会更好。\ncss的抽离使用mini-css-extract-plugin插件来实现，使用步骤为：\n\n在plugins中注册插件，并配置filename属性\n把style-loader替换为MiniCssExtractPlugin.loader\n\n这样在打包的时候就会看到css文件已经从html模板中抽离出来打包为了单独的文件。\n\n\n\n\n\n\n\n\n\n如果需要打包出多个css文件如css、less、sass等文件分别打包可以创建多个mini-css-extract-plugin插件并在对应的loader配置中替换即可。\ncss的压缩css代码在抽离后不会直接被压缩所有压缩css代码需要引入其他的插件optimize-css-assets-webpack-plugin\n安装好后在webpack.config.js中\njsconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');\nmodule.exports = {\n  optimization: {\n    minimizer: [new OptimizeCSSAssetsPlugin({})],\n  },\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: 'index.css',\n    }),\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader'],\n      },\n    ],\n  },\n};babel的使用babel是一个下一代 JavaScript 语法编译器，用于把高版本的语法（es6及以上）转换到低版本（es5）。\n在webpack中引入babel的方式很简单，分为几个部分：\n\n安装babel-loader并注册到webpack中；\n安装@babel/core是Babel的核心包,里面存放着转换的核心api；\n安装@babel/preset-env,多个plugins的集合，同时包含了es2015、es2016、es2017以及最新版本，是官方推荐的预设集合。\n\n配置在webpack.config.js中添加babel-loader\njsmodule: {\n  rules: [\n    { test: /\\.js$/, exclude: /node_modules/, loader: \"babel-loader\" }\n  ]\n}在根目录下新建.babelrc文件\n添加预设集合和一些特殊插件\njs{\n  \"presets\": [\"@babel/preset-env\"],\n  \"plugins\": [\n    \"@babel/plugin-proposal-class-properties\"\n  ]\n}js的优化@babel/plugin-transform-runtime和@babel/runtime当使用了一些es6的语法时，由于转换成es5需要加入一些帮助代码，这些代码会在使用的地方都加入一遍造成重复，使打出来的包体积变大，安装插件@babel/plugin-transform-runtime和@babel/runtime后可以把这些帮助代码全部抽离出来在后续使用的时候通过引入的形式导入到文件中，从而减小打包的体积。\n安装使用：\njsnpm install --save-dev @babel/plugin-transform-runtime\n\n// 或\n\nyarn add @babel/plugin-transform-runtime -D\n\n---------------------------------\n\nnpm install --save @babel/runtime\n\n// 或\n\nyarn add @babel/runtime@babel/plugin-transform-runtime为开发时依赖在打包时就将代码加入到包中，而@babel/runtime在运行时根据具体情况来判断如何使用加入的帮助代码。\n@babel/polyfillpolyfill是一个垫片程序，该程序通过es5模拟完整的es6+环境，因此可以安全的使用新的内置函数。\n安装使用：\njsyarn add @babel/polyfill\n\n--------------------\n\n// 在入口文件引入\n\nrequire(\"@babel/polyfill\");\n\n// 或\n\nimport \"@babel/polyfill\"；\n影响使用@babel/polyfill后会导致Promise，Set和Map这些内置的插件污染全局命名空间，有时会导致引入的库或被其他人引入时发生意外的bug，在v7以后官方提供了新的替代方案来代替使用polyfill。\npolyfill的升级方案@babel/polyfill不必再安装，转而需要依靠core-js和regenerator-runtime（详细原因请看作者的阐述），替代方案用法如下：\n安装两个新的包\njsyarn add core-js regenerator-runtime在.babelrc中配置\njs{\n  \"plugins\": [\n    [\n      \"@babel/plugin-transform-runtime\",\n      {\n        \"corejs\": false,\n        \"helpers\": true,\n        \"regenerator\": true,\n        \"useESModules\": false\n      }\n    ]\n  ]\n}然后在入口文件中导入\njsimport \"core-js/stable\"\nimport \"regenerator-runtime/runtime\"\n\n\n\n\n\n\n\n\n打包后包体积大约会增大400k\n全局变量的处理当引入jQuery这些依赖时，我们希望是在window上可以获取到全局的，这时可以使用一下几种方法来吧暴露到全局中。\n使用expose-loader安装loader\njsyarn add expose-loader使用\njs// 在入口文件中\nimport $ from 'expose?$!jquery'\n\n// 或\n\n// 在webpack.config.js文件中加入\n{\n  test: path.resolve('jquery'),\n  loader: 'expose-loader?$'\n}使用webpack插件这种方式是使用webpack插件在每个模块中都注入一个$\njs\n// 在webpack.config.js文件中引入webpack插件\nconst webpack = require(\"webpack\");\n\n// 在plugins选项中加入\nnew webpack.ProvidePlugin({\n  $: 'jquery'\n})\n通过cdn方式引入这种方式是通过cdn的方式在html模板中加入script标签引入，这和以前的引入方式没什么区别，只有一点需要注意，当通过cdn引入的时候是不需要在通过import $ from 'jquery'等方式引入的，因为在这时再引入的话会导致jquery打包到生产中造成重复和包体积增大。\n所以在使用cdn引入后如果一定要在通过模块的方式引入的话，可以在webpack配置中加上externals属性来进行忽略\njsexternals: {\n  jquery: '$'\n}图片打包webpack中使用图片的三种方式，分别是\n\n在js文件中使用\n使用css background(url)\n使用image标签\n\n在js文件中使用在js中使用图片时不能直接给Image对象设置路径字符串，这样的话会被识别为普通字符串而不是一个图片资源\njs// 错误的使用方式\nconst img = new Image();\nimg.src = './tree01.png';应该是通过import/require方式导入到文件中，在进行使用；通过import/require方式导入的文件会在内部生成一个新的图片并返回新图片的地址\n安装使用\n首先要安装file-loader来帮助实现上面的说的功能\njsyarn add file-loader -D在webpack.config.js中配置loader\njs// 在module选项中插入\n{\n  test: /\\.(png|jpg|gif|jpeg)$/, // 匹配以png、jpg、jpeg、gif结尾的资源\n  use: 'file-loader'\n},在js文件中导入资源\njsimport treeImg from './tree01.png';\n\nconsole.log(treeImg); // 是一个生成的新的以hash戳命名的图片 eg：c49d75b8b21e664625d3f7734a8cd8e9.png\n\nconst img = new Image();\n\nimg.src = treeImg;\n\ndocument.body.appendChild(img);这个时候运行npx webpack查看打包路径会发现图片已经可以打包到文件夹中。\n使用css background(url)同样的使用到了上面说的file-loader只不过是把引入图片的位置从js文件转移到了css文件中，通过css文件中使用background-image: url('./anim8.png');样式可以起到和导入一样的效果，webpack会把url()中的路径解析生成一个新的图片并输出到打包路径中。\ncssbody {\n  background-image: url('./anim8.png');\n  /* 相当于 */\n  /* background-image: url(require('./anim8.png')); */\n}使用image标签在html页面中直接使用image标签来进行打包的话需要额外使用到另一个loader：html-withimg-loader，使用该loader可以达到和上面一样的效果。\n安装使用\njsyarn add html-withimg-loader -D配置:html-withimg-loader需要搭配file-loader一起使用，在使用的时候需要把file-loader的esModule设置为flase，不然导出以后src会是{default: 图片地址}\njs{\n  test: /\\.html$/,\n  use: 'html-withimg-loader'\n},\n{\n  test: /\\.(png|jpg|gif|jpeg)$/,\n  use: { loader: \"file-loader\", options: { esModule: false } }\n},优化一下项目打包以后我们不想所有的图片都会发送一个http请求，而是想小图片直接以base64的形式打包到代码中，而大一些的图片才发送请求；此时我们只需要把上面的file-loader换成url-loader即可。\njs// 安装\nyarn add url-loader -D\n\n// 配置\n\n// {\n//   test: /\\.(png|jpg|gif|jpeg)$/,\n//   use: { loader: \"file-loader\", options: { esModule: false } }\n// }\n// 把上面的配置替换为下面的配置\n\n{\n  test: /\\.(png|jpg|gif|jpeg)$/,\n  use: { \n    loader: \"url-loader\", \n    options: \n      { \n        esModule: false, \n        limit: 200*1024  // 按字节算，这里是200*1024=200k\n      } \n    }\n}\n\n\n\n\n\n\n\n\n如果同样有搭配html-withimg-loader的需求不要忘记配置一下esModule: false\n打包文件的分类打包后的文件我们希望像开发时一样可以按照css、js、img等资源类型进行分类，所以我们需要在配置上简单配置一下。\njs输出路径直接在output.filename选项中修改即可\njsoutput: {\n  // 输出配置\n  filename: \"js/bundle.js\", // 输出的文件名\n  path: path.resolve(__dirname, \"dist\"), // 输出的目录\n},css输出路径在抽离css的插件处配置outputPath即可\njsplugins: [\n  new MiniCssExtractPlugin({\n    filename: \"css/index.css\",\n  }),\n]img输出路径在url-loader的选项中配置outputPath即可\njsmodule: [\n  {\n    test: /\\.(png|jpg|gif|jpeg)$/,\n    use: {\n      loader: \"url-loader\",\n      options: { esModule: false, limit: 1, outputPath: \"img/\" },\n    },\n  },\n]关于资源访问时的前缀路径项目发布后资源如果出于cdn或服务器上的话，我们会希望在图片、css等资源访问时加上域名等前缀，此时我们只需要在webpack.config.js中配置output.publicPath属性即可\njsoutput: {\n  // 输出配置\n  filename: \"js/bundle.js\", // 输出的文件名\n  path: path.resolve(__dirname, \"dist\"), // 输出的目录\n  publicPath: 'http://www.example.com'\n},此时所有的资源都会自动加上这个前缀，但是需要注意的是此时图片的路径上会少一个/所以添加了publicPath以后需要在img的输出路径上多加以个/\njsmodule: [\n  {\n    test: /\\.(png|jpg|gif|jpeg)$/,\n    use: {\n      loader: \"url-loader\",\n      options: { esModule: false, limit: 1, outputPath: \"/img/\" },// 需要多加一个/\n    },\n  },\n]另外如果只想在图片或css等某一资源上添加前缀的话在对应的loader或插件（具体取决于使用什么做的输出文件操作）上设置publicPath就可以了\njs// 以图片为例\nmodule: [\n  {\n    test: /\\.(png|jpg|gif|jpeg)$/,\n    use: {\n      loader: \"url-loader\",\n      options: { \n      esModule: false, \n      limit: 1, \n      outputPath: \"/img/\", // 需要多加一个/\n      publicPath:'http://www.example.com' },\n    },\n  },\n]多页面打包多页面程序，顾名思义就是拥有多个入口页面并且每个页面有独立的入口文件，这是与前面的单页面模式最大的不同点。\n准备要打包多页面当然需要准的是多个入口文件\n首先准备一个空的node项目，然后在项目中添加\n\n在src文件夹下创建home.js、other.js两个入口文件， 并在里面随便写点代码（比如console）\n在public文件夹下创建index.html模板\n安装webpack、webpack-cli、html-webpack-plugin依赖\n添加webpack配置文件\n\n配置下面我们来开始进行配置文件的编写\n第一步\n第一步肯定是编写入口文件\njsmodule.exports = {\n  mode: \"development\",\n  entry: {\n    home: \"./src/index.js\",\n    other: \"./src/other.js\",\n  },\n}这里入口文件的配置与单页面配置不同的是要以对象的形式进行配置，分别配置为对应的入口文件即可，其中key值会作为后面打包文件的文件名\n第二步\n第二步添加一下打包文件的输出配置\njsmodule.exports = {\n  mode: \"development\",\n  entry: {\n    index: \"./src/index.js\",\n    other: \"./src/other.js\",\n  },\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n}然后运行一下npx webpack，看看效果，不出意外的会产生报错\njsERROR in chunk other [entry]\nbundle.js\nConflict: Multiple chunks emit assets to the same filename bundle.js (chunks index and other)这里报错信息告诉我们多个模块将发射为同名的文件(home和other)，这证明我们的filename: \"bundle.js\"配置的有错误，此时打开我们输出的bundle.js文件会发现只有index.js打包成功了，这显然不是我们想要的，为了解决这个问题，需要把这里修改成根据我们打包的文件自动的生成文件名，这样就不怕文件名冲突了\njsconst path = require(\"path\");\nmodule.exports = {\n  mode: \"development\",\n  entry: {\n    index: \"./src/index.js\",\n    other: \"./src/other.js\",\n  },\n  output: {\n-   filename: \"bundle.js\",\n+   filename: \"[name].js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n}这里可以看到我们从bundle.js改成了[name].js，再次运行npx webpack，可以看到将两个文件都打包成功并成功以各自的名称进行命名\n第三步\n多页面顾名思义，肯定也是需要多个html页面来作为载体，所以这里继续使用html-webpack-plugi这个插件进行html和打包文件的整合和输出， 先看配置\njsconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n  mode: \"development\",\n  entry: {\n    index: \"./src/index.js\",\n    other: \"./src/other.js\",\n  },\n  output: {\n    filename: \"[name].js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \"index.html\",\n      template: \"./public/index.html\",\n    }),\n    new HtmlWebpackPlugin({\n      filename: \"other.html\",\n      template: \"./public/index.html\",\n    }),\n  ],\n};由于是多页面的打包，所以我们的需求肯定是输出多个html页面，但是html-webpack-plugin的配置中filename并不能写成数组、也不能像output属性写成[name].html，所以我们就通过再new一个插件的实例并分别配置页面输出来解决这个问题。\n现在运行一下命令npx webpack，成功打包后，任意打开一个打包后的html页面，我们会发现他们把两个入口文件都引入了\nhtml&lt;!-- index.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  \n&lt;script src=\"home.js\"&gt;&lt;/script&gt;&lt;script src=\"other.js\"&gt;&lt;/script&gt;&lt;/body&gt;\n&lt;/html&gt;虽然说打包成功了，但是都引入了全部的入口文件那直接打包到一个文件中岂不美哉，所以我们还要改一下配置\njsconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nmodule.exports = {\n  mode: \"development\",\n  entry: {\n    index: \"./src/index.js\",\n    other: \"./src/other.js\",\n  },\n  output: {\n    filename: \"[name].js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: \"index.html\",\n      template: \"./public/index.html\",\n      chunks: [\"home\"],\n    }),\n    new HtmlWebpackPlugin({\n      filename: \"other.html\",\n      template: \"./public/index.html\",\n      chunks: [\"other\"],\n    }),\n  ],\n};这次我们给每一个页面的配置添加了一个chunks配置项，这是告诉插件我们当前这个html想要引入那些文件，里面填写我们想要引入的文件名就可以了。\n再次运行npx webpack，这次可以看到在dist文件夹下，正确的打包了两个入口文件index.js和other.js以及两个入口htmlindex.html和other.html并且两个文件中都正确的引入了对应的入口文件。\n到此为止一个多页面应用的配置和打包流程就算结束了，可以拿着打好的包丢到服务器里去浪里个浪啦~\nsouce-mapsource-map的出现是为了解决当我们的程序进行了打包压缩后由于代码被压缩在一行或几行的情况下无法调试错误的痛点。\nsource-map是一个信息文件，里面存储的是转换后与转换前的代码的对应关系，当调试工具支持source-map功能时便可以根据source-map中的信息将报错正常的显示出来。\n在webpack中是通过devtool选项来进行source-map的生成以下列举几个选项：\n\n\n\n选项\n生产环境\n输出\n\n\n\neval\n不推荐\n生成后的代码（如经过babel转换过后的）\n\n\nsource-map\n可行\n输出源代码和映射文件，可有准确的输出报错行和列\n\n\neval-source-map\n不推荐\n输出源代码但是不产生映射文件，是通过在打包文件内通过eval方式输出报错信息\n\n\ncheap-source-map\n不推荐\n低开销的source-map，不能定位到列\n\n\ncheap-eval-source-map\n不推荐\n低开销的eval-source-map，不能定位到列\n\n\ncheap-module-source-map\n不推荐\n输出源代码和映射文件，仅输出行信息\n\n\ncheap-module-eval-source-map\n不推荐\n输出源代码但没有映射文件，仅输出行信息\n\n\nhidden-source-map\n可行\n与source-map相同，但是不会添加引用注释，不向浏览器暴露source map\n\n\nnosources-source-map\n可行\n生成的source map不会包含源码\n\n\n其他方式来自官网上的其他配置方式\n\n\n\n\n\n\n\n\n\n你可以直接使用 SourceMapDevToolPlug / EvalSourceMapDevToolPlugin 来替代使用 devtool 选项，因为它有更多的选项。切勿同时使用 devtool 选项和 SourceMapDevToolPlugin/EvalSourceMapDevToolPlugin 插件。devtool 选项在内部添加过这些插件，所以你最终将应用两次插件。\nwatchwatch可以在运行了webpack打包命令后，持续的监听文件变化来重新编译打包。\n配置jsmodule.exports = {\n  ...\n  watch: true,\n  watchOptions: {\n    aggregateTimeout: 500,\n    poll: 1000,\n    ignored: /node_modules/,\n  }\n}\naggregateTimeout防抖时间，超过指定时间未修改才进行打包\npoll毫秒单位的轮询时间间隔\nignored排除一些大的文件夹\n\n其他插件clean-webpack-plugin这个插件的作用是清空output.path文件夹，所以可以在打包时利用该插件先清空掉原有的dist文件夹，然后生成新的打包文件，避免出现打包文件叠加或者缓存问题。\n安装和使用运行命令\njsyarn add clean-webpack-plugin -D在配置文件中配置\njsconst { CleanWebpackPlugin } = require(\"clean-webpack-plugin\");\nmodule.exports = {\n  ...\n  plugins: [\n    new CleanWebpackPlugin()\n  ]\n}copy-webpack-plugin这个插件的作用是将一个指定目录copy到output.path文件夹，利用这个插件我们可以在打包时把一些静态文件（如图片、音频、视频等）自动的拷贝到打包目录下。\n安装和使用运行命令\njsyarn add copy-webpack-plugin -D在配置文件中配置\njsconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nmodule.exports = {\n  ...\n  plugins: [\n    new CopyWebpackPlugin([\n      {\n        from: './static',\n        to: './static'\n      }\n    ])\n  ]\n}webpack跨域devServer代理dev-server 使用了非常强大的 http-proxy-middleware 包来将请求代理到单独的后端服务器上。\n使用方式jsmodule.exports = {\n  ...\n  devServer: {\n    proxy: {\n      \"/api\": {\n        target: \"http://192.168.1.1:8088\",\n        pathRewrite: {\n          \"^/api\": ''\n        }\n      }\n    }\n  }\n}这样就可以实现跨域访问后端api了。\n前端模拟数据同样是基于devServer选项来配置，不过这次用的是一个钩子——before\njsmodule.exports = {\n  ...\n  devServer: {\n    before(app){\n      app.get('/api/user', function(req, res) {\n        res.json({ custom: 'response' });\n      });\n    }\n  }\n}这里devServer会自动传入一个app参数，这个参数就是express的实例对象，多以我们就可以在这个方法内像写后台一样写一些简单的后端代码来模拟数据。\n前后端代码写在一起（此方法只适合nodejs服务器）express版本安装中间件webpack-dev-middleware\njs// server.js\n\nconst express = require(\"express\");\nconst webpack = require(\"webpack\");\nconst webpackDev = require(\"webpack-dev-middleware\");\nconst webpackConfig = require(\"./webpack.config.js\");\n\nconst app = express();\n\nconst complier = webpack(webpackConfig);\n\napp.use(webpackDev(complier));\n\napp.get('/user', (req, res) =&gt; {\n  // do something\n})\n\napp.listen(8080);koa2版本安装中间件koa-webpack\njs// server.js\n\nconst Koa = require('koa');\nconst webpack = require('webpack');\nconst config = require('./webpack.config.js');\nconst koaWebpack = require('koa-webpack');\n\nconst app = new Koa();\nconst compiler = webpack(config);\nconst middleware = await koaWebpack({ compiler });\n \napp.use(middleware);\n\napp.listen(3000);这样前后端就是运行在同一个服务器的状态了，所以也就不会发生跨域问题了。\nresolveresolve选项能设置模块如何被解析。\nmodules告诉 webpack 解析模块时应该搜索的目录。\n使用绝对路径，将只在给定目录中搜索。\njsmodule.exports = {\n  ...\n  resolve: {\n    modules: [\"node_modules\"]\n  }\n}只在node_modules目录中搜索\nalias给资源配置别名，可以是某一目录下或某一文件\njsconst path = require(\"path\");\nmodule.exports = {\n  ...\n  resolve: {\n    modules: [\"node_modules\"],\n    alias: {\n      '@': path.resolve(__dirname, 'src'),// 设置src前缀为@\n    }\n  }\n}\n\n// 文件中使用时\nimport Test from '@/Test.js'\nmainFields当从 npm 包中导入模块时，此选项将决定在 package.json 中使用哪个字段导入模块。\njsmodule.exports = {\n  ...\n  resolve: {\n    modules: [\"node_modules\"],\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n    },\n    mainFields: [\"style\", \"main\"] // 首先使用style字段导入模块，找不到再使用main字段导入模块\n  }\n}\n\n// 文件中引用\nimport 'bootstrap';定义环境变量使用webpack的内置插件DefinePlugin\njsmodule.exports = {\n  ...\n  plugins: [\n    new Webpack.DefinePlugin({\n      MODE: JSON.stringify(\"dev\")\n    })\n  ]\n}\n\n// 文件中使用 index.js\n\nif (MODE === \"dev\") {\n  console.log(\"dev\");\n} else {\n  console.log(\"prod\");\n}\n\n\n\n\n\n\n\n\n定义的值会去掉引号后传入到环境变量中，所以如果传入字符串需要用JSON.stringify转换一下，如果是boolean和number等类型则不需要转换直接写作FLAG:'true'、NUM:'1'就可以了；如果是表达式也可以和number一样直接写，这样会直接传入表达式的计算结果如：EXPRESSION:'1+1'的打印值为2\n区分环境在开发中我们往往开发环境和生产环境的配置并不相同，为了不在每次打包时都去更改配置文件（费力且容易出错）我们可以使用webpack-merge模块来实现自动的注入不同环境的配置。\n安装使用安装模块\njsyarn add webpack-merge -D使用\nmerge允许我们把多个配置文件合并起来使用，所以我们可以在根目录下创建webpack.dev.js和webpack.prod.js来分别配置不同环境的配置，下面以dev环境做个例子\njsconst { smart } =  require(\"webpack-merge\")\nconst base = reuqire(\"./webpack.base.js\") // 引入公用配置\n\nmodule.exports = smart(base, {\n  mode: 'development',\n  // 其他配置\n  ...\n})在启动时我们只需要指定不同的配置文件即可实现不同环境的切换\njs// 生产环境\nnpm run dev -- --config webpack.dev.js\n\n// 开发环境\nnpm run build -- --config webpack.prod.js一些优化点noParse忽略无依赖大型库noParse的作用是防止 webpack 解析那些任何与给定正则表达式相匹配的文件。忽略的文件中不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。\n应用场景\n在引入库时，明确的知道该库不存在其他依赖且该库体积较大时，比如引入JQuery时\njsmodule.exports = smart(base, {\n  ...\n  module: {\n    noParse: /jquery|lodash/,  // 正则的方式\n    noParse: function(content) { // webpack 3.0.0 写法\n      return /jquery|lodash/.test(content);\n    },\n  }\n})IgnorePlugin忽略依赖包的指定文件IgnorePlugin是webpack的内置插件，作用是忽略掉指定依赖包下的指定文件，如moment的本地化文件。\n应用场景\nIgnorePlugin接受两个参数，分别是\n\n匹配(test)资源请求路径的正则表达式；\n匹配(test)资源上下文（目录）的正则表达式（可选）。\n\njsconst webpack = require('webpack');\nmodule.exports = smart(base, {\n  ...\n  plugins: [\n    new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/)\n  ]\n})DllPlugin实现输出dll库DllPlugin允许webpack将bundles文件进行拆分，来提升构建速度\n可以把不会变动的大型库通过dll的方式打包出去，如React、Vue等依赖，然后在构建项目时就会先去dll清单中寻找相关依赖，如果找到了就不会重复打包，找不到时再进行打包操作。\n使用步骤\n\n在根目录下创建一个专门用来打包dll的配置文件，如webapck.dll.test.js；\n在dll配置文件中使用DllPlugin来配置打包信息；\n使用命令行传参数的方式运行dll的配置文件，单独打包；\n在html模板和项目主webpack配置中引入dll；\n\nout.library\nout.library是将模块输出为一个可以被直接使用的包，也就是会在webpack打包后将模块赋值给一个变量，变量名即为library的值，默认使用var方式导出\njs// out.library = 'test_dll' 时导出的模块\n\nvar test_dll =\n(function(modules) { // webpackBootstrap\n  ...\n  return __webpack_require__(__webpack_require__.s = 0);\n})({\n  // 依赖模块\n})DllPlugin\nwebpack的内置插件，可以单独写在一个配置文件里使用。\n\npath：manifest json 文件的绝对路径\nname：暴露出的 DLL 的函数名要与 out.library相同\n\nDllReferencePlugin\nwebpack的内置插件，应该写在项目打包时所使用的配置文件中\n\nmanifest：DllPlugin导出的manifest文件的绝对路径\n\n配置示例\njs// webapck.dll.test.js\n\nconst path = require(\"path\");\nconst webpack = require(\"webpack\");\n\nmodule.exports = {\n  mode: 'development',\n  entry: {\n        test: ['./src/test.js'],\n    },\n    output: {\n        path: path.join(__dirname, \"dist\"),\n        filename: \"[name].dll.js\",\n        library: \"[name]_dll\"\n    },\n    plugins: [\n        new webpack.DllPlugin({\n            path: path.join(__dirname, \"dist\", \"[name]-manifest.json\"),\n            name: \"[name]_dll\"\n        })\n    ]\n};\n\n// webpack.config.js\n\nconst path = require(\"path\");\nconst webapck = require(\"webpack\");\nmodule.exports = {\n  mode: \"development\",\n  entry: \"./src/index.js\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n  plugins: [\n    ...\n    new webapck.DllReferencePlugin({\n      manifest: path.resolve(__dirname, 'dist', 'test-manifest.json')\n    })\n  ],\n};\n多线程打包HappypackHappypack一个三方插件，用来开启多线程进行打包\n使用方式\n修改module.rules中需要多线程打包的文件，把loader修改为happypack的loader并通过?id=的方式设置id,创建一个Happypack插件的实例，并配置id和loader（把原来的loader配置复制过来就可以了）\n首先安装插件\njsyarn add happypack -D在配置中修改配置\njs// webpack.config.js\nconst path = require(\"path\");\nconst Happypack = require(\"happypack\");\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['Happypack/loader?id=js'],\n      },\n    ],\n  },\n  plugins: [\n    ...\n    new Happypack({\n      id: 'js',\n      use: [\n        'babel-loader'\n      ]\n    })\n  ],\n};happypack参数\n\nid: String 用唯一的标识符 id 来代表当前的 Happypack 是用来处理一类特定的文件.\nloaders: Array 用法和 webpack Loader 配置中一样.\nthreads: Number 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数。\nverbose: Boolean 是否允许 HappyPack 输出日志，默认是 true。\nthreadPool: HappyThreadPool 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多。\nverboseWhenProfiling: Boolean 开启webpack –profile ,仍然希望HappyPack产生输出。\ndebug: Boolean 启用debug 用于故障排查。默认 false。\n\nwebpack自带的优化策略tree-shakingtree-shaking策略会在生产环境下裁剪掉当前代码中多余的引入，如导出库中导出多个函数但是我们只用到了一个，在打包后webpack会自动的裁减掉多余的函数来减小包的体积。\ntree-shaking只会对生产环境且使用import方式导入的代码生效，对require语法不生效。\nscope-hostingscope-hosting策略会在生产环境下对当前代码进行分析并进行优化合并\njslet a = 1;\nlet b = 2;\nlet d = 3;\nlet d = a + b + c;\n\nconsole.log(d);\n\n// scope-hosting后会优化掉前面a,b,c，d的声明，直接打印计算结果\nconsole.log(6)多页面打包公共代码抽离打包多页面时，我们会想着将多出引用的文件进行抽离，当后续文件进行访问时可以快速的使用缓存来提升效率，那么就可以使用optimization.splitChunks来进行配置。\n\n\n\n\n\n\n\n\n\n在webpack4中CommonsChunkPlugin插件被移除，代替方案是使用optimization.splitChunks来进行配置。\njsconst path = require(\"path\");\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n    index: \"./src/index.js\",\n    other: \"./src/other.js\",\n  },\n  optimization: {\n    splitChunks: {\n      cacheGroups: {\n        common: {\n          // 公用部分抽离\n          minSize: 0, \n          minChunks: 2, \n          chunks: \"initial\",\n        },\n        vendor: {\n          // 第三方库抽离\n          test: /node_modules/,\n          priority: 1, \n          minSize: 0, \n          minChunks: 2, \n          chunks: \"initial\", \n        },\n      },\n    },\n  },\n  output: {\n    filename: \"[name].js\",\n    path: path.resolve(__dirname, \"dist\"),\n  },\n  ...\n};配置项\n\ncacheGroups缓存组\ntest 匹配路径的正则表达式\npriority 执行权重，越大越先执行\n\n\nchunks表示哪些代码需要优化，有三个可选值：initial(初始块)、async(按需加载块)、all(全部块)，默认为async\nminSize表示在压缩前的最小模块大小，默认为30000\nminChunks表示引用多少次才进行优化\nname拆分出来块的名字，默认由块名和hash值自动生成\n\n懒加载webpack的懒加载方式，使用es6草案中的import函数即可。\n热加载热加载能让我们在修改代码后由webpack自动的把项目重启并运行，省去了人工的繁琐操作。\njsconst webapck = require(\"webpack\");\nmodule.exports = {\n  ...\n  devServer: {\n    hot: true // 开启热更新\n  },\n  plugins: [\n    new webapck.HotModuleReplacementPlugin(), // 开启热更新\n    new webapck.NamedModulesPlugin() // 打印更新的文件\n  ]\n  ...\n}\n配置好以后，现在更改文件后保存会发现webpack重新编译了代码，并且页面会强制刷新。\nHotModuleReplacementPlugin热更新替换插件不要使用在生产环境\n属性\n\nmultiStep (boolean)：设置为 true 时，插件会分成两步构建文件。首先编译热加载 chunks，之后再编译剩余的通常的资源。\nfullBuildTimeout (number)：当 multiStep 启用时，表示两步构建之间的延时。\nrequestTimeout (number)：下载 manifest 的延时（webpack 3.0.0 后的版本支持）。\n\n\n\n\n\n\n\n\n\n\n这些选项属于实验性内容，因此以后可能会被弃用。就如同上文所说的那样，这些选项通常情况下都是没有必要设置的，仅仅是设置一下 new webpack.HotModuleReplacementPlugin() 在大部分情况下就足够了。\nNamedModulesPlugin当开启 HMR 的时候使用该插件会显示模块的相对路径，建议用于开发环境。\ntapableTapable是一个用于事件发布订阅执行的插件架构\n具体内容需要查阅文档Sync簇主要方法：\n\ntap 注册钩子\ncall 按顺序同步执行钩子\n\n\nSyncHook最基本的同步的钩子事件流\n使用示例\njsconst { SyncHook } = require(\"tapable\");\n\nclass Lesson {\n  constructor() {\n    this.hooks = {\n      arch: new SyncHook([\"name\"]),\n    };\n  }\n\n  tap() {\n    this.hooks.arch.tap(\"vue\", (name) =&gt; {\n      console.log(\"vue :&gt;&gt; \", name);\n    });\n    this.hooks.arch.tap(\"node\", (name) =&gt; {\n      console.log(\"node :&gt;&gt; \", name);\n    });\n  }\n\n  start() {\n    this.hooks.arch.call(\"yut\");\n  }\n}\n\nconst lesson = new Lesson();\n\nlesson.tap();\n\nlesson.start();\n\n// 输出:\n// vue :&gt;&gt;  yut\n// node :&gt;&gt;  yut模拟实现\njsclass SyncHook {\n  constructor(args) {\n    this.tasks = [];\n  }\n\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n\n  call(...args) {\n    this.tasks.forEach((task) =&gt; task(...args));\n  }\n}\n\nconst hook = new SyncHook([\"name\"]);\n\nhook.tap(\"node\", (name) =&gt; {\n  console.log(\"node :&gt;&gt; \", name);\n});\nhook.tap(\"vue\", (name) =&gt; {\n  console.log(\"vue :&gt;&gt; \", name);\n});\n\nhook.call(\"yuht\");SyncBailHook带有熔断机制的同步钩子事件流，当其中一个钩子执行返回非undefined时，则中断后续钩子的执行\n使用示例\njsconst { SyncBailHook } = require(\"tapable\");\n\nclass Lesson {\n  constructor() {\n    this.hooks = {\n      arch: new SyncBailHook([\"name\"]),\n    };\n  }\n\n  tap() {\n    this.hooks.arch.tap(\"vue\", (name) =&gt; {\n      console.log(\"vue :&gt;&gt; \", name);\n      return \"stop\"\n    });\n    this.hooks.arch.tap(\"node\", (name) =&gt; {\n      console.log(\"node :&gt;&gt; \", name);\n    });\n  }\n\n  start() {\n    this.hooks.arch.call(\"yut\");\n  }\n}\n\nconst lesson = new Lesson();\n\nlesson.tap();\n\nlesson.start();模拟实现\njsclass SyncBailHook {\n  constructor(args) {\n    this.tasks = [];\n  }\n\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n\n  call(...args) {\n    let ret, index = 0, len = this.tasks.length\n    do {\n      ret = this.tasks[index++](...args);\n    } while (ret === undefined &amp;&amp; index &lt; len);\n  }\n}\n\nconst hook = new SyncBailHook([\"name\"]);\n\nhook.tap(\"node\", (name) =&gt; {\n  console.log(\"node :&gt;&gt; \", name);\n  return \"stop\"\n});\nhook.tap(\"vue\", (name) =&gt; {\n  console.log(\"vue :&gt;&gt; \", name);\n});\n\nhook.call(\"yuht\");\n\n// 输出:\n// node :&gt;&gt;  yutSyncWaterfallHook瀑布流模式的同步钩子事件流，可以传递参数到下一个钩子中，调用call是传入的参数不会传入到后续钩子中\n使用示例\njsconst { SyncWaterfallHook } = require(\"tapable\");\n\nclass Lesson {\n  constructor() {\n    this.hooks = {\n      arch: new SyncWaterfallHook([\"name\"]),\n    };\n  }\n\n  tap() {\n    this.hooks.arch.tap(\"vue\", (name) =&gt; {\n      console.log(\"vue :&gt;&gt; \", name);\n      return \"params\"\n    });\n    this.hooks.arch.tap(\"node\", (data) =&gt; {\n      console.log(\"node :&gt;&gt; \", data);\n    });\n  }\n\n  start() {\n    this.hooks.arch.call(\"yut\");\n  }\n}\n\nconst lesson = new Lesson();\n\nlesson.tap();\n\nlesson.start();\n\n// 输出：\n// node :&gt;&gt;  yuht\n// vue :&gt;&gt;  params模拟实现\njsclass SyncWaterfallHook {\n  constructor(args) {\n    this.tasks = [];\n  }\n\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n\n  call(...args) {\n    const [first, ...other] = this.tasks;\n    let ret;\n    ret = first(...args);\n    other.reduce((a, b) =&gt; {\n      return b(a);\n    }, ret);\n  }\n}\n\nconst hook = new SyncWaterfallHook([\"name\"]);\n\nhook.tap(\"node\", (name) =&gt; {\n  console.log(\"node :&gt;&gt; \", name);\n  return \"params\";\n});\nhook.tap(\"vue\", (data) =&gt; {\n  console.log(\"vue :&gt;&gt; \", data);\n});\n\nhook.call(\"yuht\");SyncLoopHook能够实现重复调用某一函数的同步钩子事件流\n使用示例\njsconst { SyncLoopHook } = require(\"tapable\");\n\nclass Lesson {\n  constructor() {\n    this.index = 0;\n    this.hooks = {\n      arch: new SyncLoopHook([\"name\"]),\n    };\n  }\n\n  tap() {\n    this.hooks.arch.tap(\"vue\", (name) =&gt; {\n      console.log(\"vue :&gt;&gt; \", name);\n      return ++this.index === 3 ? undefined : \"loop\"\n    });\n    this.hooks.arch.tap(\"node\", (data) =&gt; {\n      console.log(\"node :&gt;&gt; \", data);\n    });\n  }\n\n  start() {\n    this.hooks.arch.call(\"yut\");\n  }\n}\n\nconst lesson = new Lesson();\n\nlesson.tap();\n\nlesson.start();\n\n// 输出：\n// node :&gt;&gt;  yuht\n// node :&gt;&gt;  yuht\n// node :&gt;&gt;  yuht\n// vue :&gt;&gt;  yuht模拟实现\njsclass SyncLoopHook {\n  constructor(args) {\n    this.tasks = [];\n  }\n\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n\n  call(...args) {\n    this.tasks.forEach((task) =&gt; {\n      let ret;\n      do {\n        ret = task(...args);\n      } while (ret != undefined);\n    });\n  }\n}\n\nconst hook = new SyncLoopHook([\"name\"]);\nlet loopNums = 0;\nhook.tap(\"node\", (name) =&gt; {\n  console.log(\"node :&gt;&gt; \", name);\n  return ++loopNums === 3 ? undefined : \"loop\";\n});\nhook.tap(\"vue\", (data) =&gt; {\n  console.log(\"vue :&gt;&gt; \", data);\n});\n\nhook.call(\"yuht\");Async簇AsyncParralleHook并行异步钩子，有回调函数模式和promise模式两种调用模式。\n回调函数模式在注册钩子时使用tapAsync，此时会多传入一个回到函数，当钩子执行完毕时需要调用该回调。在启动时调用callAsync，此时需要传入一个回调函数，此回调函数在所有钩子执行完毕后被调用。\npromise模式在注册钩子是使用tapPromise，返回一个promise对象。在启动时调用promise，返回一个promise对象，当所有钩子执行成功后该promise进入完成状态。\nAsyncParallelBailHook带有熔断的异步钩子，当任意一个钩子返回值非undefined的值时就不会调用最终的回调钩子。\n","slug":"webpack/webpack4学习笔记","date":"2020-04-29T16:00:00.000Z","categories_index":"webpack","tags_index":"webpack","author_index":"天然卷打工战士"},{"id":"762d57d23f302a5afc8450b6572a5c7f","title":"文档导航","content":"前端开发\nJavaScript&#x2F;node.js\n\n现代 JavaScript 教程\nnodejs中文网\nkoa2官方文档\neggjs官方文档\nw3school\n阮一峰博客\nES6 入门教程\nMDN\nloadash文档\n\n\n前端工程化\n\nBabel官网\nwebpack官方文档\nnpm官方网站\nyarn中文网\n\n\nvue.js\n\nvue官方文档\nvue-cli官方文档\nvuex官方文档\nvue-router官方文档\nvue官方社区\nant-design-vue官方文档\naxios看云文档\n\n\n微信小程序\n\n小程序官方文档\n\n\n其他前端文档\n\necharts文档\nmomentjs文档\n\n\n\n游戏开发\nunity3d文档\n\n社区论坛\nV2EX\n掘金\n逼乎\n独立精神\n\n图片素材\n图片素材\n\n","slug":"文档导航","date":"2020-03-16T09:03:15.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"80fa170694c2738a195b06ce828cfe4a","title":"LeetCode：整数反转","content":"LeetCode第7号问题：整数反转\n题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例：\njava输入: 123\n输出: 321\n\n输入: -123\n输出: -321\n\n输入: 120\n输出: 21注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n解法（java）每次弹出数字’x’最后一位，并压入到’res’的后面，全部压入后，’x’与’res’即完全相反；\n在不使用数据结构的情况下可以借助数学方法来实现“弹出&#x2F;压入”的操作：\njava// 弹出\npop = x % 10\nx /= 10\n\n// 压入\ntemp = y * 10 + pop\ny = temp \n\n\n\n\n\n\n\n\n此方式有溢出风险，使用时应注意每次反转后是否溢出。\n反转后数字的溢出情况可以使用Integer.MAX_VALUE和Integer.MIN_VALUE来实现\n参考代码：\njavaclass Solution &#123;\n    public int reverse(int x) &#123;\n        long res = 0;\n        while(x != 0) &#123;\n            res = res * 10 + x % 10;\n            x /= 10;\n        &#125;\n        return res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE ? 0 : (int)res;\n    &#125;\n&#125;","slug":"LeetCode：整数反转","date":"2020-02-29T13:39:30.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"62f4259c1d3df5765faf228a85e43d10","title":"js实现选择排序","content":"\n\n\n\n\n\n\n\n\n选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。\n算法思路\n使用线性查找当前待排序数据，找到最小值\n把最小值移动到数组最左边\n重复1、2步，直到数组全部完成排序\n\n代码实现方式一：\n使用递归实现，一次循环比较好读，容易理解，但效率较循环低一些\njsconst unsort = [6, 1, 7, 8, 9, 3, 5, 4, 2]\n\nconst selectedSort = (arr, index = 0) =&gt; &#123;\t\n    let min = arr[index]\n\n    const len = arr.length\n\n    for (let i = index; i &lt; len; i++) &#123;\n        const temp = arr[i]\n        if (temp &lt; min) &#123;\n            arr[index] = temp\n            arr[i] = min\n            min = temp\n        &#125;\n    &#125;\n\n    if (index === len - 1) &#123;\n        return arr\n    &#125;\n    return selectedSort(arr, index + 1)\n&#125;\n\nconst sorted = selectedSort(unsort)\n\nconsole.log(sorted)\n\n// console: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n方式二：\n使用循环实现，两次循环，比较不好读，逻辑容易出现纰漏，效率比递归要高\njsconst unsort = [6, 1, 7, 8, 9, 3, 5, 4, 2]\n\nconst selectedSort = (arr) =&gt; &#123;\n    const len = arr.length\n    let min\n    let temp\n    for (let i = 0; i &lt; len; i++) &#123;\n        min = arr[i]\n        temp\n        for (let j = i + 1; j &lt; len; j++) &#123;\n            if (arr[j] &lt; min) &#123;\n                temp = min\n                min = arr[j]\n                arr[j] = temp\n                arr[i] = min\n            &#125;\n        &#125;\n    &#125;\n    return arr\n&#125;\n\nconst sorted = selectedSort(unsort)\n\nconsole.log(sorted)\n\n// console: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n理解选择排序使用线性方式来查找最小值，所以每次循环都会比较n-m(m为循环次数)个数，直到最后一轮只比较一个数字，因此复杂度是（n - 1）+ (n - 2) + (n - 3) … + 1 ≈ n^2^ &#x2F; 2, 忽略非重要项后为O(n^2^)\n","slug":"js实现选择排序","date":"2020-01-04T14:00:07.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"90a976545b5488dd75ff7364ad12073f","title":"使用VSCode编辑器debug调试Vue代码","content":"\n\n\n\n\n\n\n\n\n环境为 vue-cli3、webpack、vscode\n首先需要在VSCode中安装 Debugger for Chrome 插件\n\n然后在debug配置中添加如下配置\n\n配置代码\njs&#123;\n     &quot;type&quot;: &quot;chrome&quot;,\n     &quot;request&quot;: &quot;launch&quot;,\n     &quot;name&quot;: &quot;vuejs: chrome&quot;,\n     &quot;url&quot;: &quot;http://localhost:8080&quot;, //改成自己的端口就行\n     &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;/src&quot;,\n     &quot;breakOnLoad&quot;: true,\n     &quot;sourceMapPathOverrides&quot;: &#123;\n         &quot;webpack:///src/*&quot;: &quot;$&#123;webRoot&#125;/*&quot;\n     &#125;\n&#125;webpack的配置\n\n使用vue-cli3的话，在vue.config.js中configureWebpack项中添加以下两个配置\njsconfigureWebpack: &#123;\n    devtool: &#39;source-map&#39;,// 保证源码正确加载\n&#125;,\n使用其他的方式构建项目，在conf&#x2F;index.js中修改将devtool: &#39;cheap-module-eval-source-map&#39;修改为devtool: &#39;source-map&#39;\n\n\n","slug":"使用VSCode编辑器debug调试Vue代码","date":"2019-12-25T16:24:33.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"0fbbceddbe858589d1dc31c9d206fd02","title":"纯Canvas事件按钮点击按下效果","content":"使用纯Canvas实现一个按钮点击按下的效果，类似下图\n\n使用到的API阴影偏移：\n\nshadowOffsetX &#x3D; float\nshadowOffsetY &#x3D; float\n用来实现有体积的视觉效果 效果等同于 css中的shadow属性\n\n阴影模糊：\n\nshadowBlur &#x3D; float\n设置阴影的模糊效果\n\n阴影颜色：\n\nshadowColor &#x3D; color\n设置阴影的颜色\n\n路径：\n\nbeginPath() \nmoveTo()\nlineTo()\nquadraticCurveTo()\nclosePath()\n以此为 起始一条路径，或重置当前路径、把路径移动到画布中的指定点，不创建线条、\t添加一个新点，然后在画布中创建从该点到最后指定点的线条、创建二次贝塞尔曲线、\t创建从当前点回到起始点的路径\n\n具体实现：\nhtml&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n    &lt;canvas id=&quot;myCanvas&quot; width=&quot;1000&quot; height=&quot;800&quot; style=&quot;border:1px solid #d3d3d3;&quot;&gt;&lt;/canvas&gt;\n\n    &lt;script&gt;\n        var c = document.getElementById(&quot;myCanvas&quot;);\n        var ctx = c.getContext(&quot;2d&quot;);\n\n        var x = 20\n        var y = 20\n        var height = 100\n        var width = 200\n        var radius = 5\n\n        // 绘制初始状态\n        radiusRect(x, y, width, height, radius, ctx)\n        setShadow(ctx)\n        draw(ctx)\n        cleartShadow(ctx)\n\n        // 绘制圆角矩形\n        function radiusRect(x, y, width, height, radius, ctx) &#123;\n            // 开启路径\n            ctx.beginPath()\n            // 设置填充颜色\n            ctx.fillStyle = &quot;#0066CC&quot;\n            // 绘制边\n            ctx.moveTo(x, y + radius)\n            ctx.lineTo(x, y + height - radius)\n            // 绘制圆角\n            ctx.quadraticCurveTo(x, y + height, x + radius, y + height)\n            ctx.lineTo(x + width - radius, y + height)\n            ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius)\n            ctx.lineTo(x + width, y + radius)\n            ctx.quadraticCurveTo(x + width, y, x + width - radius, y)\n            ctx.lineTo(x + radius, y)\n            ctx.quadraticCurveTo(x, y, x, y + radius)\n            // 闭合路径\n            ctx.closePath();\n        &#125;\n\n        // 设置阴影和偏移\n        function setShadow(ctx) &#123;\n            ctx.shadowOffsetX = 0\n            ctx.shadowOffsetY = 10 // 10个偏移量\n            ctx.shadowBlur = 0\n            ctx.shadowColor = &quot;#006600&quot;\n        &#125;\n\n        // 清楚掉阴影和位移\n        function cleartShadow(ctx) &#123;\n            ctx.shadowOffsetX = 0\n            ctx.shadowOffsetY = 0\n        &#125;\n\n        // 绘制到画布上\n        function draw(ctx) &#123;\n            ctx.stroke()\n            ctx.fill()\n        &#125;\n\n        //事件监听 按下时，持续的绘制为按下状态\n        c.addEventListener(&#39;mousedown&#39;, (e) =&gt; &#123;\n            if (e.clientX &gt;= x &amp;&amp; e.clientX &lt;= x + width &amp;&amp; e.clientY &gt;= y &amp;&amp; e.clientY &lt;= y + height &amp;&amp; e\n                .button == 0) &#123;\n                ctx.clearRect(0, 0, 1000, 1000) // 先清楚所有的矩形\n                radiusRect(x, y + 10, width, height, radius, ctx) // 10个偏移量\n                draw(ctx)\n\n\n            &#125;\n        &#125;)\n\n        //事件监听 抬起时，恢复为初始状态\n        c.addEventListener(&#39;mouseup&#39;, (e) =&gt; &#123;\n            if (e.button == 0) &#123;\n                setTimeout(() =&gt; &#123;\n                    radiusRect(x, y, width, height, radius, ctx)\n                    setShadow(ctx)\n                    draw(ctx)\n                    cleartShadow(ctx)\n                &#125;, 100)\n            &#125;\n        &#125;)\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;","slug":"纯Canvas事件按钮点击按下效果","date":"2019-12-25T16:23:35.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"429bc49bea45cd590028e18172e3c7b5","title":"如何跳过SourceTree的注册步骤，直接使用功能（3.2.6亲测有效）","content":"首先在官网上下载 SourceTree 的安装包，我下载的时候最新版本是 3.2.6官方下载链接\n安装好软件后，打开软件会提示必须使用 Bitbuket 的账号才可以登录，我们只需要跳过这一步就可以正常使用其功能，具体步骤为：\n第一步：在文件系统地址栏输入： %LocalAppData%\\Atlassian进入SourceTree目录在该目录创建accounts.json，并写入内容\ntxt [&#123;\n  &quot;$id&quot;: &quot;1&quot;,\n  &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;,\n  &quot;Authenticate&quot;: true,\n  &quot;HostInstance&quot;: &#123;\n    &quot;$id&quot;: &quot;2&quot;,\n    &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;,\n    &quot;Host&quot;: &#123;\n      &quot;$id&quot;: &quot;3&quot;,\n      &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;,\n      &quot;Id&quot;: &quot;atlassian account&quot;\n    &#125;,\n    &quot;BaseUrl&quot;: &quot;https://id.atlassian.com/&quot;\n  &#125;,\n  &quot;Credentials&quot;: &#123;\n    &quot;$id&quot;: &quot;4&quot;,\n    &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;,\n    &quot;Username&quot;: &quot;&quot;,\n    &quot;Email&quot;: null\n  &#125;,\n  &quot;IsDefault&quot;: false\n&#125;]第二步：在文件系统地址栏输入：%LocalAppData%\\Atlassian进入SourceTree.exe_Url_2teh2ti3u00uadewxtjgksiqhpw5qyeh文件夹（根据版本不同，文件夹名称略有不同但前半部是一样的），再次进入名称为版本号的文件夹，这里是3.2.6.3544，打开user.config文件在SourceTree标签中添加代码\ntxt&lt;setting name=&quot;AgreedToEULA&quot; serializeAs=&quot;String&quot;&gt;\n    &lt;value&gt;True&lt;/value&gt;\n&lt;/setting&gt;\n&lt;setting name=&quot;AgreedToEULAVersion&quot; serializeAs=&quot;String&quot;&gt;\n    &lt;value&gt;20160201&lt;/value&gt;\n &lt;/setting&gt;第三步：重启软件后就已经跳过了注册/登录的步骤，此时会弹出未检测到mercurial的弹窗，选择第四个不适用mercurial，即可正常使用 SourceTree 的功能了。\n","slug":"如何跳过SourceTree的注册步骤，直接使用功能（3.2.6亲测有效）","date":"2019-11-05T02:03:00.000Z","categories_index":"","tags_index":"git","author_index":"天然卷打工战士"},{"id":"d47195800af9e19545026a7859b4e5f4","title":"使用gitbucket搭建内网私服github服务器","content":"\n\n\n\n\n\n\n\n\ngitbucket是一个使用 Scala 编写运行在 java 虚拟机上的 git 服务器端程序，releases 版提供可直接使用的 war 包，搭建方便，功能对于小公司，小团队来说也都足够。\n环境\ngitbucket 下载地址\njdk8\ntomcat8(非必须)\n\n启动\n下载好 war 包后，使用java -jar gitbucket.war命令进行启动\n\n启动成功后在浏览器输入localhost:8080看到如下页面说明启动成功\n\n使用 root 账户登录，账号：root，密码：root\n\n创建用户\n\n新建仓库后就可以和团队之间进行协作开发了\n\n\n结束以上就是简单的搭建一个gitbucket服务器的全部了，gitbucket除了支持 git 的管理还支持很多特性，如：Issues、PR、wiki、仓库的权限管理等功能，在以后的文章里会专门进行介绍。\n","slug":"使用gitbucket搭建内网私服github服务器","date":"2019-07-21T07:29:48.000Z","categories_index":"","tags_index":"git,gitbucket","author_index":"天然卷打工战士"},{"id":"9f65f9154397f0206bf8e3273761ecef","title":"js运算符优先级记录","content":"最近在系统的重新学习js的知识，看到了优先级的相关资料，以前都没有注意到过的小细节，今天记录一下，如果以后有机会遇到相关的坑也方便找一下。\n\n\n\n优先级\n运算类型\n关联性\n运算符\n\n\n\n20\n圆括号\nn&#x2F;a\n( … )\n\n\n19\n成员访问\n从左到右\n… . …\n\n\n19\n需计算的成员访问\n从左到右\n… [ … ]\n\n\n19\nnew (带参数列表)\nn&#x2F;a\n… . …\n\n\n18\nnew (无参数列表)\n从右到左\nnew …\n\n\n17\n后置递增(运算符在后)\nn&#x2F;a\n… ++\n\n\n17\n后置递减(运算符在后)\nn&#x2F;a\n… –\n\n\n16\n逻辑非\n从右到左\n! …\n\n\n16\n按位非\n从右到左\n~ …\n\n\n16\n一元加法\n从右到左\n+ …\n\n\n16\n一元减法\n从右到左\n- …\n\n\n16\n前置递增\n从右到左\n++ …\n\n\n16\n前置递减\n从右到左\n– …\n\n\n16\ntypeof\n从右到左\ntypeof …\n\n\n16\nvoid\n从右到左\nvoid …\n\n\n16\ndelete\n从右到左\ndelete …\n\n\n15\n幂\n从右到左\n… ** …\n\n\n14\n乘法\n从左到由\n… * …\n\n\n14\n除法\n从左到右\n… &#x2F; …\n\n\n14\n取模\n从左到右\n… % …\n\n\n13\n加法\n从左到右\n… + …\n\n\n13\n减法\n从左到右\n… - …\n\n\n12\n按位左移\n从左到右\n… &lt;&lt; …\n\n\n12\n按位右移\n从左到右\n… &gt;&gt; …\n\n\n12\n无符号右移\n从左到右\n… &gt;&gt;&gt; …\n\n\n11\n小于\n从左到右\n… &lt; …\n\n\n11\n小于等于\n从左到右\n… &lt;&#x3D; …\n\n\n11\n大于\n从左到右\n… &gt; …\n\n\n11\n大于等于\n从左到右\n… &gt;&#x3D; …\n\n\n11\nin\n从左到右\n… in …\n\n\n11\ninstanceof\n从左到右\n… instanceof …\n\n\n10\n等号\n从左到右\n… &#x3D;&#x3D; …\n\n\n10\n非等号\n从左到右\n… !&#x3D; …\n\n\n10\n全等号\n从左到右\n… &#x3D;&#x3D;&#x3D; …\n\n\n10\n非全等号\n从左到右\n… !&#x3D;&#x3D; …\n\n\n9\n按位与\n从左到右\n… &amp; …\n\n\n8\n按位异或\n从左到右\n… ^ …\n\n\n7\n按位或\n从左到右\n…\t…\n\n\n6\n逻辑与\n从左到右\n… &amp;&amp; …\n\n\n5\n逻辑或\n从左到右\n…\t\t…\n\n\n4\n条件运算符\n从右到左\n… ? … : …\n\n\n3\n赋值\n从右到左\n… &#x3D; …\n\n\n3\n复合赋值运算符\n\n+&#x3D; …\n\n\n3\n复合赋值运算符\n\n-&#x3D; …\n\n\n3\n复合赋值运算符\n\n*&#x3D; …\n\n\n3\n复合赋值运算符\n\n&#x2F;&#x3D; …\n\n\n3\n复合赋值运算符\n\n%&#x3D; …\n\n\n3\n复合赋值运算符\n\n&lt;&lt;&#x3D; …\n\n\n3\n复合赋值运算符\n\n&gt;&gt;&#x3D; …\n\n\n3\n复合赋值运算符\n\n&gt;&gt;&gt;&#x3D; …\n\n\n3\n复合赋值运算符\n\n&amp;&#x3D; …\n\n\n3\n复合赋值运算符\n\n^&#x3D; …\n\n\n3\n复合赋值运算符\n\n&#x3D; …\n\n\n2\nyield\n从右到左\nyield …\n\n\n2\nyield*\n从右到左\nyield* …\n\n\n1\n展开运算符\nn&#x2F;a\n… …\n\n\n0\n逗号\n从左到右\n… , …\n\n\n","slug":"js运算符优先级记录","date":"2019-06-09T08:11:56.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"1c6f35bdc8ba11e47fd7fdb4a881c294","title":"关于Vue兼容IE10","content":"因为Vue使用了ES6语法，而低版本IE浏览器不支持，解决方法是:使用**babel-polyfill**转换成ES5，具体办法\n\n\n\n\n\n\n\n\n\n这个方法只能支持到**IE9为止的语法兼容**，关于样式的兼容需要另行处理\n\n安装**@babel/polyfill**\ntxt $ npm install --save-dev babel/polyfill\n在**packgae.json中找到browserslist**添加\ntxt &quot;browserslist&quot;: [\n    &quot;&gt; 1%&quot;,\n    &quot;last 2 versions&quot;,\n    &quot;not ie &lt;= 8&quot;,\n    &quot;ie 8&quot;\n  ]\n在**babel.config.js**中添加\ntxt  module.exports = &#123;\n    presets: [\n      [&#39;@vue/app&#39;, &#123;\n        useBuiltIns: &#39;entry&#39;\n    &#125;]\n    ]\n  &#125;\n在**main.js**中引入\ntxt  import &#39;@babel/polyfill&#39;\n然后重启项目，应该就可以正常显示了。\n\n\n\n\n\n\n\n\n\n\n\n这里有两个问题：一个是如果配置了多页面的话，那么在多页面的js入口中都需要引入** import &#39;@babel/polyfill&#39;；第二个是，这里只兼容到了IE10，element-ui表现良好，如果需要兼容到IE9也可以用这个办法，但是IE9没有Flex布局所以element-ui在IE9下布局样式是完全崩溃的，解决办法是使用css3的calc()**函数\n","slug":"关于Vue兼容IE10","date":"2019-04-30T06:09:00.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"12ed2830258b8dcd4c32cee291a17957","title":"js中的柯里化实现","content":"在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。\n简单的来说柯里化就是把原本多参数的函数，转换成每次只接受一个参数，但是参数可传递的函数链来使用。\n简单的例子\njs    // 柯里化前\n   let plus = (a,b) =&gt; a + b\n   plus(1,2)  // 输出：3\n\n    // 柯里化后\n    let plusTwoNum = (a,b)=&gt; a+b\n    let plus = fpu.curry(plusTwoNum)\n    plus(1)(2) // 输出：3上面是代码是很简单的一个函数柯里化例子，乍一看是没有什么特别的用处的，但是在某些场景是可以发乎很大的用处的，比如说当程序需要运行上面的sum函数，但是参数确实分开获取的，在某一时刻只能获取到其中的一个值a，值b需要一定条件后才能拿到的时候就可以使用柯里化来完美的解决这个问题。\n下面简单说一下柯里化的简单实现（想要支持更复杂的特性，需要自己进行增强）先上代码\njs    // 函数自动柯里化\n    // eg: new FPUtiles().curry((a,b,c,d) =&gt; a+b+c+d)(1)(2)(3)(4)\n    curry(fn)&#123;\n        const _fn = (restNum,argList) =&gt; restNum === 0 ? fn(...argList) : x =&gt; _fn(restNum-1,[...argList,x])\n        return _fn(fn.length,[])\n    &#125;下面开始整理思路：\n\n首先curry函数接收一个函数，这个函数是我们真正的处理逻辑的函数\n然后通过闭包，声明一个函数_fn，_fn接收两个参数，一个是真正函数的参数列表长度的计数器，一个是传入参数的列表\n在_fn函数中判断真正函数的参数列表是否等于0，等于0代表参数已经全部都传入进来了，可以调用真正的函数去进行计算，并返回fn函数进行计算然后返回结果；如果参数列表不等于0，则把参数列表的计数器-1，并把传入参数进行合并，然后使用返回_fn函数供尾递归调用。\n\n上面就是柯里化的大体思路，主要实现是依赖闭包和尾递归来实现的，所以在性能上有优化的同时也是有一定的损失，对于性能要求很苛刻的程序可能需要酌情考虑，一般情况下合理使用柯里化是可以把代码的可读性提高很多。\n","slug":"js中的柯里化实现","date":"2019-04-24T06:50:27.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"ca5f7333fd4afa33ba15d97463d47073","title":"VSCode安装使用编程字体FiraCode","content":"FiraCode字体是一个可以把编程中常用的组合符号优化显示的字体\n下面开始在VSCode中的配置\n\n首先在FiraCode的github页面下载字体\n\n把下载的压缩包解压，然后找到ttf文件夹，全部选中，右键安装即可\n\n在VSCode中的配置\njs  &quot;editor.fontFamily&quot;: &quot;&#39;Fira Code&#39;, Consolas, &#39;Courier New&#39;, monospace&quot;,//添加上FiraCode字体\n  &quot;editor.fontLigatures&quot;: true,//开启连体字\n\n\n\n\n\n\n\n\n\n\n如果配置完后，编辑器的内容没什么变化的话，重启一下就可以了。\n","slug":"VSCode安装使用编程字体FiraCode","date":"2019-04-24T02:21:10.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"38463cdb58c9ed519678c1b1d62b6f8a","title":"CocosCreator实现摄像机跟随移动","content":"如果只有一个摄像机的话，在Main Camera上添加脚本\n\n这样的话就可以实现摄像机跟随主角移动而移动\n","slug":"实现摄像机跟随移动","date":"2019-04-07T17:15:48.000Z","categories_index":"","tags_index":"游戏开发","author_index":"天然卷打工战士"},{"id":"f05f533c1133c025c502733d54123419","title":"Canvas实现文字粒子效果","content":"最终实现效果\n\n实现思路：\n\n\n\n\n\n\n\n\n\n获取到canvas绘制后屏幕上像素点的数组，在目标像素点上绘制粒子替换掉原来的内容\n\n绘制文字\n通过API获取画布的二进制数组\n设置粒子的填充步长\n添加粒子\n循环的遍历粒子，更新粒子的状态\n\n代码实现\n绘制文字\njs   context.textAlign = &quot;center&quot;;\n   context.font = this.size + &quot;px arial&quot;;\n   context.fillText(this.text, this.x, this.y);获取二进制数组\njs   let idata = context.getImageData(0, 0, canvas.width, canvas.height); // 获取 canvas指定范围内的 像素数组\n   let buffer32 = new Uint32Array(idata.data.buffer); // 转成32位的数组\n\n\n\n\n\n\n\n\n这里使用的getImageData()方法是获取画布内所有的像素点的二进制表示，在JS中使用Uint32Array来接收，已数组形式展现，没有渲染的地方数组值是0，有渲染的地方为一个非0的数字\n填充粒子\njs// 遍历所有的数组 \nfor (var j = 0; j &lt; canvas.height; j += gridY) &#123;//步长\n  for (var i = 0; i &lt; canvas.width; i += gridX) &#123;//步长\n      if (buffer32[j * canvas.width + i]) &#123;\n            // 放入粒子对象\n            var ball = new Particle(i, j);\n            this.placement.push(ball);\n      &#125;\n    &#125;\n &#125;\n\n\n\n\n\n\n\n\n这里的意思是在二进制数组中某一个范围内的粒子的密度，其中步长越小越密集\n更新粒子状态\njs(function drawFrame() &#123;\n    window.requestAnimationFrame(drawFrame);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    for (var i = 0; i &lt; word.placement.length; i++) &#123;\n        //调用particle对像的drawParticle方法，开始画布上画\n        word.placement[i].drawParticle();\n    &#125;\n&#125;())js            this.drawParticle = function () &#123;\n                // 当前粒子变小到一定程度之后，每次将它的半径+0.1，使其慢慢变大\n                if (this.radius &lt; this.futurRadius &amp;&amp; this.dying === false) &#123;\n                    this.radius += durVal;\n                &#125; else &#123; //粒子已经到达最大状态\n                    this.dying = true; //表示粒子还处于show状态\n                &#125;\n\n                //每次-0.1\n                if (this.dying) &#123;\n                    this.radius -= durVal;\n                &#125;\n                // 画粒子形状\n                context.save();\n                context.fillStyle = this.color;\n                context.beginPath();\n                context.fillRect(this.x, this.y, this.futurRadius, this.futurRadius)\n                context.closePath();\n                context.fill();\n                context.restore();\n\n                //将消失的粒子重置最初的状态\n                if (this.y &lt; 0 || this.radius &lt; 1) &#123;\n                    this.x = this.base[0];\n                    this.y = this.base[1];\n                    this.dying = false;\n                    this.futurRadius = randomInt(1.1, 5.1);\n                &#125;\n            &#125;完整代码\nhtml&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;canvas id=&quot;dir&quot; width=&quot;800&quot; height=&quot;800&quot; style=&quot;border:1px solid #ccc&quot;&gt;\n    &lt;/canvas&gt;\n\n    &lt;script&gt;\n        var canvas = document.getElementById(&quot;dir&quot;);\n        var context = canvas.getContext(&quot;2d&quot;);\n\n        var gridY = 10,\n            gridX = 10,\n            colors = [&#39;#f44336&#39;, &#39;#e91e63&#39;, &#39;#9c27b0&#39;, &#39;#673ab7&#39;, &#39;#3f51b5&#39;,\n                &#39;#2196f3&#39;, &#39;#03a9f4&#39;, &#39;#00bcd4&#39;, &#39;#009688&#39;, &#39;#4CAF50&#39;,\n                &#39;#8BC34A&#39;, &#39;#CDDC39&#39;, &#39;#FFEB3B&#39;, &#39;#FFC107&#39;, &#39;#FF9800&#39;,\n                &#39;#FF5722&#39;\n            ],\n            durVal = 0.1;\n\n\n        // 粒子\n        function Particle(x, y) &#123;\n            this.x = x;\n            this.y = y;\n            this.color = colors[Math.floor(Math.random() * colors.length)]; //&#39;bleack&#39;//\n            this.futurRadius = randomInt(1.1, 5.1);\n            this.radius = 1.1;\n            this.dying = false;\n            this.base = [x, y];\n\n            this.drawParticle = function () &#123;\n\n                // 当前粒子变小到一定程度之后，每次将它的半径+0.1，使其慢慢变大\n                if (this.radius &lt; this.futurRadius &amp;&amp; this.dying === false) &#123;\n                    this.radius += durVal;\n                &#125; else &#123; //粒子已经到达最大状态\n                    this.dying = true; //表示粒子还处于show状态\n                &#125;\n\n                //每次-0.1\n                if (this.dying) &#123;\n                    this.radius -= durVal;\n                &#125;\n                // 画粒子形状\n                context.save();\n                context.fillStyle = this.color;\n                context.beginPath();\n                context.fillRect(this.x, this.y, this.futurRadius, this.futurRadius)\n                context.closePath();\n                context.fill();\n                context.restore();\n\n                //将消失的粒子重置最初的状态\n                if (this.y &lt; 0 || this.radius &lt; 1) &#123;\n                    this.x = this.base[0];\n                    this.y = this.base[1];\n                    this.dying = false;\n                    this.futurRadius = randomInt(1.1, 5.1);\n                &#125;\n            &#125;\n        &#125;\n\n        function Shape(x, y, texte) &#123;\n            this.x = x;\n            this.y = y;\n            this.size = 200;\n            this.text = texte;\n            this.placement = [];\n        &#125;\n\n\n        Shape.prototype.getValue = function () &#123;\n            context.textAlign = &quot;center&quot;;\n            context.font = this.size + &quot;px arial&quot;;\n            context.fillText(this.text, this.x, this.y);\n\n            let idata = context.getImageData(0, 0, canvas.width, canvas.height); // 获取 canvas指定范围内的 像素数组\n            let buffer32 = new Uint32Array(idata.data.buffer); // 转成32位的数组\n\n            // 遍历所有的数组 \n            for (var j = 0; j &lt; canvas.height; j += gridY) &#123;\n                for (var i = 0; i &lt; canvas.width; i += gridX) &#123;\n                    if (buffer32[j * canvas.width + i]) &#123;\n                        // 放入粒子对象\n                        var ball = new Particle(i, j);\n                        this.placement.push(ball);\n                    &#125;\n                &#125;\n            &#125;\n\n            context.clearRect(0, 0, canvas.width, canvas.height);\n        &#125;\n\n        function randomInt(min, max) &#123;\n            return min + Math.random() * (max - min + 1);\n        &#125;\n\n        var word = new Shape(canvas.width / 2, canvas.height / 2, &#39;文字粒子&#39;)\n        word.getValue\n\n        (function drawFrame() &#123;\n            window.requestAnimationFrame(drawFrame);\n            context.clearRect(0, 0, canvas.width, canvas.height);\n\n            for (var i = 0; i &lt; word.placement.length; i++) &#123;\n                //调用particle对像的drawParticle方法，开始画布上画\n                word.placement[i].drawParticle();\n            &#125;\n\n        &#125;())\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n","slug":"Canvas实现文字粒子效果","date":"2019-03-29T06:45:12.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"6d5ec0ddb13963c47904e9839c9e31d9","title":"git把某本地分支的某次修改修改到其他远程分支","content":"起因因为一次手残操作，在没看清分支的情况下把代码写在了一个错误分支上，并且把修改提交到了该分支上。在网上找了很多解决办法都不太好用，最后用下面的这个命令解决了这个问题。\n目标git的修改提交到了不是目标分支的另一个分支上，需要将其修正过来。\n解决\n首先切换到本地的错误分支上 git checkout -b [分支]\n\n在错误分支上使用命令 git log 控制台输出\n 复制下需要修改的提交记录的commitedId(红框内的部分)\n\n切换到正常的分支上使用命令 git cherry-pick [commitedId] \n\n如果有冲突，解决冲突之后 git add . git cherry-pick --continue\n\n\n\n\n\n\n\n\n\n\n\n此时可能会出现一个error的报错，暂时还没有研究这个报错的原因，不过好像并没有什么影响，代码已经被更新到正确的分支上了。\n","slug":"git把某本地分支的某次修改修改到其他远程分支","date":"2019-03-28T08:18:56.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"043f9cbe38a0b25b8b616d2a4ca463e9","title":"JavaScript工作原理之事件循环和基础的异步实现","content":"事件循环\n常规的JavaScript引擎是单线程的，也就是说所有的代码块都是顺序按照顺序被执行，这就导致遇到处理慢的代码块会阻塞软件的运行，甚至使程序停止响应，通常解决方案是使用异步来处理，把需要时间处理的代码块异步的进行处理，后面的块则继续执行，等到该代码块处理完以后再回过头来进行结果的处理，但是在ES6前并没有很好的异步解决方案，所以大部分是使用setTimeout来进行处理。下面就通过setTimeout的执行原理来理解一下JavaScript的异步处理的核心机制－－事件循环机制。\n首先看一下JavaScript的运行时模型：\n\nJavaScript引擎部分(例如V8引擎) ，黑框中部分\n\nWebAPIs部分，由宿主环境提供的额外API不属于引擎的原生部分\n\nEventLoop &amp; CallbackQueue 事件循环和回调队列，同样属于宿主环境提供的机制，用于辅助引擎工作\n\n\n\n\n下面基于这个模型，通过定时器来理解一下，JavaScript的事件循环机制以及异步是如何调用的。\n首先写一个基本的定时器\n[图片上传失败…(image-5c33a6-1553756162784)]\n1.代码运行，此时进行代码的解析\n\n2.调用console.log(&#39;HI&#39;) 进入到调用栈中\n\n3.控制台打印Hi\n\n4.解析下一部分代码\n\n5.执行定时器，加入到调用栈中\n\n6.在WebAPIs中创建一个Timer，并将定时器的内容移过去\n\n7.定时器部分执行完毕，弹出调用栈,此时定时器内的内容被保存在WebAPIs环境当中\n\n8.调用console.log(&#39;Bye&#39;) 进入到调用栈中\n\n9.控制台打印Bye\n\n10.console.log(&#39;Bye&#39;)弹出调用栈\n\n11.等待WebAPIs中的timer执行，将cb1加入到回调队列中\n\n12.通过事件循环将回调队列中的cb1重新压入到调用栈中\n\n13.cb1内调用了console.log(&#39;cb1&#39;)所以也要压入到调用栈中\n\n14.控制台打印cb1\n\n15.弹出console.log(&#39;cb1&#39;)\n\n16.弹出cb1\n\n通过对setTimeout的流程解析，很容易发现JavaScript在运行时的调用过程是首先由JS引擎将代码解析编译，然后根据调用顺序加入到调用栈中(栈中的每一项都叫做帧)逐帧执行，其中需要用到WebAPIs、事件循环、回调队列的辅助，最后将执行的结果返回给调用处，至此JavaScript就完成了一次调用的循环。\n基础异步实现\n上面的例子已经使用setTimeout实现了一个基础的异步调用但是需要注意的是，虽然例子中使用的setTimeout(myCallback, 5000);但这并不意味着回调函数会在5秒后立即被执行，而是表示回调方法在5秒后把回调函数添加到回调队列中,如果此时队列中存在待处理任务，那么该回调函数也会相应的被延迟执行。\n所以即使是像下面这个例子一样也依然会是一个异步的调用结果，因为setTimeout的第二个参数仅仅是延迟多久将回调内容放置到回调队列中，而不是确保延迟多久后一定执行。\ntxt\nconsole.log(&#39;Hi&#39;);\n\nsetTimeout(function() &#123;\n\n    console.log(&#39;callback&#39;);\n\n&#125;, 0);\n\nconsole.log(&#39;Bye&#39;);\n\n/**输出结果**/\n\n//Hi\n\n//Bye\n\n//callback\n","slug":"JavaScript工作原理之事件循环和基础的异步实现","date":"2019-03-28T06:22:44.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"4ed54b66406825cfd09b4a09d07c0870","title":"[转]写好JavaScript条件语句的5条守则","content":"\n\n\n\n\n\n\n\n\n\n原文地址：5 Tips to Write Better Conditionals in JavaScript\n原文作者：ecelyn Yeen(@jecelynyeen)\n译文出自：阿里云翻译小组\n译文链接：https://github.com/dawn-teams/translate/blob/master/articles/5-Tips-to-Write-Better-Conditionals-in-JavaScript.md\n译者：眠云(杨涛)\n校对者：也树，Mcskiller\n\n\n写好JavaScript条件语句的5条守则在用 JavaScript 工作时，我们经常和条件语句打交道，这里有5条让你写出更好&#x2F;干净的条件语句的建议。\n1.多重判断时使用 Array.includes\n2.更少的嵌套，尽早 return\n3.使用默认参数和解构\n4.倾向于遍历对象而不是 Switch 语句\n5.对 所有&#x2F;部分 判断使用 Array.every &amp; Array.some\n6.总结\n1.多重判断时使用 Array.includes让我们看一下下面这个例子:\njs// condition\nfunction test(fruit) &#123;\n  if (fruit == &#39;apple&#39; || fruit == &#39;strawberry&#39;) &#123;\n    console.log(&#39;red&#39;);\n  &#125;\n&#125;第一眼，上面这个例子看起来没问题。如果我们有更多名字叫 cherry 和 cranberries 的红色水果呢？我们准备用更多的 || 来拓展条件语句吗？\n我们可以用 Array.includes (Array.includes)重写条件语句。\njsfunction test(fruit) &#123;\n  const redFruits = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  if (redFruits.includes(fruit)) &#123;\n    console.log(&#39;red&#39;);\n  &#125;\n&#125;我们把红色的水果(red fruits)这一判断条件提取到一个数组。这样一来，代码看起来更整洁。\n2.更少的嵌套，尽早 Return让我们拓展上一个例子让它包含两个条件。\n\n如果没有传入参数 fruit，抛出错误\n接受 quantity 参数，并且在 quantity 大于 10 时打印出来\n\njsfunction test(fruit, quantity) &#123;\n  const redFruits = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  // 条件 1: fruit 必须有值\n  if (fruit) &#123;\n    // 条件 2: 必须是red的\n    if (redFruits.includes(fruit)) &#123;\n      console.log(&#39;red&#39;);\n\n      // 条件 3: quantity大于10\n      if (quantity &gt; 10) &#123;\n        console.log(&#39;big quantity&#39;);\n      &#125;\n    &#125;\n  &#125; else &#123;\n    throw new Error(&#39;No fruit!&#39;);\n  &#125;\n&#125;\n\n// 测试结果\ntest(null); // error: No fruits\ntest(&#39;apple&#39;); // print: red\ntest(&#39;apple&#39;, 20); // print: red, big quantity在上面的代码, 我们有:\n\n1个 if&#x2F;else 语句筛选出无效的语句\n3层if嵌套语句 (条件 1, 2 &amp; 3)\n\n我个人遵循的规则一般是在发现无效条件时，尽早Return。\njs/_ 当发现无效语句时，尽早Return _/\n\nfunction test(fruit, quantity) &#123;\n  const redFruits = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  // 条件 1: 尽早抛出错误\n  if (!fruit) throw new Error(&#39;No fruit!&#39;);\n\n  // 条件 2: 必须是红色的\n  if (redFruits.includes(fruit)) &#123;\n    console.log(&#39;red&#39;);\n\n    // 条件 3: 必须是大质量的\n    if (quantity &gt; 10) &#123;\n      console.log(&#39;big quantity&#39;);\n    &#125;\n  &#125;\n&#125;\n这样一来，我们少了一层嵌套语句。这种编码风格非常好，尤其是当你有很长的if语句的时候(想象你需要滚动到最底层才知道还有else语句，这并不酷)\n我们可以通过 倒置判断条件 &amp; 尽早return 进一步减少if嵌套。看下面我们是怎么处理判断 条件2 的: \njs/_ 当发现无效语句时，尽早Return _/\n\nfunction test(fruit, quantity) &#123;\n  const redFruits = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  // 条件 1: 尽早抛出错误\n  if (!fruit) throw new Error(&#39;No fruit!&#39;);\n  // 条件 2: 当水果不是红色时停止继续执行\n  if (!redFruits.includes(fruit)) return; \n\n  console.log(&#39;red&#39;);\n\n  // 条件 3: 必须是大质量的\n  if (quantity &gt; 10) &#123;\n    console.log(&#39;big quantity&#39;);\n  &#125;\n&#125;通过倒置判断条件2，我们的代码避免了嵌套语句。这个技巧在我们需要进行很长的逻辑判断时是非常有用的，特别是我们希望能够在条件不满足时能够停止下来进行处理。\n而且这么做并不困难。问问自己，这个版本(没有嵌套)是不是比之前的(两层条件嵌套)更好，可读性更高？\n但对于我，我会保留先前的版本(包含两层嵌套)。这是因为:\n\n代码比较短且直接，包含if嵌套的更清晰\n倒置判断条件可能加重思考的负担(增加认知载荷)\n\n因此，应当尽力减少嵌套和尽早return，但不要过度。如果你感兴趣的话，可以看一下关于这个话题的一篇文章和 StackOverflow 上的讨论。\n\nAvoid Else, Return Early by Tim Oxley\nStackOverflow discussion on if&#x2F;else coding style\n\n3.使用默认参数和解构我猜下面的代码你可能会熟悉，在JavaScript中我们总是需要检查 null &#x2F; undefined的值和指定默认值:\njsfunction test(fruit, quantity) &#123;\n  if (!fruit) return;\n  // 如果 quantity 参数没有传入，设置默认值为 1\n  const q = quantity || 1; \n\n  console.log(`We have $&#123;q&#125; $&#123;fruit&#125;!`);\n&#125;\n\n//test results\ntest(&#39;banana&#39;); // We have 1 banana!\ntest(&#39;apple&#39;, 2); // We have 2 apple!实际上，我们可以通过声明 默认函数参数 来消除变量 q。\njsfunction test(fruit, quantity = 1) &#123;\n  // 如果 quantity 参数没有传入，设置默认值为 1\n  if (!fruit) return;\n  console.log(`We have $&#123;quantity&#125; $&#123;fruit&#125;!`);\n&#125;\n\n//test results\ntest(&#39;banana&#39;); // We have 1 banana!\ntest(&#39;apple&#39;, 2); // We have 2 apple!这更加直观，不是吗？注意，每个声明都有自己的默认参数.\n例如，我们也能给fruit分配默认值:function test(fruit = &#39;unknown&#39;, quantity = 1)。\n如果fruit是一个object会怎么样？我们能分配一个默认参数吗？\njsfunction test(fruit) &#123; \n  // 当值存在时打印 fruit 的值\n  if (fruit &amp;&amp; fruit.name)  &#123;\n    console.log (fruit.name);\n  &#125; else &#123;\n    console.log(&#39;unknown&#39;);\n  &#125;\n&#125;\n\n//test results\ntest(undefined); // unknown\ntest(&#123; &#125;); // unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); // apple看上面这个例子，我们想打印 fruit 对象中可能存在的 name 属性。否则我们将打印unknown。我们可以通过默认参数以及解构从而避免判断条件 fruit &amp;&amp; fruit.name\njs// 解构 - 仅仅获取 name 属性\n// 为其赋默认值为空对象\nfunction test(&#123;name&#125; = &#123;&#125;) &#123;\n  console.log (name || &#39;unknown&#39;);\n&#125;\n\n// test results\ntest(undefined); // unknown\ntest(&#123; &#125;); // unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); // apple由于我们只需要 name 属性，我们可以用 &#123;name&#125; 解构出参数，然后我们就能使用变量 name 代替 fruit.name。\n我们也需要声明空对象 &#123;&#125; 作为默认值。如果我们不这么做，当执行 test(undefined) 时，你将得到一个无法对 undefined 或 null 解构的的错误。因为在 undefined 中没有 name 属性。\n如果你不介意使用第三方库，这有一些方式减少null的检查:\n\n使用 Lodash get函数\n使用Facebook开源的idx库(with Babeljs)\n\n这是一个使用Lodash的例子:\njsfunction test(fruit) &#123;\n  // 获取属性名，如果属性名不可用，赋默认值为 unknown\n  console.log(__.get(fruit, &#39;name&#39;, &#39;unknown&#39;); \n&#125;\n\n// test results\ntest(undefined); // unknown\ntest(&#123; &#125;); // unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); // apple你可以在jsbin运行demo代码。除此之外，如果你是函数式编程的粉丝，你可能选择使用 Lodash fp，Lodash的函数式版本(方法变更为get或者getOr)。\n4.倾向于对象遍历而不是Switch语句让我们看下面这个例子，我们想根据 color 打印出水果:\njsfunction test(color) &#123;\n  // 使用条件语句来寻找对应颜色的水果\n  switch (color) &#123;\n    case &#39;red&#39;:\n      return [&#39;apple&#39;, &#39;strawberry&#39;];\n    case &#39;yellow&#39;:\n      return [&#39;banana&#39;, &#39;pineapple&#39;];\n    case &#39;purple&#39;:\n      return [&#39;grape&#39;, &#39;plum&#39;];\n    default:\n      return [];\n  &#125;\n&#125;\n\n// test results\ntest(null); // []\ntest(&#39;yellow&#39;); // [&#39;banana&#39;, &#39;pineapple&#39;]上面的代码看起来没有错误，但是我找到了一些累赘。用对象遍历实现相同的结果，语法看起来更简洁:\njsconst fruitColor = &#123;\n  red: [&#39;apple&#39;, &#39;strawberry&#39;],\n  yellow: [&#39;banana&#39;, &#39;pineapple&#39;],\n  purple: [&#39;grape&#39;, &#39;plum&#39;]\n&#125;;\n\nfunction test(color) &#123;\n  return fruitColor[color] || [];\n&#125;或者你也可以使用 Map实现相同的结果:\njs  const fruitColor = new Map()\n    .set(&#39;red&#39;, [&#39;apple&#39;, &#39;strawberry&#39;])\n    .set(&#39;yellow&#39;, [&#39;banana&#39;, &#39;pineapple&#39;])\n    .set(&#39;purple&#39;, [&#39;grape&#39;, &#39;plum&#39;]);\n\nfunction test(color) &#123;\n  return fruitColor.get(color) || [];\n&#125;Map是一种在 ES2015 规范之后实现的对象类型，允许你存储 key 和 value 的值。\n但我们是否应当禁止switch语句的使用呢？答案是不要限制你自己。从个人来说，我会尽可能的使用对象遍历，但我并不严格遵守它，而是使用对当前的场景更有意义的方式。\nTodd Motto有一篇关于 switch 语句对比对象遍历的更深入的文章，你可以在这个地方阅读\nTL;DR; 重构语法在上面的例子，我们能够用Array.filter 重构我们的代码，实现相同的效果。\njs const fruits = [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;, \n    &#123; name: &#39;strawberry&#39;, color: &#39;red&#39; &#125;, \n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;, \n    &#123; name: &#39;pineapple&#39;, color: &#39;yellow&#39; &#125;, \n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;, \n    &#123; name: &#39;plum&#39;, color: &#39;purple&#39; &#125;\n];\n\nfunction test(color) &#123;\n  return fruits.filter(f =&gt; f.color == color);\n&#125;有着不止一种方法能够实现相同的结果，我们以上展示了 4 种。\n5.对 所有&#x2F;部分 判断使用Array.every &amp; Array.some这最后一个建议更多是关于利用 JavaScript Array 的内置方法来减少代码行数。看下面的代码，我们想要检查是否所有水果都是红色:\njsconst fruits = [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n  ];\n\nfunction test() &#123;\n  let isAllRed = true;\n\n  // 条件：所有水果都是红色\n  for (let f of fruits) &#123;\n    if (!isAllRed) break;\n    isAllRed = (f.color == &#39;red&#39;);\n  &#125;\n\n  console.log(isAllRed); // false\n&#125;代码那么长！我们可以通过 Array.every减少代码行数:\njsconst fruits = [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n  ];\n\nfunction test() &#123;\n  const isAllRed = fruits.every(f =&gt; f.color == &#39;red&#39;);\n\n  console.log(isAllRed); // false\n&#125;现在更简洁了，不是吗？相同的方式，如果我们想测试是否存在红色的水果，我们可以使用 Array.some 一行代码实现。\njsconst fruits = [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n];\n\nfunction test() &#123;\n  // 条件：任何一个水果是红色\n  const isAnyRed = fruits.some(f =&gt; f.color == &#39;red&#39;);\n\n  console.log(isAnyRed); // true\n&#125;6.总结让我们一起生产更多可读性高的代码。我希望你能从这篇文章学到东西。\n这就是所有的内容。编码快乐！\n","slug":"写好JavaScript条件语句的5条守则(转)","date":"2019-03-28T06:21:57.000Z","categories_index":"","tags_index":"","author_index":"天然卷打工战士"},{"id":"7fb61ad3abf570e620c0abbb8d9991cb","title":"centos安装jdk8","content":"准备\n\n\n\n\n\n\n\n\n\n在 linux 环境下创建一个目录来安装 java如&#x2F;usr&#x2F;java\n下载安装文件\nJDK8 官网下载地址\n移动到&#x2F;usr&#x2F;java 目录，使用 wget 进行安装，需要先在网页上点击要下载的版本，然后在浏览器的下载内容里把带有带有认证信息的下载链接拷贝出来使用 wget 安装。\n命令如下:\ntxtwget https://download.oracle.com/otn-pub/java/jdk/8u191-b12/2787e4a523244c269598db4e85c51e0c/jdk-8u191-linux-x64.tar.gz?AuthParam=1544493195_05ddb141d0fd346fda735fcc6a63f5ba\n\n\n\n\n\n\n\n\n复制链接这一步速度要快，认证信息有时效\n解压文件\n\n使用 tar zxvf 命令将压缩包解压。\n接完完成后使用 rm -rf 删除掉压缩包。\n\n环境变量的配置\n这一步是把 java 配置到全局的环境变量\n\n使用 vi /etc/profile 打开profile文件\n按 i 进入编辑模式，并调整光标到最后一行\n找一个舒服的位置，把下面的内容拷贝进去，修改路径\n确认没错后按 ESC 输入:wq 保存退出\n使用 source /etc/profile 使环境变量立即生效\n\n配置文件如下:\ntxtexport JAVA_HOME=/usr/local/dev/jdk1.8.0_131 \\\\这里改成自己的路径\nexport JRE_HOME=$JAVA_HOME/jre\nexport CLASSPATH=$JAVA_HOME/lib/\nexport PATH=$PATH:$JAVA_HOME/bin最后使用 java -version 和 javac -version 来确认是否安装成功\n","slug":"centos安装jdk8","date":"2019-01-17T08:12:56.000Z","categories_index":"","tags_index":"linux,java","author_index":"天然卷打工战士"},{"id":"ee7eeb40394fd08cf916793f98d4a3ee","title":"linux安装Mysql5.7","content":"why?\n搞了个百度云服务器，装了CentOS7系统,然后发现升级到 7 以后安装 mysql 和 6 不一样，在网上找了很多资料最后终于装上了，记录一下，留着以后用。\nhow?\n\n\n\n\n\n\n\n\n\n安装的 Mysql 版本为5.7\n下载 yum 源\n官网找到对应的 yum 源 找到Red Hat Enterprise Linux 7 / Oracle Linux 7 (Architecture Independent), RPM Package 点击下载在浏览器下载记录中把下载地址拷贝下来即可。\n下载 yum 的 rpm 包\n首先创建一个目录来放安装文件\ntxtcd /usr\n\nmkdir mysql\n\ncd mysqltxtwget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm安装 rpm 包\ntxtrpm -ivh mysql57-community-release-el7-11.noarch.rpm安装 mysql 服务\ntxtyum install -y mysql-server启动服务\n在 7 中没有 service 命令，所以使用 systemctl 命令\ntxtsystemctl start mysqld查看初始密码因为 5.7 以后首次安装不允许使用空密码登录，所以会随机生成一个密码，这个密码存放在/var/log/mysqld.log\ntxtcat /var/log/mysqld.log|grep &#39;A temporary password&#39;\n2018-12-11T12:57:59.878904Z 1 [Note] A temporary password is generated for root@localhost: ESkTTaw;k0R&amp;\n// 冒号后面的就是初始密码登录并修改密码\ntxtmysql -u root -p\n\nalter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your_password&#39;;修改完密码后，重新登录测试下，就可以使用 Mysql 了\n","slug":"安装Mysql5-7","date":"2019-01-16T05:50:55.000Z","categories_index":"","tags_index":"linux,mysql","author_index":"天然卷打工战士"}]