[{"id":"65e058b963273b5b3e940e3659fb3ebc","title":"OpenGL「四」：在文件中编写Shader","content":"前面用到了Shader绘制了一个红色的三角形，但是Shader是硬编码在代码中的，虽然是OpenGL想让我们这么写的，但是在实际开发中那肯定是不靠谱的，所以这次就尝试把Shader写到独立的文件中使用。\n设计Shader文件首先先在工程目录下创建文件res/shader/Basic.shader，用于存放Shader\n\n然后把代码中硬编码的Shader代码拷贝到Basic.shader中\n#shader vertex\n#version 330 core\n\nlayout(location &#x3D; 0) in vec4 position;\n\nvoid main() &#123;\n\tgl_Position &#x3D; position;\n&#125;;\n\n\n#shader fragment\n#version 330 core\n\nlayout(location &#x3D; 0) out vec4 color;\n\nvoid main() &#123;\n\tcolor &#x3D; vec4(1.0, 0.0, 0.0, 1.0);\n&#125;;\n\n像这样在文件中可以直接像正常写代码一样写两个Shader代码，只需要像声明GLSL版本一样使用#shader fragment和#shader vertex声明一下是那个Shader就可以了，至于cherno为什么这么写而不是把Shader拆分成两个文件来写，猜测可能是因为写在一个文件中可以只需要读取和绑定一次，而代码一般来说代码体积又不会太大，一次加载到内存处理起来很快，犯不上分文件带来的两次绑定的性能消耗吧？也可能就是单纯的学习项目懒的搞复杂…\n\n\n\n\n\n\n\n特别注意\n #shader fragment和#shader vertex是自定义的用于区分Shader并不是OpenGL的定义。\n\n\n使用流加载Shader这里逻辑比较简单，主要是使用fstream来创建文件读/写流，然后循环的按行获取文件中的内容，一旦检测到包含#shader xxxx的行就检查具体的类型，确定类型后后续的行都认为是该类型的Shader代码把内容都写入到ss中存起来，最后使用结构体返回Shader的代码字符串。\n...\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n\n&#x2F;&#x2F; Shader代码结构体，包含了两个Shader的代码字符串\nstruct ShaderProgramSource &#123;\n\tstd::string vertex;\n\tstd::string fragment;\n&#125;;\n\nstatic ShaderProgramSource ParseShader(const std::string&amp; filepath) &#123;\n    &#x2F;&#x2F; 创建流并绑定文件\n\tstd::ifstream stream(filepath);\n    \n    &#x2F;&#x2F; 判断是否存在文件\n\tif (!stream.is_open()) &#123;\n\t\tstd::cout &lt;&lt; &quot;file open failed!&quot; &lt;&lt; std::endl;\n\t&#125;\n\n    &#x2F;&#x2F; 声明Shader类型枚举 \n\tenum ShaderType &#123;\n\t\tNONE &#x3D; -1, VERTEX &#x3D; 0, FRAGMENT &#x3D; 1\n\t&#125;;\n\n    &#x2F;&#x2F; 文件行数据\n\tstd::string line;\n    &#x2F;&#x2F; 字符串流，用于数据格式转换\n\tstd::stringstream ss[2];\n    &#x2F;&#x2F; Shader类型\n\tShaderType type &#x3D; ShaderType::NONE;\n    &#x2F;&#x2F; 按行获取Shader的代码\n\twhile (getline(stream, line)) &#123;\n        &#x2F;&#x2F; 如果是声明语句行，获取类型赋值给type\n\t\tif (line.find(&quot;#shader&quot;) !&#x3D; std::string::npos) &#123;\n\t\t\tif (line.find(&quot;vertex&quot;) !&#x3D; std::string::npos)\n\t\t\t\ttype &#x3D; ShaderType::VERTEX;\n\t\t\telse if (line.find(&quot;fragment&quot;) !&#x3D; std::string::npos)\n\t\t\t\ttype &#x3D; ShaderType::FRAGMENT;\n\t\t&#125;\n        &#x2F;&#x2F; 如果不是声明语句，就把当前行数据输入到字符串流中\n\t\telse &#123;\n\t\t\tss[(int)type] &lt;&lt; line &lt;&lt; &quot;\\n&quot;;\n\t\t&#125;\n\t&#125;\n    &#x2F;&#x2F; 关闭流\n\tstream.close();\n    &#x2F;&#x2F; 返回包含Shader代码字符串的结构体\n\treturn &#123;\n\t\tss[0].str(),\n\t\tss[1].str() &#x2F;&#x2F; 转换成字符串返回\n\t&#125;;\n&#125;\n...\n\n\n新的逻辑代码使用刚封装好的方法加载Shader代码\n...\n&#x2F;&#x2F; 加载Shader代码\nShaderProgramSource source &#x3D; ParseShader(&quot;res&#x2F;shader&#x2F;Basic.shader&quot;);\n&#x2F;&#x2F; 创建Shader程序\nunsigned int shader &#x3D; CreateShader(source.vertex, source.fragment);\n&#x2F;&#x2F; 使用Shader\nglUseProgram(shader);\n...\n\n再见三角形我们可以随便改改片段着色器中的颜色输出为color = vec4(1.0, 1.0, 0.0, 1.0);，再按下F5运行代码验证结果，可以看到一个黄色的三角形，证明我们已经可以正确的使用文件加载Shader代码了。\n\n","slug":"OpenGL4","date":"2021-12-29T16:00:00.000Z","categories_index":"OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"打工战士"},{"id":"7d4eb62a0f031a2c66f45b6854b89b78","title":"OpenGL「三」：你好三角形","content":"在之前的学习中，使用早期OpenGL绘制了一个三角形，以及了解了如何使用GLEW引入现代OpenGL的API,本篇就使用现代API重新的绘制一个三角形。全部代码截图放在最末尾了，留作参考。\n渲染管线渲染管线指的是渲染的工作流程，不具体指向某一个单独的过程，也不是特指某一段编程代码(如:Shader，Shader只是管线中的一个过程)，感性点的理解可以是从发送绘制指令开始到实际显示到画面里的过程，就是渲染管线，下图展示了渲染管线的各个阶段：\n\n在早期的使用的是固定管线，也就是说整个渲染管线的过程的实现都是固定的，可自定义程度有限，比如：需要开启光照，那我们就只能告诉调用线程的API来开启光照，至于光照的实现效果以及如何实现一个符合需求光照的则与程序员无关。\n在现代API中已经升级为可编程管线，可编程管线开放了部分阶段给程序员，可以使程序员更加灵活的实现项目中所需要的各种效果，而不需要付出太大的成本，上图中蓝色的部分就是可编程管线中可自定义的部分。\n了解VAO，VBO这两个概念细说起来很复杂，后面再进行深入的学习，现阶段感性的认知是：\nVBO\nVBO全称：顶点缓冲对象(Vertex Buffer Objects)，它可以在GPU中开辟一块空间用于存储大量的顶点数据，方便我们在使用时一次性发送大量的顶点数据到显卡上，提高性能。\nVAO\nVAO全称：顶点数组对象(Vertex Array Object)，一次完整的VBO的配置使犯错且复杂的，为了避免在切换不同VBO以及重复使用VBO，我们应该将VBO与VAO进行绑定，这样VAO便会记录下所需要的信息，然后在切换与重复使用时操作VAO即可。\n感性理解：一个用于记录描述VBO模型的对象，方便的切换VBO配置。\n使用VBO创建VBO\n&#x2F;&#x2F; 申请缓冲区\nunsigned int vbo; &#x2F;&#x2F; A\nglGenBuffers(1, &amp;vbo); &#x2F;&#x2F; B\nglBindBuffer(GL_ARRAY_BUFFER, vbo); &#x2F;&#x2F; C\n\n\nA行申请一个int类型变量，用于存放缓冲区的id。\nB行申请一个缓冲区对象，第一个参数表示申请数量，第二个参数是使用哪个变量来存储申请成功后的id。\nC行绑定id是vbo的缓冲区到GL_ARRAY_BUFFER类型的缓冲区上，缓冲区有很多种类型，由于我们这里是使用顶点缓冲区所以使用GL_ARRAY_BUFFER，其他缓冲区类型可以在glBindBuffer | docs.gl查看。\n绑定数据&#x2F;&#x2F; A\nfloat vertexs[6] &#x3D; &#123;\n\t-0.5f, -0.5f,\n\t0.0f,   0.5f,\n\t0.5f,  -0.5f\n&#125;;\n\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\n\n&#x2F;&#x2F; B \nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);\n\n\nA行声明绘制三角形所需要的顶点位置，类型是一个float数组，每两个数据组成三角形的一个顶点位置信息。\nB行绑定顶点数据到指定类型的的缓冲区上，第一个参数指定了绑定到GL_ARRAY_BUFFER类型的缓冲区上，第二个参数是告诉OpenGL缓冲区数据的大小，第三个参数是把实际的顶点数据传入到缓冲区中，第四个参数是缓冲区中数据的预期使用方式，有多种方式可供选择这里选择了GL_STATIC模式，其含义是数据存储内容将被修改一次并多次使用。，其他预期类型可查看:glBufferData | docs.gl。\n解释数据的用途OpenGL的顶点着色器(Vertex Shader)允许使用任何形式的输入，所以这就需要我们手动的告诉OpenGl如何去解释这些数据。\n\n   float vertexs[6] &#x3D; &#123;\n\t-0.5f, -0.5f,\n\t0.0f,   0.5f,\n\t0.5f,  -0.5f\n&#125;;\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\n\t\nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);\n\nglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);&#x2F;&#x2F; A\nglEnableVertexAttribArray(0); &#x2F;&#x2F;B\n\nA行解释OpenGL如何使用缓冲区中的数据，这个解释只对当前的VBO生效，参数含义：\n\n第一个参数，表示顶点属性索引的值，与GLSL语言有关，表明本次解释的是某一特定的索引顶点属性，只要在Shader取值时布局索引对应上即可获取期望的数据，最大16；\n属性有几个分量；\n数据所使用的数据类型；\n是否归一化；\n一个分量数据的内存大小；\n在GL_ARRAY_BUFFER 缓冲区中，属性值第一次出现偏移量。\n\nB行在配置好顶点属性后，如果需要使用需要手动开启对应索引的顶点属性，默认是关闭所有的顶点属性的。\n\n\n\n\n\n\n\n\n\n如果需要其他属性的配置，如颜色，法线等信息，可以多次调用glVertexAttribPointer函数进行解释，并使用glEnableVertexAttribArray来开启顶点属性。\n此时按下F5运行项目会发现已经重新绘制出了上一篇的白色三角形。\n使用VAOVAO可以存储绑定顶点缓冲区与顶点属性值的信息，然后再绘制物体的时候只需要绑定相应的VAO就行了，可以方便的实现绘制不同物体。\nVAO存储的信息：\n\nglEnableVertexAttribArray和glDisableVertexAttribArray的调用。\n通过glVertexAttribPointer设置的顶点属性配置。\n通过glVertexAttribPointer调用与顶点属性关联的VBO。\n\n\nVAO使用起来非常简单就像VBO的创建一样，只需要调用glGenVertexArrays获取索引，然后使用glBindVertexArray绑定即可，绑定成功后任何随后的顶点属性调用都会储存在这个VAO中。\n&#x2F;&#x2F; 申请VAO\nunsigned int vao;\nglGenVertexArrays(1, &amp;vao);\n&#x2F;&#x2F; 绑定VAO，绑定后所有的调用都会记录到当前VAO中\nglBindVertexArray(vao);\n\n\n&#x2F;&#x2F; 顶点属性调用\nunsigned int vbo;\nglGenBuffers(1, &amp;vbo);\nglBindBuffer(GL_ARRAY_BUFFER, vbo);\nglBufferData(GL_ARRAY_BUFFER, 6 * sizeof(vertexs), vertexs, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);\nglEnableVertexAttribArray(0);\n\n&#x2F;&#x2F; 绘制循环\n...\n&#x2F;&#x2F; 使用VAO\nglBindVertexArray(vao);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n...\n\n\n\n\n\n\n\n\n\n特别注意\n如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。\n\n\n再次按下F5运行项目，成功绘制出白色三角形。\n使用Shader虽然成功绘制出了白色三角形，但是现代OpenGL最厉害的特性Shader却一点没用上，下面就通过为三角形上色来入手，学习下Shader的使用。\nShader是一段代码片段，它运行在GPU上，作用是告诉GPU当前处理的图形应该如何绘制，比如：顶点在哪里，当前这个像素应该是什么样的等等，它是整个渲染管线的一部分，只不过是部分开放出来给我们自定义而已。\n\n\n\n\n\n\n粗暴理解\nShader就是OpenGL在绘制时暴露出来的回调函数，其上下文是属于OpenGL的，所以千万不要当做是我们开发程序的部分，就是一个回调函数而已。\n\n\n为什么需要Shader因为运行在GPU上效率高，比如我们需要绘制1000个像素的样色并不需要循环访问1000遍而是可以同时访问这1000个像素点。\n\n\n\n\n\n\n\n\n\n但是不能因为GPU快就把全部逻辑都交给GPU来做，很多时候还是要在CPU上计算，最后把结果一口气全部发到GPU上更快。\n顶点着色器与片段着色器常用的Shader有两个Vertex Shader(顶点着色器)和Fragment Shader(片段着色器)，它们的作用是：\n顶点着色器\n用于描述顶点的位置，在3D空间中一个点具体应该显示在哪里取决于我们如何进行观察，通过顶点着色器就可以让原始的顶点通过矩阵变换显示到屏幕中正确的位置。\n其作用对象是每一个顶点，每一个顶点会调用一次顶点着色器。\n片段着色器\n其作用对象是在确认了顶点信息后，最终会绘制到屏幕上的每一个像素点，每一个像素点会调用一次片段着色器。\n所以也可以叫做像素着色器，我觉得叫像素着色器更好理解，因为其作用就是处理绘制一个图形到屏幕时，该图形在屏幕所占面积的像素该如何显示的逻辑，操作的对象就是屏幕上图形所占面积的所有像素点，叫片段着色器总觉得词不达意，还是像素着色器更形象。\n\n\n\n\n\n\n举例说明\n在纸上画一个三角形并涂满颜色就好比我们使用Shader来绘制一个三角形： \n1.确定三角形在纸上的三个顶点在哪，对应的就是顶点着色器的工作；\n2.给三角形涂满颜色，并且确定都是什么颜色，对应的就是片段着色器的工作，只不过涂色粒度是像素而已。\n\n\n编写Shader编写Shader的过程其实和写代码是一样的，编写代码-&gt;编译代码-&gt;连接程序-&gt;喂给OpenGL，只不过这些个过程都内嵌到了我们的工程中作为代码的一部分存在，需要我们手动的来实现。\nShader代码&#x2F;&#x2F; A\nstd::string vertexShader &#x3D;\n\t&#x2F;&#x2F; B\n\t&quot;#version 330 core\\n&quot;\n\t&quot;\\n&quot;\n\t&#x2F;&#x2F; C\n\t&quot;layout(location &#x3D; 0) in vec4 position;\\n&quot;\n\t&quot;\\n&quot;\n\t&quot;void main() &#123;\\n&quot;\n\t&#x2F;&#x2F; D\n\t&quot;\tgl_Position &#x3D; position;\\n&quot;\n\t&quot;&#125;&quot;;\n&#x2F;&#x2F; E \nstd::string fragmentShader &#x3D;\n\t&quot;#version 330 core\\n&quot;\n\t&quot;\\n&quot;\n\t&quot;layout(location &#x3D; 0) out vec4 color;\\n&quot;\n\t&quot;\\n&quot;\n\t&quot;void main() &#123;\\n&quot;\n\t&#x2F;&#x2F; F\n\t&quot;\tcolor &#x3D; vec4(1.0, 0.0, 0.0, 1.0);\\n&quot;\n\t&quot;&#125;&quot;;\nA行顶点着色器\nB行声明GLSL(OpenGL为开发Shader提供的编程语言)使用的版本\nC行layout(location = 0) 确定使用哪一个索引的顶点属性对象，这个索引就是glVertexAttribPointer第一个参数设置的索引，使用一致的索引就可以获取到对应的内存布局的顶点属性。后面的in/out用于定义着色器的输入输出，这里是定义了一个名叫position的向量表示顶点位置，这个变量的值来自于顶点属性对象\nD行赋值到GLSL的内建变量上，该变量表示顶点的实际坐标\nE行片段着色器\nF行设置像素点颜色，OpenGL中颜色值使用vec4的向量表示，四个分量分别是r、g、b、a其区间在0~1\n编译着色器\nstatic int ComplieShader(unsigned int type, const std::string&amp; source) &#123;\n\t&#x2F;&#x2F; A\n\tunsigned int shader &#x3D; glCreateShader(type);\n\n\t&#x2F;&#x2F; B\n\tconst char* src &#x3D; source.c_str();\n\t&#x2F;&#x2F; C\n\tglShaderSource(shader, 1, &amp;src, nullptr);\n\t&#x2F;&#x2F; D\n\tglCompileShader(shader);\n\n\t&#x2F;&#x2F; E开始\n\tint result;\n\tglGetShaderiv(shader, GL_COMPILE_STATUS, &amp;result);\n\n\n\tif (result &#x3D;&#x3D; GL_FALSE) &#123;\n\t\tint length;\n\t\tglGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);\n\t\tchar* message &#x3D; (char*)alloca(length * sizeof(char));\n\n\t\tglGetShaderInfoLog(shader, length, &amp;length, message);\n\n\t\tstd::cout &lt;&lt; &quot;Failed to Compile&quot; &lt;&lt; (type &#x3D;&#x3D; GL_VERTEX_SHADER ? &quot;vertex&quot; : &quot;fragment&quot;) &lt;&lt; std::endl;\n\t\tstd::cout &lt;&lt; message &lt;&lt; std::endl;\n\n\t\tglDeleteShader(shader);\n\n\t\treturn 0;\n\t&#125;\n\t&#x2F;&#x2F; E结束\n\n\t&#x2F;&#x2F; F\n\treturn shader;\n&#125;\n\n\n编译着色器是一个重复的工作，所以可以封装为一个方法使用\nA行申请一个指定类型的着色器，好比于创建一个C++文件\nB行把C++风格的字符串转换为C风格的字符串，因为OpenGL是C开发的所以需要转换下\nC行给指定的着色器绑定源码，好比把代码写到文件里\nD行编译着色器，好比于把C++代码编译成.obj文件\nE区域因为Shader是运行在GPU没法直接发送消息到CPU这边，所以需要写一些代码来获取Shader编译的日志信息，如果发生了错误可以打印出错误信息供调试使用\nF行返回着色器的id\n创建着色器程序Opengl的着色器程序总会让人头晕，在程序里多了一OpenGL就够了，为什么OpenGL里又多个程序，这程序有啥用，为什么这么写之类的疑问，这里其实有几个点捋顺了会好理解很多：\n\n着色器程序类似于编译后链接各个文件的过程，它把多个单独的着色器链接在一起打包成一个整体（就好比C++能编程成.exe的可执行程序或者是.lib的链接库一样），绑定给OpenGL后，在渲染对象的时候激活这个着色器程序，我们可以先创建多个着色器程序等到需要的时候切换到特定的程序上\n OpenGL是一个巨大的状态机，所以它一定是有一个有限的逻辑变化并且根据逻辑状态的变化不停接收输入，产出输出的东西，着色器程序就是这个机器中的一个部分，当OpenGL的状态切换到计算顶点/片段信息时，就需要着色器程序这个工具来操作，所以虽然叫着色器程序但其实相当于OpenGL这个大机器中的一个小部位，甚至直接理解成动态绑定给OpenGL的一个库也不是不行\n\n\n\nstatic int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader) &#123;\n\t&#x2F;&#x2F; A\n\tunsigned int program &#x3D; glCreateProgram();\n\n\t&#x2F;&#x2F; B\n\tunsigned int vs &#x3D; ComplieShader(GL_VERTEX_SHADER, vertexShader);\n\tunsigned int fs &#x3D; ComplieShader(GL_FRAGMENT_SHADER, fragmentShader);\n\n\t&#x2F;&#x2F; C\n\tglAttachShader(program, vs);\n\tglAttachShader(program, fs);\n\n\t&#x2F;&#x2F; D\n\tglLinkProgram(program);\n\n\t&#x2F;&#x2F; E\n\tglValidateProgram(program);\n\n\treturn program;\n\n&#125;\n\n\nA行创建一个着色器程序，好比创建一个C++工程\nB行调用编译着色器代码，获取到编译后的着色器，好比获取了需要连接的.obj文件\nC行把着色器添加到着色器程序里，好比把文件添加到了工程里\nD行链接着色器到着色器程序，好比链接程序把多个.obj链接到一个.exe/.lib上，此时就像我们可以直接使用可执行程序或者运行库一样，直接使用这个着色器程序就以为着所有相关信息都能获取到\nE行校验着色器程序是否正确\n启用着色器程序在代码里我们只需要调用CreateShader并传入前面编写的Shader代码模板获取到一个可用着色器程序id，并通过glUseProgram函数启用即可。\n\n&#x2F;&#x2F; 定义CreateShader与ComplieShader函数\n\n&#x2F;&#x2F; 编写vertexShader与fragmentShader的代码\n\nunsigned int shader &#x3D; CreateShader(vertexShader, fragmentShader);\nglUseProgram(shader);\n\n\n&#x2F;&#x2F; 在绘制循环中，正常调用draw call\nglDrawArrays(GL_TRIANGLES, 0, 3);\n\n\n此时按下F5会看到一个红色的三角形，至此使用Shader编程开发一个简(复)单(杂)的三角形就完成啦。\n\n容易晕的点我们在代码中所有对OpenGL的调用都是一些命令函数，其具体过程都是在GPU中实现且最后并不会返回实际的东西回来，都是返回我们调用的函数所期望产生的对象的唯一标识id（也可能是索引）\n所以不像正常面向对象时的逻辑：\n\n我有一个缓冲区对象\n我要操作什么，缓冲区对象.xxx();\n\n而是这样：\n\n程序：GPU给我搞一个缓冲区对象\nGPU：搞完了，id是xxx\n程序：OK，GPU我有一个缓冲区对象id是xxx，帮我把它绑定到GL_ARRAY_BUFFER这个缓冲区上\nGPU：搞完了\n程序：我有一个缓冲区对象id是xxx，我要这样这样描述…\nGPU：OK\n程序：我有一个缓冲区对象id是xxx…\nGPU: OK\n\n\n参考代码\n\n在新标签页中打开查看高清图\n","slug":"OpenGL3","date":"2021-12-21T16:00:00.000Z","categories_index":"OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"打工战士"},{"id":"6160cc6d102bffa77808f7eb2e12f02e","title":"关于0.1+0.2!=0.3这件事","content":"0.1 + 0.2 === 0.3吗？在JavaScript有一个经典的面试题，那就是”0.1 + 0.2 === 0.3吗？”\n这个题看起来非常的弱智哈，只要小本毕业了肯定都秒答”必须的啊”，啊，要这么认为那这题肯定是挂了，嗯。\n然后简单敲一下，啊，还真就错了。\n\n原因是计算结果并不是正好的0.3而是0.30000000000000004\n\n很明显这是一个浮点型计算精度的问题，这就需要讨论一下JS中是如何存储数字的了。\nJS中的Number类型在JS中不区分整型和浮点型（没有int，float，double区分），所有的数字都会统一使用Number这个类型来表示；\nNumber如何存储数字的因为要兼顾整型与浮点型，所以JS中的Number类型采用的是IEEE754标准（二进制浮点数算术标准）的浮点数存储标准，这个标准也是20世纪80年代以来最广泛使用的浮点数运算标准，这个标准一共规定了4种表示浮点数值的方式其中就有我们常见的float和double两个类型：\n\nbinary32: 单精度\nbinary64: 双精度\n\n其中binary32是需要强制实现的，其他的类型都可以选择实现，JS在这里采取了binary64来实现Number类型\nbinary64的定义与内存布局数学定义IEEE754中对二进制浮点数的数学定义如下：\n\n各项的含义分别是：\n\nValue：二进制原值；\nsign(s)：符号位 取值 0，1代表正负；\nexponent(e)：阶码（指数偏移值） = 阶码真值 ± 127/1023（32/64位情况）；\nfraction(f)：尾数(分数值) = 去除最高位后的小数部分。\n\n\n\n\n\n\n\n\n\n\n对细节感兴趣的可以点击这里IEEE754 wiki（需科学上网）\n内存布局对应的内存布局\n0 |  1 0 0 0 0 0 0 0 0 0 0 | 1 | 0 0 0 0 0 0 ... 0 0 0 0\ns |  ---exponent(11bit)--- | h | ----fraction(52bit)----\n\n最高位是符号位，后面是 11 的阶码，最后是 52 位尾数，在尾数前有 1 位的隐藏位。\n这里涉及到一个概念问题，不同于我们常说的小数（十进制下），在计算机只认识[0,1]是没有小数点这个概念的，所以才会用IEEE 745来定义如何表达小数，这个方式被称作浮点数，浮点数的关键就在于这个阶码(exponent)，它表示了小数点应该在这53位尾数中的哪一位。\n要理解这个阶码先看下十进制小数转换为二进制的规则。\n十进制小数的二进制表达公式：\n其中：\n\n指数的基数是 2\n|a| &gt;= 1&amp;&amp; |a| &lt; 2 (就是永远为1)\nn 为正整数\n\n举例:\n\n对应这个结果重新看浮点数的定义\n\n阶码 对应的是 n = 2 + \n隐藏位对应的是 有效位 = 1.0\n尾数对应的是 小数部分 = 0.0111\n\n对应的内存布局\n\n测试地址 | IEEE-754 Floating Point Converter\n\n\n\n\n\n\n\n\n\n看过如何把十进制数字转换为二进制表示后可以发现二进制的小数整数位永远都是1（二进制的世界里没有0开头的数字），所以就隐藏掉了，这样还能多出来一位来表示小数位加大一点精度。\n总结0.1 + 0.2 != 0.3这个问题，其本身是小数与浮点数两个概念的带来的混淆所产生的，即：我们意识中的小数的有效位数是明确的，所以在写代码时也会下意识的认为只计算有效位的结果，而计算机并不能存储小数而是浮点数的形式进行存储，其精度不能得到保证，在这个问题中0.3作为显式定义的浮点数必然与由0.1 + 0.2计算得到的新浮点数精度不一致，导致计算结果出现错误。\n\n0.3显式声明的内存布局\n\n想要规避这个问题可以采用放大的方式来保证有效位的计算，比如所有数字乘10: 1 + 2 === 3，然后在需要的时候再还原回来即可保证精度的计算。 \n[Bonus]在其他语言中的浮点数在Java和C/C++里float使用了binary32，double使用了binary64，这两个语言中都对浮点数计算时进行了特殊的处理保证计算结果精度的正确性。\n值得一提的是在Java中如果不显示声明数字是float类型计算时也同样会产生和JS一样的bug，显式声明后则不会出现\n\njava运行结果（不显式声明为浮点型）\n\n\njava运行结果（显式声明为浮点型）\n\n\n在C++中则不存在这个问题\n\nC++运行结果\n\n\n","slug":"浮点数的定义","date":"2021-12-13T16:00:00.000Z","categories_index":"分享","tags_index":"JavaScript","author_index":"打工战士"},{"id":"48f3ebc985f2f9c9c1a27375e29f50ed","title":"OpenGL「二」：使用现代OpenGL","content":"在上一篇中我们已经使用OpenGL成功的在窗口中绘制了一个白色三角形，虽然非常简单，但是使用的代码却是OpenGL1.1版本的老代码，在2021的今天那肯定是不满足我们了，所以在这篇我们来看看如何引入现代的OpenGL API。\n现在OpenGL在哪？前面说过OpenGL的本质是一个跨平台的图形标准，并没有实现代码，其具体实现是由显卡厂商具体实现的，所以各个版本的实现都是存在于我们的GPU中，正常情况下我们是无法定位到函数的位置，我们需要一种手段获取到存在GPU中的函数的地址让我们可以正常的调用它们，常规情况下我们可以借助系统函数来实现这一需求，比如：\n...\n\n&#x2F;&#x2F; 查询名为apiName的函数\nvoid *p &#x3D; (void *) wglGetProcAddress(apiName);\n&#x2F;&#x2F; 如果p存在则调用\nif (p) &#123;\n    p();\n&#125;\n&#x2F;&#x2F; 如果没有可能还要判断是否在1.1版本中，实现兼容方案等\n...\n\n可以看到手段是很繁琐的，就算是封装为函数了也需要考虑这样那样的兼容，非常的让人头大。\n但是我们作为一个一般的开发者，要是全部的函数都封装一遍还要跟上OpenGL的版本更新，那显然是不太现实的，所以我们就需要用到一些大佬们封装的库来降低开发成本，本次使用的GLEW就是其中广泛使用的库，下面就来学习下GLEW的配置和使用。\nGLEW先来看下官网对于GLEW的描述：\nThe OpenGL Extension Wrangler Library (GLEW) is a cross-platform open-source C/C++ extension loading library. GLEW provides efficient run-time mechanisms for determining which OpenGL extensions are supported on the target platform. OpenGL core and extension functionality is exposed in a single header file. GLEW has been tested on a variety of operating systems, including Windows, Linux, Mac OS X, FreeBSD, Irix, and Solaris.\nOpenGL扩展Wrangler库（GLEW）是一个跨平台的开源C/C扩展加载库。GLEW提供了高效的运行时机制，用于确定目标平台上支持哪些OpenGL扩展。OpenGL核心和扩展功能在单个头文件中公开。GLEW已经在多种操作系统上进行了测试，包括Windows、Linux、Mac OS X、FreeBSD、Irix和Solaris。\n根据官网的描述，可以知道GLEW是一个高效的确定目标平台上支持那些OpenGL的扩展，使用这个库可以保证我们平台无关的获取到想要的API，这里就包括我们说的现代API。\n这就是库就非常好的地方，就像JQuery之于前端一样，可以让我们完全的从各种版本和平台的兼容性中解放出来，专注于开发业务，而不是去写那无穷尽的hack。\n配置GLEW环境1.首先下载GLEW库\nGLEW下载地址\n\n\n\n\n\n\n\n\n\n\n这里下载编译好的包即可，如果是开发项目可以选择下载源码方便进行调试。\n2.解压文件\n\n3.VS中的配置\n3.1添加到工程\n把解压好的文件夹复制到工程的\\Dependencies下\n3.2配置\n配置附加目录\n\n配置附加依赖库\n\n配置附加依赖项\n\n由于GLEW在运行时区分动态库和静态库，所以我们还需要配置一下宏，\n\nGLEW_STATIC：静态库宏\nGLEW_BUILD：动态库宏\n\n\n右键点击工程-&gt;C/C++-&gt;预处理器-&gt;预处理器定义\n\n编写测试代码我们使用GLEW调用glGenBuffers函数并打印当前OpenGL版本号来进行测试。\n#include &lt;iostream&gt;\n&#x2F;&#x2F; 引入GLEW\n#include &lt;GL&#x2F;glew.h&gt;\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\nint main(void)\n&#123;\n\tGLFWwindow *window;\n\n    &#x2F;&#x2F; ... 省略窗口创建过程\n\n\t&#x2F;* Make the window&#39;s context current *&#x2F;\n\tglfwMakeContextCurrent(window);\n    &#x2F;&#x2F; 初始化GLEW\n\tif (glewInit() !&#x3D; GLEW_OK)\n\t&#123;\n\t\tstd::cout &lt;&lt; &quot;GLEW is Error&quot; &lt;&lt; std::endl;\n\t&#125;\n\t&#x2F;&#x2F;申请缓冲区\n\tunsigned int a;\n\tglGenBuffers(1, &amp;a);\n\t&#x2F;&#x2F;打印OpenGL版本\n\tstd::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;\n    &#x2F;&#x2F;  ...省略绘制b部分\n \n\tglfwTerminate();\n\treturn 0;\n&#125;\n\n运行结果\n\nQ&amp;Agl.h included before glew.h\n\n\n\n\n\n\n\n\n\n通过查阅官网的Usage可以得知，在调用glewInit前需要先创建一个有效的OpenGL渲染上下文，所以调用时间应在glfwMakeContextCurrent函数后再调用。\n无法解析的外部符号 __imp__glewInit@0，函数 _main 中引用了该符号\n\n\n\n\n\n\n\n\n\n没有定义宏。\n","slug":"OpenGL2","date":"2021-12-10T16:00:00.000Z","categories_index":"OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"打工战士"},{"id":"8d43fa0304d1f9bd1b2ad6d1921fba3a","title":"OpenGL「一」：使用C++编写第一个OpenGL窗口程序","content":"环境准备\nVS2019\nGLFW\n\n下载GLFW一个轻量级的，开源的，跨平台的library。支持OpenGL及OpenGL ES，用来管理窗口，读取输入，处理事件等功能。需要这个库的原因是OpenGL本身只是标准，所以并没有提供窗口管理的功能，所以需要使用工具来帮助我们开发，而GLFW就是其中不错的选择。\n\n\n\n\n\n\n\n\n\nGLFW名称具体含义没有查到，但是看功能应该是OpenGl for window，这里window不是指windows系统而是应用程序窗口的window。\n下载GLFW官方下载地址\n\n选择下载32位的程序\n下载完成后解压文件，这里我们主要关注include和lib-vs2019两个目录，分别是头文件位置和链接库位置。\n\n\n\n\n\n\n\n提示\n如果使用的不是VS2019，选择对应版本的即可。\n\n\n在VS中创建C++工程打开VS，点击创建新项目-&gt;C++空项目点击下一步，起名OpenGL并选择好工程目录后点击创建。\n\n工程创建成功后，点击红框按钮切换视图并创建src文件夹以及Application.cpp文件\n\n输入以下代码，按F5，测试工程是否能正常启动\n#include &lt;iostream&gt;\n\nint main(void) &#123;\n\tstd::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;\n\tstd::cin.get();\n&#125;\n\n确认启动正常后，复制GLFW的示例代码到Application.cpp中\n官方示例地址\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\nint main(void)\n&#123;\n    GLFWwindow* window;\n\n    &#x2F;* Initialize the library *&#x2F;\n    if (!glfwInit())\n        return -1;\n\n    &#x2F;* Create a windowed mode window and its OpenGL context *&#x2F;\n    window &#x3D; glfwCreateWindow(640, 480, &quot;Hello World&quot;, NULL, NULL);\n    if (!window)\n    &#123;\n        glfwTerminate();\n        return -1;\n    &#125;\n\n    &#x2F;* Make the window&#39;s context current *&#x2F;\n    glfwMakeContextCurrent(window);\n\n    &#x2F;* Loop until the user closes the window *&#x2F;\n    while (!glfwWindowShouldClose(window))\n    &#123;\n        &#x2F;* Render here *&#x2F;\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        &#x2F;* Swap front and back buffers *&#x2F;\n        glfwSwapBuffers(window);\n\n        &#x2F;* Poll for and process events *&#x2F;\n        glfwPollEvents();\n    &#125;\n\n    glfwTerminate();\n    return 0;\n&#125;\n\n此时代码会全是异常，无法运行，所以开始配置GLFW环境。\n配置GLFW环境首先，打开工程目录并在当前项目的上一级也就是解决方案的目录下(包含OpenGL.sln文件的目录)创建文件夹Dependencies用于存放各种依赖库。\n创建好Dependencies文件夹后，再创建GLFW文件夹，并把之前下载的GLFW压缩包中的include和lib-vc2019文件夹复制到Dependencies\\GLFW下\n\n同时由于我们希望GLFW库是静态链接到我们的项目中，所以lib-vc2019文件夹中的glfw3.dll和glfw3dll.lib都可以删除掉，保持项目的干净。\n\n第二步，右键点击工程-&gt;属性打开属性页。\n\n然后点击C/C++-&gt;常规-&gt;附加包含目录配置包含目录为Dependencies\\GLFW\\include目录\n\n第三步，类似附加包含目录我们继续配置链接器的目录\n点击链接器-&gt;常规-&gt;附加库目录配置包含目录为Dependencies\\GLFW\\lib-vc2019目录\n\n再选择链接器-&gt;输入-&gt;附加依赖项，添加glfw3.lib作为附加库\n\n至此回到Application.cpp按F7间编译会发现没有报错了，再次按下F5可以正确的弹出OpenGL窗口。\n\n绘制第一个三角形为了体验OpenGL所以这里简单绘制了一个三角形在窗口中，代码如下：\n#include &lt;GLFW&#x2F;glfw3.h&gt;\n\nint main(void) &#123;\n\t...\n\t&#x2F;* Loop until the user closes the window *&#x2F;\n\twhile (!glfwWindowShouldClose(window)) &#123;\n\t\t&#x2F;* Render here *&#x2F;\n\t\tglClear(GL_COLOR_BUFFER_BIT);\n        &#x2F;&#x2F; 绘制三角形\n\t\tglBegin(GL_TRIANGLES);\n\n\t\tglVertex2f(-0.5f, -0.5f);\n\t\tglVertex2f(0.0f, 0.5f);\n\t\tglVertex2f(0.5f, -0.5f);\n\n\t\tglEnd();\n        &#x2F;&#x2F; 绘制结束\n        ...\n\t&#125;\n    ...\n\treturn 0;\n&#125;\n\n启动项目可以看到一个白色的三角形在窗口中央\n\n\n\n\n\n\n\n\n特别注意\n这里绘制三角形的代码使用的是已经淘汰的legacy OpenGL(早期的固定管线时期)代码，并非是现代OpenGL语法，这里仅供展示用。\n\n\n至此关于GLFW的环境就全部搭建完毕了，以后会在此基础上开始后面的学习。\n\n[Bonus]关于链接器Cherno在这里进行了一个演示，就是把附加依赖项中的附加库全部删除掉了，只添加glfw3.lib作为附加库，此时代码不会报错，但是按下F5后在链接阶段会报很多错\n\n这是由于缺少一些系统依赖库所导致的，面对这种情况只需要报错信息中蓝框中的部分（_之后，@之前）复制出来到百度搜索一下就可以很快的找到解决方案（其实就是微软官方文档）\n\n点击进入文档后，滑动到最下面，找到对应的库名重新添加到附加依赖项即可\n\n此例中报错原因是缺少User32.lib所导致的，所以将其添加到附加依赖项就可以解决问题。\n","slug":"OpenGL1","date":"2021-12-06T16:00:00.000Z","categories_index":"OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"打工战士"},{"id":"9297302560a828b99950be98432fa02c","title":"OpenGL「零」：什么是OpenGL","content":"\n\n\n\n\n\n提示\n本系列内容全部来自Cherno的OpenGL系列视频，是对该系列内容的一个学习和总结，这个系列视频的目的是学习OpenGL的使用和思想，可能会使用非现代OpenGL的内容同时并不会实际开发一些可投入生产的库，所以代码仅供参考。\n\n\n什么是OpenGLOpenGL一般被认为是一套跨平台的图形开发API，本质上是一套标准，所以和类似编程语言的标准一样OpenGL是没有代码实现的，其具体实现由显卡厂商进行实现。\nOpenGL规范只是严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现的，将由OpenGL库的开发者自行决定。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配即可。\n正是由于具体实现由显卡厂商进行实现，所以在实际场景中各家显卡对OpenGL的支持以及实现方式都有所不同，导致同样的代码在不同显卡上会有不同表现，甚至是出现Bug。\n\n\n\n\n\n\n\n\n\n虽然OpenGL中带个Open字样，因为只是标准没有实现，同时具体实现都是由显卡厂商提供，而显卡厂商根本不会把自家驱动开源出来，所以其实根本没有开源一说。\n其他竞品其他图形API还有诸如Direct3D、Vulkan、Metal等。\n优缺点Metal苹果独占，抬走下一位。\nDirect3D优点\n微软开发，Win平台自带，所以对Win平台极度优化，API友好，在Win上的不二之选，同时可以使用C#开发，上手门槛也并不高。\n缺点\n不支持跨平台，Win独占\nVulkan优点\n和OpenGL同门，是最新一代的API，同样支持跨平台\n缺点\n出现时间比较晚，没有OpenGL，D3D这么成熟；上手难度高，需要有一定的功底才能玩的明白(菜鸡劝退)。\n为什么还是选择OpenGL对比OpenGL这些API的缺点，OpenGL上手难度适中，在可跨平台上也比较成熟，所以综合来说是成本最小的一个，所以在选择它来入门是非常合适的。\n\n\n\n\n\n\n提示\n对于实际项目相对于直接使用OpenGL的API而言，很多人会把API封装成D3D风格，这样就能又使用OpenGL又能有一个人性化的API来使用了。\nps: 如果目标平台只有Win，那么大可不必用OpenGL找罪受，直接D3D起飞更合适。\n\n\n","slug":"OpenGL0","date":"2021-12-05T16:00:00.000Z","categories_index":"OpenGL","tags_index":"游戏开发,图形开发,OpenGL","author_index":"打工战士"},{"id":"36c783b7f07c9ef5c2531a5b03a12c76","title":"享元模式","content":"描述享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。\n通俗的说就是把相似对象的通用部分进行抽离成为元对象，并在原对象中进行引用，此时所有对象持有的元对象指针都指向同一内存地址，所以大大减少内存开销。\n\n\n\n\n\n\n\n\n\n注意，共享的元对象应只包括上下文无关的属性，也就是说不包含任何状态的通用属性。\n应用场景存在大量相似对象时的内存溢出和效率问题。\n游戏中的实例\n瓷砖地图\n重复物体渲染\n\n模式角色\n共享元对象（meta-object）存放不包含任何状态的属性；\n元对象工厂（factory）创建并缓存元对象；\n实体类（entity）存放具有状态的属性，并持有元对象指针。\n\n","slug":"享元模式","date":"2020-08-17T16:00:00.000Z","categories_index":"设计模式","tags_index":"设计模式,游戏设计模式","author_index":"打工战士"},{"id":"5bb8772a21d2fa7313e330cd8614eb64","title":"v8如何存储对象属性","content":"v8中属性的存放分为快慢属性两种，如果是数字索引则会分配在elements属性中使用线性查询，如果是慢属性则要复杂一些：当属性个数少于10个（这个数字可能根据对象申请时空间而变化）则这些属性会分配到对象内空间；如果属性个数多于10个则会把多出来的属性放到properties属性中并使用线性方式存储；如果多于10个且远远多于10个则会将多出来的属性存储在properties上并使用非线性的存储方式（词典）\n思考题：为什么不推荐使用delete删除属性?\n原因1 delete并不是直接释放内存，而是切断引用从而间接的达到内存释放。原因2 因为线性存储查改快，增删慢的特点，所以在使用delete的情况下，会从快慢属性的列表中移除该属性，导致线性存储触发增删操作，降低效率。原因3 因为delete会移除快慢属性，所以在操作慢属性时，如果属性个数在临界值，可能会在增删的同时触发存储结构的重排（字典变化为线性）导致消耗更多的性能。\n","slug":"v8如何存储对象属性","date":"2020-08-14T16:00:00.000Z","categories_index":"V8","tags_index":"JavaScript","author_index":"打工战士"},{"id":"51d32e32729eed215a5d3851fb64aa7c","title":"发布订阅模式与观察者模式的区别","content":"角色上的区别观察者模式:\n\nsubject(被观察者)\nobserver(观察者)\n\n发布订阅模式:\n\nPublisher(发布者)\nSubscriber(订阅者)\nBroker(中介人)\n\n对于观察者(订阅者)的区别观察者模式:\n直接存储在被观察者中，由被观察者直接的遍历通知观察者，对于某一被观察者而言需要维护自身的全部观察者。\n发布订阅模式:\n所有的订阅者通过订阅一个或多个topic(主题)的方式讲自身注册到中介人中。\n对于被观察者(发布者)的区别观察者模式:\n在自身中存储全部的观察者对象，对于某一被观察者而言需要维护自身的全部观察者的监听状态。\n发布订阅模式:\n发布者不需要持有订阅者对象，只需要持有中介人对象即可，发布者可以不关心订阅者的存在与具体状态。\n状态发生改变时的区别观察者模式:\n由被观察者直接遍历所有观察者并发送通知。\n发布订阅模式:\n发布者只需要告诉中介人自己需要更新那个topic(主题)即可，由中介人遍历通知所有订阅了该主题的订阅者。\n总结发布订阅与观察者相似，但区别在于观察者模式中，subject(被观察者)、observer(观察者)都是派生自基类之中，其中被观察者直接持有观察者的指针，当被观察者状态发生改变时，由自身遍历所有观察者并发出通知。而在发布订阅模式中则是多出一个中介人(broker)的角色与topic(主题)来进行消息的分发，也就是说当Publisher(相当于被观察者)发生变化时主动的调用中介人类并告知中介人自己要更新哪个主题下的状态此后由中介人来查找对应的主题下的Subscriber(相当于观察者)进行状态的更新，而Subscriber也只需要把自身注册到中介人中并告知中介人自己需要订阅哪些主题即可，此时订阅者与发布者只知道中介人存在而不知道彼此的存在。\n","slug":"发布订阅模式与观察者模式的区别","date":"2020-08-12T16:00:00.000Z","categories_index":"设计模式","tags_index":"设计模式","author_index":"打工战士"},{"id":"cd55e9d94b94ab2ca447027ce4beeca6","title":"观察者模式","content":"描述观察者模式通过“主题”与“观察者”以低耦合的方式来解决对象间存在的一对多关系，如某一对象状态发生改变时，对其他依赖组件发送通知并自动更新。\n应用场景具有一对多关系且需要同时更新的场景\n游戏中的实例\n数据变化与ui的绑定\n成就系统\n\n\n\n\n\n\n\n\n思考题: 观察者模式与发布订阅的区别\n\n\n模式中的角色\nsubject(被观察者、主题)是一个基类，包含notify、addObjserver、removeObserver等接口，用来注册观察者，并在状态发生改变时通知所有观察者;\nobserver(观察者)是一个基类，包含update接口，将自身注册到被观察者类中，并在收到通知后进行状态的更新。\n\n","slug":"观察者模式","date":"2020-08-11T16:00:00.000Z","categories_index":"设计模式","tags_index":"设计模式,游戏设计模式","author_index":"打工战士"},{"id":"35b7e7d45f0bf660fac88351c60754e3","title":"命令模式","content":"描述命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n应用场景gui 交互时可以使用。\n\n快捷键所触发的指令\ncmd类指令式交互界面\n\n游戏中的实例\n回放功能: 只需要记录指令栈即可；\n宏命令功能: 将指令进行压缩，变成一个指令队列顺序执行；\n撤销（上一步）功能: 在命令中添加undo接口，并记录最后一次状态改变的值；\n键盘按键释放技能: 按下指定按键时，触发指定命令请求指定功能；\n技能按键绑定。\n\n模式角色\n指令基类（command）\n\n接收器（received）\n\n请求发生器（invoker）\n\n具体命令，继承自指令基类（ConcreteCommand）\n\n\n实现接收器，收音机\npublic class AudioPlayer &#123;\n    public void play() &#123;\n        System.out.println(&quot;播放...&quot;);\n    &#125;\n    public void rewind() &#123;\n        System.out.println(&quot;倒带...&quot;);\n    &#125;\n    public void stop() &#123;\n        System.out.println(&quot;停止...&quot;);\n    &#125;\n&#125;\n\n命令基类\npublic interface Command &#123;\n    &#x2F;**\n     * 执行方法\n     *&#x2F;\n    void execute();\n&#125;\n\n命令具体实现类\npublic class PlayCommand implements Command &#123;\n    private AudioPlayer myAudio;\n    public PlayCommand(AudioPlayer audioPlayer) &#123;\n        myAudio &#x3D; audioPlayer;\n    &#125;\n    &#x2F;**\n     * 执行方法\n     *&#x2F;\n    @Override\n    public void execute() &#123;\n        myAudio.play();\n    &#125;\n&#125;\n\npublic class RewindCommand implements Command &#123;\n    private AudioPlayer myAudio;\n    public RewindCommand(AudioPlayer myAudio) &#123;\n        this.myAudio &#x3D; myAudio;\n    &#125;\n    @Override\n    public void execute() &#123;\n        myAudio.rewind();\n    &#125;\n&#125;\n\n请求发生器，键盘输入\npublic class Keypad &#123;\n    private Command playCommand;\n    private Command rewindCommand;\n    private Command stopCommand;\n    public void setPlayCommand(Command playCommand) &#123;\n        this.playCommand &#x3D; playCommand;\n    &#125;\n    public void setRewindCommand(Command rewindCommand) &#123;\n        this.rewindCommand &#x3D; rewindCommand;\n    &#125;\n    public void setStopCommand(Command stopCommand) &#123;\n        this.stopCommand &#x3D; stopCommand;\n    &#125;\n    &#x2F;**\n     * 执行播放方法\n     *&#x2F;\n    public void play() &#123;\n        playCommand.execute();\n    &#125;\n    &#x2F;**\n     * 执行倒带方法\n     *&#x2F;\n    public void rewind() &#123;\n        rewindCommand.execute();\n    &#125;\n    &#x2F;**\n     * 执行播放方法\n     *&#x2F;\n    public void stop() &#123;\n        stopCommand.execute();\n    &#125;\n&#125;\n\n客户端调用\npublic class Julia &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建接收者对象\n        AudioPlayer audioPlayer &#x3D; new AudioPlayer();\n        &#x2F;&#x2F; 创建命令对象\n        Command playCommand &#x3D; new PlayCommand(audioPlayer);\n        Command rewindCommand &#x3D; new RewindCommand(audioPlayer);\n        Command stopCommand &#x3D; new StopCommand(audioPlayer);\n        &#x2F;&#x2F; 创建请求对象\n        Keypad keypad &#x3D; new Keypad();\n        keypad.setPlayCommand(playCommand);\n        keypad.setRewindCommand(rewindCommand);\n        keypad.setStopCommand(stopCommand);\n        &#x2F;&#x2F; 测试\n        keypad.play();\n        keypad.rewind();\n        keypad.stop();\n        keypad.play();\n        keypad.stop();\n    &#125;\n&#125;\n\n","slug":"命令模式","date":"2020-08-04T16:00:00.000Z","categories_index":"设计模式","tags_index":"设计模式,游戏设计模式","author_index":"打工战士"},{"id":"4733d01d48a0a10d2db65c3579578d4b","title":"MonoGame Nez分辨率切换ui定位不准","content":"在设置Stage.IsFullScreen属性为true时，切换分辨率会导致ui点击位置发生偏移，所以只需要把该属性设置为false或者不设置即可。\n在设置Canvas.IsFullScreen属性为true时，在原分辨率下ui点击位置同样发生偏移，同时在切换分辨率时ui的定位也会发生偏移，所以只需要把该属性设置为false或者不设置即可。\n","slug":"MonoGame Nez分辨率切换ui定位不准","date":"2020-06-18T16:00:00.000Z","categories_index":"MonoGame","tags_index":"游戏开发,MonoGame,Nez","author_index":"打工战士"},{"id":"e045146adaed8a16cc8d2f3b3398f352","title":"MonoGame Nez跟随角色与固定UI","content":"摄像机跟随角色框架提供了FollowCamera摄像机来方便的创建跟随摄像机，只需要传入一个实体即可实现对该实体的跟踪。\nCamera.Entity.AddComponent(new FollowCamera(soneEntity));\n\n在使用了这个摄像机后UI组件会出现虽然显示在正确的位置但是并不能正确响应的问题，该问题的原因是在不使用任何渲染器的情况下，UI组件也会被摄像机进行了视口与游戏世界的坐标转换，导致UI看似显示正常但是不能正确响应交互的现象，为了解决这个问题我们需要把UI与游戏世界使用不同渲染器分开渲染来达到目标效果，下面就通过使用ScreenSpaceRenderer渲染器来解决这个问题。\n固定UIScreenSpaceRenderer渲染器\n\n\n\n\n\n\n\n\n\nRenderer that renders using its own Camera which doesnt move.\n使用一个渲染器，渲染器拥有自己的摄像机，该摄像机不会进行移动。\n通过渲染器的描述我们能发现这个渲染器在渲染时拥有自己的摄像机并且该摄像机也不会进行移动，正好符合我们的要求所以我们尝试用这个渲染器来进行UI的渲染。\n下面开始搞起来。\n添加一个ScreenSpaceRenderer到场景中。\n\n&#x2F;&#x2F; ScreenSpaceRenderer(int renderOrder, params int[] renderLayers)\n&#x2F;&#x2F; renderOrder: 渲染器的渲染时的顺序\n&#x2F;&#x2F; renderLayers: 使用此渲染器渲染时的层级，如果组件设置的RenderLayer不在列表中则不会被这个渲染器渲染，而是被默认渲染器渲染\n\nAddRenderer(new ScreenSpaceRenderer(1, 1, 2));\n\n设置RenderLayer(渲染层)\n\nvar Canvas &#x3D; CreateEntity(&quot;Canvas&quot;).AddComponent&lt;UICanvas&gt;(new UICanvas());\nCanvas.RenderLayer &#x3D; 1;\n&#x2F;&#x2F; draw UI\n\nRenderLayer并不是所有组件都会有RenderLayer属性，只有集成在RenderableComponent的组件才会有这个属性, 如UICanvas组件\npublic class UICanvas : RenderableComponent, IUpdatable\n\n\n\n","slug":"MonoGame Nez跟随角色与固定UI","date":"2020-06-17T16:00:00.000Z","categories_index":"MonoGame","tags_index":"游戏开发,MonoGame,Nez","author_index":"打工战士"},{"id":"acf46439f7beafe8650eed8a03f181c0","title":"MonoGame官方文档(二)","content":"添加内容这部分内容会添加内容到我们的游戏中去，有关于项目的创建可以参考创建新项目，我们现在需要一些内容放置到我们的游戏中去，对于本教程我们使用下面这个球：\n\n点击鼠标”右键-&gt;图片另存为”命名为ball.png并保存到任意文件夹。\n现在打开项目文件夹并看向左边(也可能是右边)，找到”解决方案资源管理器”窗口。展开content文件夹然后双击打开Content.mgcb文件。\n\n我们现在可以看到MGCB编辑器窗口已经打开，如果没有正确打开，需要用”右键-&gt;打开方式-&gt;MonoGame Pipeline Tool”方式打开。\n\n游戏中的内容都是通过这个外部工具来进行管理的。可以通过一下方式为游戏添加内容：\n\n在工具栏的”Add Existing Item”按钮\n在菜单栏的”Edit &gt; Add &gt; Existing Item…”\n在左侧菜单中”right-click &gt; Add &gt; Existing Item…”按钮\n\n现在我们使用工具栏中的”Add Existing Item”按钮来添加内容。\n\n现在会出现一个选择文件的提示框。选择刚才下载”ball.png”。选择后系统将会询问添加文件是的策略，可以选择设置为默认，然后点击”确定”即可。\n\n现在点击工具栏上的”保存”按钮，然后关闭工具。\n\n现在我们已经把资源引入进来了，现在我们来加载它们。首先我们先声明一个变量，这让我们可以图片加载到内存中。\npublic class Game1 : Game\n&#123;\n    Texture2D ballTexture;\n\n    GraphicsDeviceManager graphics;\n\n接下来找到LoadContent函数并初始化ballTexture变量：\nprotected override void LoadContent()\n&#123;\n    &#x2F;&#x2F; Create a new SpriteBatch, which can be used to draw textures.\n    spriteBatch &#x3D; new SpriteBatch(GraphicsDevice);\n\n    &#x2F;&#x2F; TODO: use this.Content to load your game content here\n    ballTexture &#x3D; Content.Load&lt;Texture2D&gt;(&quot;ball&quot;);\n&#125;\n\n最后找到Draw方法，然后将球绘制到屏幕上：\nprotected override void Draw(GameTime gameTime)\n&#123;\n    graphics.GraphicsDevice.Clear(Color.CornflowerBlue);\n\n    &#x2F;&#x2F; TODO: Add your drawing code here\n    spriteBatch.Begin();\n    spriteBatch.Draw(ballTexture, new Vector2(0, 0), Color.White);\n    spriteBatch.End();\n\n    base.Draw(gameTime);\n&#125;\n\n现在启动项目，可以看到下图：\n\n","slug":"MonoGame官方文档(二)","date":"2020-06-11T16:00:00.000Z","categories_index":"MonoGame","tags_index":"游戏开发,MonoGame","author_index":"打工战士"},{"id":"5f6f6649742c70ec6ba94bdb691b49e4","title":"MonoGame官方文档(一)","content":"了解代码引用包using Microsoft.Xna.Framework;\nusing Microsoft.Xna.Framework.Graphics;\nusing Microsoft.Xna.Framework.Storage;\nusing Microsoft.Xna.Framework.Input;\n\n这些是使用MonoGame 时的一些必要的包。\n之所以使用Microsoft.Xna.Framework框架是，因为MonoGame是Xna的开源实现，并且为了兼容Xna使用了与之相同的命名空间。\nGame1 类public class Game1 : Game\n\n类Game1继承自Game类，Game提供了游戏框架全部的核心方法（加载/卸载内容，刷新，绘制等）。通常情况下一个游戏只有一个Game类，所以此类的命名显得并不是那么重要。\n构造器public Game1()\n&#123;\n    graphics &#x3D; new GraphicsDeviceManager(this);\n    Content.RootDirectory &#x3D; &quot;Content&quot;;\n&#125;\n\n在构造函数里我们通常会初始化一些起始变量。在这里我们为我们的游戏创建了一个新的GraphicsDeviceManager（图形设备管理器），并为其设置一个了资源文件夹。\n初始化方法protected override void Initialize()\n&#123;\n    &#x2F;&#x2F; TODO: Add your initialization logic here\n\n    base.Initialize();\n&#125;\n\n初始化方法在构造函数后游戏循环（刷新与绘制）前进行调用，在这里可以加载任何服务和非图形资源。\nLoadContent方法protected override void LoadContent()\n&#123;\n    &#x2F;&#x2F; Create a new SpriteBatch, which can be used to draw textures.\n    spriteBatch &#x3D; new SpriteBatch(GraphicsDevice);\n\n    &#x2F;&#x2F; TODO: use this.Content to load your game content here\n&#125;\n\n此方法Initialize方法后游戏循环之前调用，用于加载我们的游戏内容，只会在每次游戏启动后调用一次。\nUpdate方法protected override void Update(GameTime gameTime)\n&#123;\n    if (GamePad.GetState(PlayerIndex.One).Buttons.Back &#x3D;&#x3D; ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape))\n        Exit();\n\n    &#x2F;&#x2F; TODO: Add your update logic here\n\n    base.Update(gameTime);\n&#125;\n\n每秒调用多次，并用于刷新游戏中的状态（碰撞检查，输入收集，播放音频等）。\nDraw方法\nprotected override void Draw(GameTime gameTime)\n&#123;\n    graphics.GraphicsDevice.Clear(Color.CornflowerBlue);\n\n    &#x2F;&#x2F; TODO: Add your drawing code here\n\n    base.Draw(gameTime);\n&#125;\n\n\n和Update相同也是每秒调用多次（用于绘制资源到窗口中）。\n","slug":"MonoGame官方文档(一)","date":"2020-06-09T16:00:00.000Z","categories_index":"MonoGame","tags_index":"游戏开发,MonoGame","author_index":"打工战士"},{"id":"762d57d23f302a5afc8450b6572a5c7f","title":"文档导航","content":"前端开发\nJavaScript/node.js\n\n现代 JavaScript 教程\nnodejs中文网\nkoa2官方文档\neggjs官方文档\nw3school\n阮一峰博客\nES6 入门教程\nMDN\nloadash文档\n\n\n前端工程化\n\nBabel官网\nwebpack官方文档\nnpm官方网站\nyarn中文网\n\n\nvue.js\n\nvue官方文档\nvue-cli官方文档\nvuex官方文档\nvue-router官方文档\nvue官方社区\nant-design-vue官方文档\naxios看云文档\n\n\n微信小程序\n\n小程序官方文档\n\n\n其他前端文档\n\necharts文档\nmomentjs文档\n\n\n\n游戏开发\nunity3d文档\n\n社区论坛\nV2EX\n掘金\n逼乎\n独立精神\n\n图片素材\n图片素材\n\n","slug":"文档导航","date":"2020-03-16T09:03:15.000Z","categories_index":"工具","tags_index":"","author_index":"打工战士"},{"id":"80fa170694c2738a195b06ce828cfe4a","title":"LeetCode：整数反转","content":"LeetCode第7号问题：整数反转\n题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例：\n输入: 123\n输出: 321\n\n输入: -123\n输出: -321\n\n输入: 120\n输出: 21\n\n注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n解法（java）每次弹出数字’x’最后一位，并压入到’res’的后面，全部压入后，’x’与’res’即完全相反；\n在不使用数据结构的情况下可以借助数学方法来实现“弹出/压入”的操作：\n&#x2F;&#x2F; 弹出\npop &#x3D; x % 10\nx &#x2F;&#x3D; 10\n\n&#x2F;&#x2F; 压入\ntemp &#x3D; y * 10 + pop\ny &#x3D; temp \n\n\n\n\n\n\n\n\n\n此方式有溢出风险，使用时应注意每次反转后是否溢出。\n反转后数字的溢出情况可以使用Integer.MAX_VALUE和Integer.MIN_VALUE来实现\n参考代码：\nclass Solution &#123;\n    public int reverse(int x) &#123;\n        long res &#x3D; 0;\n        while(x !&#x3D; 0) &#123;\n            res &#x3D; res * 10 + x % 10;\n            x &#x2F;&#x3D; 10;\n        &#125;\n        return res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE ? 0 : (int)res;\n    &#125;\n&#125;\n\n\n\n\n","slug":"LeetCode：整数反转","date":"2020-02-29T13:39:30.000Z","categories_index":"算法学习","tags_index":"","author_index":"打工战士"},{"id":"62f4259c1d3df5765faf228a85e43d10","title":"js实现选择排序","content":"\n\n\n\n\n\n\n\n\n选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。\n算法思路\n使用线性查找当前待排序数据，找到最小值\n把最小值移动到数组最左边\n重复1、2步，直到数组全部完成排序\n\n代码实现方式一：\n使用递归实现，一次循环比较好读，容易理解，但效率较循环低一些\nconst unsort &#x3D; [6, 1, 7, 8, 9, 3, 5, 4, 2]\n\nconst selectedSort &#x3D; (arr, index &#x3D; 0) &#x3D;&gt; &#123;\t\n    let min &#x3D; arr[index]\n\n    const len &#x3D; arr.length\n\n    for (let i &#x3D; index; i &lt; len; i++) &#123;\n        const temp &#x3D; arr[i]\n        if (temp &lt; min) &#123;\n            arr[index] &#x3D; temp\n            arr[i] &#x3D; min\n            min &#x3D; temp\n        &#125;\n    &#125;\n\n    if (index &#x3D;&#x3D;&#x3D; len - 1) &#123;\n        return arr\n    &#125;\n    return selectedSort(arr, index + 1)\n&#125;\n\nconst sorted &#x3D; selectedSort(unsort)\n\nconsole.log(sorted)\n\n&#x2F;&#x2F; console: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n\n\n方式二：\n使用循环实现，两次循环，比较不好读，逻辑容易出现纰漏，效率比递归要高\nconst unsort &#x3D; [6, 1, 7, 8, 9, 3, 5, 4, 2]\n\nconst selectedSort &#x3D; (arr) &#x3D;&gt; &#123;\n    const len &#x3D; arr.length\n    let min\n    let temp\n    for (let i &#x3D; 0; i &lt; len; i++) &#123;\n        min &#x3D; arr[i]\n        temp\n        for (let j &#x3D; i + 1; j &lt; len; j++) &#123;\n            if (arr[j] &lt; min) &#123;\n                temp &#x3D; min\n                min &#x3D; arr[j]\n                arr[j] &#x3D; temp\n                arr[i] &#x3D; min\n            &#125;\n        &#125;\n    &#125;\n    return arr\n&#125;\n\nconst sorted &#x3D; selectedSort(unsort)\n\nconsole.log(sorted)\n\n&#x2F;&#x2F; console: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n\n\n理解选择排序使用线性方式来查找最小值，所以每次循环都会比较n-m(m为循环次数)个数，直到最后一轮只比较一个数字，因此复杂度是（n - 1）+ (n - 2) + (n - 3) … + 1 ≈ n^2^ / 2, 忽略非重要项后为O(n^2^)\n","slug":"js实现选择排序","date":"2020-01-04T14:00:07.000Z","categories_index":"算法学习","tags_index":"","author_index":"打工战士"},{"id":"90a976545b5488dd75ff7364ad12073f","title":"使用VSCode编辑器debug调试Vue代码","content":"\n\n\n\n\n\n\n\n\n环境为 vue-cli3、webpack、vscode\n首先需要在VSCode中安装 Debugger for Chrome 插件\n\n然后在debug配置中添加如下配置\n\n配置代码\n&#123;\n     &quot;type&quot;: &quot;chrome&quot;,\n     &quot;request&quot;: &quot;launch&quot;,\n     &quot;name&quot;: &quot;vuejs: chrome&quot;,\n     &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&quot;, &#x2F;&#x2F;改成自己的端口就行\n     &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;src&quot;,\n     &quot;breakOnLoad&quot;: true,\n     &quot;sourceMapPathOverrides&quot;: &#123;\n         &quot;webpack:&#x2F;&#x2F;&#x2F;src&#x2F;*&quot;: &quot;$&#123;webRoot&#125;&#x2F;*&quot;\n     &#125;\n&#125;\n\nwebpack的配置\n\n使用vue-cli3的话，在vue.config.js中configureWebpack项中添加以下两个配置\nconfigureWebpack: &#123;\n    devtool: &#39;source-map&#39;,&#x2F;&#x2F; 保证源码正确加载\n&#125;,\n使用其他的方式构建项目，在conf/index.js中修改将devtool: &#39;cheap-module-eval-source-map&#39;修改为devtool: &#39;source-map&#39;\n\n\n","slug":"使用VSCode编辑器debug调试Vue代码","date":"2019-12-25T16:24:33.000Z","categories_index":"vue","tags_index":"","author_index":"打工战士"},{"id":"0fbbceddbe858589d1dc31c9d206fd02","title":"纯Canvas事件按钮点击按下效果","content":"使用纯Canvas实现一个按钮点击按下的效果，类似下图\n\n使用到的API阴影偏移：\n\nshadowOffsetX = float\nshadowOffsetY = float\n用来实现有体积的视觉效果 效果等同于 css中的shadow属性\n\n阴影模糊：\n\nshadowBlur = float\n设置阴影的模糊效果\n\n阴影颜色：\n\nshadowColor = color\n设置阴影的颜色\n\n路径：\n\nbeginPath() \nmoveTo()\nlineTo()\nquadraticCurveTo()\nclosePath()\n以此为 起始一条路径，或重置当前路径、把路径移动到画布中的指定点，不创建线条、    添加一个新点，然后在画布中创建从该点到最后指定点的线条、创建二次贝塞尔曲线、    创建从当前点回到起始点的路径\n\n具体实现：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n\n    &lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;1000&quot; height&#x3D;&quot;800&quot; style&#x3D;&quot;border:1px solid #d3d3d3;&quot;&gt;&lt;&#x2F;canvas&gt;\n\n    &lt;script&gt;\n        var c &#x3D; document.getElementById(&quot;myCanvas&quot;);\n        var ctx &#x3D; c.getContext(&quot;2d&quot;);\n\n        var x &#x3D; 20\n        var y &#x3D; 20\n        var height &#x3D; 100\n        var width &#x3D; 200\n        var radius &#x3D; 5\n\n        &#x2F;&#x2F; 绘制初始状态\n        radiusRect(x, y, width, height, radius, ctx)\n        setShadow(ctx)\n        draw(ctx)\n        cleartShadow(ctx)\n\n        &#x2F;&#x2F; 绘制圆角矩形\n        function radiusRect(x, y, width, height, radius, ctx) &#123;\n            &#x2F;&#x2F; 开启路径\n            ctx.beginPath()\n            &#x2F;&#x2F; 设置填充颜色\n            ctx.fillStyle &#x3D; &quot;#0066CC&quot;\n            &#x2F;&#x2F; 绘制边\n            ctx.moveTo(x, y + radius)\n            ctx.lineTo(x, y + height - radius)\n            &#x2F;&#x2F; 绘制圆角\n            ctx.quadraticCurveTo(x, y + height, x + radius, y + height)\n            ctx.lineTo(x + width - radius, y + height)\n            ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius)\n            ctx.lineTo(x + width, y + radius)\n            ctx.quadraticCurveTo(x + width, y, x + width - radius, y)\n            ctx.lineTo(x + radius, y)\n            ctx.quadraticCurveTo(x, y, x, y + radius)\n            &#x2F;&#x2F; 闭合路径\n            ctx.closePath();\n        &#125;\n\n        &#x2F;&#x2F; 设置阴影和偏移\n        function setShadow(ctx) &#123;\n            ctx.shadowOffsetX &#x3D; 0\n            ctx.shadowOffsetY &#x3D; 10 &#x2F;&#x2F; 10个偏移量\n            ctx.shadowBlur &#x3D; 0\n            ctx.shadowColor &#x3D; &quot;#006600&quot;\n        &#125;\n\n        &#x2F;&#x2F; 清楚掉阴影和位移\n        function cleartShadow(ctx) &#123;\n            ctx.shadowOffsetX &#x3D; 0\n            ctx.shadowOffsetY &#x3D; 0\n        &#125;\n\n        &#x2F;&#x2F; 绘制到画布上\n        function draw(ctx) &#123;\n            ctx.stroke()\n            ctx.fill()\n        &#125;\n\n        &#x2F;&#x2F;事件监听 按下时，持续的绘制为按下状态\n        c.addEventListener(&#39;mousedown&#39;, (e) &#x3D;&gt; &#123;\n            if (e.clientX &gt;&#x3D; x &amp;&amp; e.clientX &lt;&#x3D; x + width &amp;&amp; e.clientY &gt;&#x3D; y &amp;&amp; e.clientY &lt;&#x3D; y + height &amp;&amp; e\n                .button &#x3D;&#x3D; 0) &#123;\n                ctx.clearRect(0, 0, 1000, 1000) &#x2F;&#x2F; 先清楚所有的矩形\n                radiusRect(x, y + 10, width, height, radius, ctx) &#x2F;&#x2F; 10个偏移量\n                draw(ctx)\n\n\n            &#125;\n        &#125;)\n\n        &#x2F;&#x2F;事件监听 抬起时，恢复为初始状态\n        c.addEventListener(&#39;mouseup&#39;, (e) &#x3D;&gt; &#123;\n            if (e.button &#x3D;&#x3D; 0) &#123;\n                setTimeout(() &#x3D;&gt; &#123;\n                    radiusRect(x, y, width, height, radius, ctx)\n                    setShadow(ctx)\n                    draw(ctx)\n                    cleartShadow(ctx)\n                &#125;, 100)\n            &#125;\n        &#125;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n\n","slug":"纯Canvas事件按钮点击按下效果","date":"2019-12-25T16:23:35.000Z","categories_index":"canvas","tags_index":"","author_index":"打工战士"},{"id":"429bc49bea45cd590028e18172e3c7b5","title":"如何跳过SourceTree的注册步骤，直接使用功能（3.2.6亲测有效）","content":"首先在官网上下载 SourceTree 的安装包，我下载的时候最新版本是 3.2.6官方下载链接\n安装好软件后，打开软件会提示必须使用 Bitbuket 的账号才可以登录，我们只需要跳过这一步就可以正常使用其功能，具体步骤为：\n第一步：在文件系统地址栏输入： %LocalAppData%\\Atlassian进入SourceTree目录在该目录创建accounts.json，并写入内容\n [&#123;\n  &quot;$id&quot;: &quot;1&quot;,\n  &quot;$type&quot;: &quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;,\n  &quot;Authenticate&quot;: true,\n  &quot;HostInstance&quot;: &#123;\n    &quot;$id&quot;: &quot;2&quot;,\n    &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;,\n    &quot;Host&quot;: &#123;\n      &quot;$id&quot;: &quot;3&quot;,\n      &quot;$type&quot;: &quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;,\n      &quot;Id&quot;: &quot;atlassian account&quot;\n    &#125;,\n    &quot;BaseUrl&quot;: &quot;https:&#x2F;&#x2F;id.atlassian.com&#x2F;&quot;\n  &#125;,\n  &quot;Credentials&quot;: &#123;\n    &quot;$id&quot;: &quot;4&quot;,\n    &quot;$type&quot;: &quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;,\n    &quot;Username&quot;: &quot;&quot;,\n    &quot;Email&quot;: null\n  &#125;,\n  &quot;IsDefault&quot;: false\n&#125;]\n\n第二步：在文件系统地址栏输入：%LocalAppData%\\Atlassian进入SourceTree.exe_Url_2teh2ti3u00uadewxtjgksiqhpw5qyeh文件夹（根据版本不同，文件夹名称略有不同但前半部是一样的），再次进入名称为版本号的文件夹，这里是3.2.6.3544，打开user.config文件在SourceTree标签中添加代码\n&lt;setting name&#x3D;&quot;AgreedToEULA&quot; serializeAs&#x3D;&quot;String&quot;&gt;\n    &lt;value&gt;True&lt;&#x2F;value&gt;\n&lt;&#x2F;setting&gt;\n&lt;setting name&#x3D;&quot;AgreedToEULAVersion&quot; serializeAs&#x3D;&quot;String&quot;&gt;\n    &lt;value&gt;20160201&lt;&#x2F;value&gt;\n &lt;&#x2F;setting&gt;\n\n第三步：重启软件后就已经跳过了注册/登录的步骤，此时会弹出未检测到mercurial的弹窗，选择第四个不适用mercurial，即可正常使用 SourceTree 的功能了。\n","slug":"如何跳过SourceTree的注册步骤，直接使用功能（3.2.6亲测有效）","date":"2019-11-05T02:03:00.000Z","categories_index":"git","tags_index":"git","author_index":"打工战士"},{"id":"d47195800af9e19545026a7859b4e5f4","title":"使用gitbucket搭建内网私服github服务器","content":"\n\n\n\n\n\n\n\n\ngitbucket是一个使用 Scala 编写运行在 java 虚拟机上的 git 服务器端程序，releases 版提供可直接使用的 war 包，搭建方便，功能对于小公司，小团队来说也都足够。\n环境\ngitbucket 下载地址\njdk8\ntomcat8(非必须)\n\n启动\n下载好 war 包后，使用java -jar gitbucket.war命令进行启动\n\n启动成功后在浏览器输入localhost:8080看到如下页面说明启动成功\n\n使用 root 账户登录，账号：root，密码：root\n\n创建用户\n\n新建仓库后就可以和团队之间进行协作开发了\n\n\n结束以上就是简单的搭建一个gitbucket服务器的全部了，gitbucket除了支持 git 的管理还支持很多特性，如：Issues、PR、wiki、仓库的权限管理等功能，在以后的文章里会专门进行介绍。\n","slug":"使用gitbucket搭建内网私服github服务器","date":"2019-07-21T07:29:48.000Z","categories_index":"git","tags_index":"git,gitbucket","author_index":"打工战士"},{"id":"9f65f9154397f0206bf8e3273761ecef","title":"js运算符优先级记录","content":"最近在系统的重新学习js的知识，看到了优先级的相关资料，以前都没有注意到过的小细节，今天记录一下，如果以后有机会遇到相关的坑也方便找一下。| 优先级        | 运算类型          |  关联性 | 运算符 || ————- |:————-:| —–:| —:||20    |圆括号|    n/a|    ( … )||19    |成员访问    |从左到右    |… . …||19    |需计算的成员访问    |从左到右    |… [ … ]||19    |new (带参数列表)|    n/a|    … . …||18|    new (无参数列表)|    从右到左|    new …||17    |后置递增(运算符在后)|    n/a|    … ++||17    |后置递减(运算符在后)|    n/a    |… –||16    |逻辑非|    从右到左|    ! …||16    |按位非    |从右到左    |~ …||16    |一元加法 |    从右到左|    + …||16    |一元减法    |从右到左|    - …||16    |前置递增    |从右到左|    ++ …||16|    前置递减    |从右到左    |– …||16    |typeof    |从右到左|    typeof …||16    |void    |从右到左    |void …||16|    delete    |从右到左    |delete …||15    |幂    |从右到左    |… ** …||14|    乘法|    从左到由|    … * …||14|    除法|    从左到右    |… / …||14    |取模|    从左到右    |… % …||13    |加法    |从左到右|    … + …||13    |减法|    从左到右    |… - …||12    |按位左移    |从左到右    |… &lt;&lt; …||12    |按位右移    |从左到右    |… &gt;&gt; …||12    |无符号右移    |从左到右    |… &gt;&gt;&gt; …||11    |小于|    从左到右    |… &lt; …||11    |小于等于    |从左到右|    … &lt;= …||11    |大于    |从左到右    |… &gt; …||11    |大于等于    |从左到右|    … &gt;= …||11|    in    |从左到右    |… in …||11    |instanceof    |从左到右    |… instanceof …||10    |等号    |从左到右|    … == …||10    |非等号    |从左到右    |… != …||10|    全等号    |从左到右    |… === …||10    |非全等号    |从左到右    |… !== …||9    |按位与|    从左到右|    … &amp; …||8    |按位异或    |从左到右|    … ^ …||7    |按位或    |从左到右|    …    …||6    |逻辑与    |从左到右|    … &amp;&amp; …||5    |逻辑或    |从左到右|    …        …||4    |条件运算符|    从右到左    |… ? … : …||3    |赋值    |从右到左    |… = …||3    |复合赋值运算符|    |+= …||3    |复合赋值运算符|    |-= …||3    |复合赋值运算符|    |= …||3    |复合赋值运算符|    |/= …||3    |复合赋值运算符|    |%= …||3    |复合赋值运算符|    |&lt;&lt;= …||3    |复合赋值运算符|    |&gt;&gt;= …||3    |复合赋值运算符|    |&gt;&gt;&gt;= …||3    |复合赋值运算符|    |&amp;= …||3    |复合赋值运算符|    |^= …||3    |复合赋值运算符    |    |= …||2    |yield    |从右到左|    yield …||2    |yield    |从右到左    |yield* …||1    |展开运算符|    n/a|    … …||0    |逗号    |从左到右    |… , …|\n","slug":"js运算符优先级记录","date":"2019-06-09T08:11:56.000Z","categories_index":"js","tags_index":"","author_index":"打工战士"},{"id":"1c6f35bdc8ba11e47fd7fdb4a881c294","title":"关于Vue兼容IE10","content":"因为Vue使用了ES6语法，而低版本IE浏览器不支持，解决方法是:使用**babel-polyfill**转换成ES5，具体办法\n\n\n\n\n\n\n\n\n\n这个方法只能支持到**IE9为止的语法兼容**，关于样式的兼容需要另行处理\n\n安装**@babel/polyfill**\n$ npm install --save-dev babel&#x2F;polyfill\n在**packgae.json中找到browserslist**添加\n&quot;browserslist&quot;: [\n   &quot;&gt; 1%&quot;,\n   &quot;last 2 versions&quot;,\n   &quot;not ie &lt;&#x3D; 8&quot;,\n   &quot;ie 8&quot;\n ]\n在**babel.config.js**中添加\nmodule.exports &#x3D; &#123;\n  presets: [\n    [&#39;@vue&#x2F;app&#39;, &#123;\n      useBuiltIns: &#39;entry&#39;\n  &#125;]\n  ]\n&#125;\n在**main.js**中引入\nimport &#39;@babel&#x2F;polyfill&#39;\n然后重启项目，应该就可以正常显示了。\n\n\n\n\n\n\n\n\n\n\n\n这里有两个问题：一个是如果配置了多页面的话，那么在多页面的js入口中都需要引入** import &#39;@babel/polyfill&#39;；第二个是，这里只兼容到了IE10，element-ui表现良好，如果需要兼容到IE9也可以用这个办法，但是IE9没有Flex布局所以element-ui在IE9下布局样式是完全崩溃的，解决办法是使用css3的calc()**函数\n","slug":"关于Vue兼容IE10","date":"2019-04-30T06:09:00.000Z","categories_index":"vue","tags_index":"","author_index":"打工战士"},{"id":"12ed2830258b8dcd4c32cee291a17957","title":"js中的柯里化实现","content":"在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。\n简单的来说柯里化就是把原本多参数的函数，转换成每次只接受一个参数，但是参数可传递的函数链来使用。\n简单的例子\n &#x2F;&#x2F; 柯里化前\nlet plus &#x3D; (a,b) &#x3D;&gt; a + b\nplus(1,2)  &#x2F;&#x2F; 输出：3\n\n &#x2F;&#x2F; 柯里化后\n let plusTwoNum &#x3D; (a,b)&#x3D;&gt; a+b\n let plus &#x3D; fpu.curry(plusTwoNum)\n plus(1)(2) &#x2F;&#x2F; 输出：3\n\n上面是代码是很简单的一个函数柯里化例子，乍一看是没有什么特别的用处的，但是在某些场景是可以发乎很大的用处的，比如说当程序需要运行上面的sum函数，但是参数确实分开获取的，在某一时刻只能获取到其中的一个值a，值b需要一定条件后才能拿到的时候就可以使用柯里化来完美的解决这个问题。\n下面简单说一下柯里化的简单实现（想要支持更复杂的特性，需要自己进行增强）先上代码\n&#x2F;&#x2F; 函数自动柯里化\n&#x2F;&#x2F; eg: new FPUtiles().curry((a,b,c,d) &#x3D;&gt; a+b+c+d)(1)(2)(3)(4)\ncurry(fn)&#123;\n    const _fn &#x3D; (restNum,argList) &#x3D;&gt; restNum &#x3D;&#x3D;&#x3D; 0 ? fn(...argList) : x &#x3D;&gt; _fn(restNum-1,[...argList,x])\n    return _fn(fn.length,[])\n&#125;\n\n下面开始整理思路：\n\n首先curry函数接收一个函数，这个函数是我们真正的处理逻辑的函数\n然后通过闭包，声明一个函数_fn，_fn接收两个参数，一个是真正函数的参数列表长度的计数器，一个是传入参数的列表\n在_fn函数中判断真正函数的参数列表是否等于0，等于0代表参数已经全部都传入进来了，可以调用真正的函数去进行计算，并返回fn函数进行计算然后返回结果；如果参数列表不等于0，则把参数列表的计数器-1，并把传入参数进行合并，然后使用返回_fn函数供尾递归调用。\n\n上面就是柯里化的大体思路，主要实现是依赖闭包和尾递归来实现的，所以在性能上有优化的同时也是有一定的损失，对于性能要求很苛刻的程序可能需要酌情考虑，一般情况下合理使用柯里化是可以把代码的可读性提高很多。\n","slug":"js中的柯里化实现","date":"2019-04-24T06:50:27.000Z","categories_index":"js","tags_index":"","author_index":"打工战士"},{"id":"ca5f7333fd4afa33ba15d97463d47073","title":"VSCode安装使用编程字体FiraCode","content":"FiraCode字体是一个可以把编程中常用的组合符号优化显示的字体\n下面开始在VSCode中的配置\n\n首先在FiraCode的github页面下载字体\n\n把下载的压缩包解压，然后找到ttf文件夹，全部选中，右键安装即可\n\n在VSCode中的配置\n&quot;editor.fontFamily&quot;: &quot;&#39;Fira Code&#39;, Consolas, &#39;Courier New&#39;, monospace&quot;,&#x2F;&#x2F;添加上FiraCode字体\n&quot;editor.fontLigatures&quot;: true,&#x2F;&#x2F;开启连体字\n\n\n\n\n\n\n\n\n\n\n如果配置完后，编辑器的内容没什么变化的话，重启一下就可以了。\n","slug":"VSCode安装使用编程字体FiraCode","date":"2019-04-24T02:21:10.000Z","categories_index":"","tags_index":"","author_index":"打工战士"},{"id":"38463cdb58c9ed519678c1b1d62b6f8a","title":"CocosCreator实现摄像机跟随移动","content":"如果只有一个摄像机的话，在Main Camera上添加脚本\n\n这样的话就可以实现摄像机跟随主角移动而移动\n","slug":"实现摄像机跟随移动","date":"2019-04-07T17:15:48.000Z","categories_index":"游戏开发","tags_index":"游戏开发","author_index":"打工战士"},{"id":"f05f533c1133c025c502733d54123419","title":"Canvas实现文字粒子效果","content":"最终实现效果\n\n实现思路：\n\n\n\n\n\n\n\n\n\n获取到canvas绘制后屏幕上像素点的数组，在目标像素点上绘制粒子替换掉原来的内容\n\n绘制文字\n通过API获取画布的二进制数组\n设置粒子的填充步长\n添加粒子\n循环的遍历粒子，更新粒子的状态\n\n代码实现\n绘制文字 context.textAlign &#x3D; &quot;center&quot;;\ncontext.font &#x3D; this.size + &quot;px arial&quot;;\ncontext.fillText(this.text, this.x, this.y);\n获取二进制数组 let idata &#x3D; context.getImageData(0, 0, canvas.width, canvas.height); &#x2F;&#x2F; 获取 canvas指定范围内的 像素数组\nlet buffer32 &#x3D; new Uint32Array(idata.data.buffer); &#x2F;&#x2F; 转成32位的数组\n\n\n\n\n\n\n\n\n\n这里使用的getImageData()方法是获取画布内所有的像素点的二进制表示，在JS中使用Uint32Array来接收，已数组形式展现，没有渲染的地方数组值是0，有渲染的地方为一个非0的数字\n填充粒子\n&#x2F;&#x2F; 遍历所有的数组 \nfor (var j &#x3D; 0; j &lt; canvas.height; j +&#x3D; gridY) &#123;&#x2F;&#x2F;步长\n  for (var i &#x3D; 0; i &lt; canvas.width; i +&#x3D; gridX) &#123;&#x2F;&#x2F;步长\n      if (buffer32[j * canvas.width + i]) &#123;\n            &#x2F;&#x2F; 放入粒子对象\n            var ball &#x3D; new Particle(i, j);\n            this.placement.push(ball);\n      &#125;\n    &#125;\n &#125;\n\n\n\n\n\n\n\n\n\n这里的意思是在二进制数组中某一个范围内的粒子的密度，其中步长越小越密集\n更新粒子状态\n(function drawFrame() &#123;\n    window.requestAnimationFrame(drawFrame);\n    context.clearRect(0, 0, canvas.width, canvas.height);\n\n    for (var i &#x3D; 0; i &lt; word.placement.length; i++) &#123;\n        &#x2F;&#x2F;调用particle对像的drawParticle方法，开始画布上画\n        word.placement[i].drawParticle();\n    &#125;\n&#125;())\n\nthis.drawParticle &#x3D; function () &#123;\n    &#x2F;&#x2F; 当前粒子变小到一定程度之后，每次将它的半径+0.1，使其慢慢变大\n    if (this.radius &lt; this.futurRadius &amp;&amp; this.dying &#x3D;&#x3D;&#x3D; false) &#123;\n        this.radius +&#x3D; durVal;\n    &#125; else &#123; &#x2F;&#x2F;粒子已经到达最大状态\n        this.dying &#x3D; true; &#x2F;&#x2F;表示粒子还处于show状态\n    &#125;\n\n    &#x2F;&#x2F;每次-0.1\n    if (this.dying) &#123;\n        this.radius -&#x3D; durVal;\n    &#125;\n    &#x2F;&#x2F; 画粒子形状\n    context.save();\n    context.fillStyle &#x3D; this.color;\n    context.beginPath();\n    context.fillRect(this.x, this.y, this.futurRadius, this.futurRadius)\n    context.closePath();\n    context.fill();\n    context.restore();\n\n    &#x2F;&#x2F;将消失的粒子重置最初的状态\n    if (this.y &lt; 0 || this.radius &lt; 1) &#123;\n        this.x &#x3D; this.base[0];\n        this.y &#x3D; this.base[1];\n        this.dying &#x3D; false;\n        this.futurRadius &#x3D; randomInt(1.1, 5.1);\n    &#125;\n&#125;\n\n完整代码\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;canvas id&#x3D;&quot;dir&quot; width&#x3D;&quot;800&quot; height&#x3D;&quot;800&quot; style&#x3D;&quot;border:1px solid #ccc&quot;&gt;\n    &lt;&#x2F;canvas&gt;\n\n    &lt;script&gt;\n        var canvas &#x3D; document.getElementById(&quot;dir&quot;);\n        var context &#x3D; canvas.getContext(&quot;2d&quot;);\n\n        var gridY &#x3D; 10,\n            gridX &#x3D; 10,\n            colors &#x3D; [&#39;#f44336&#39;, &#39;#e91e63&#39;, &#39;#9c27b0&#39;, &#39;#673ab7&#39;, &#39;#3f51b5&#39;,\n                &#39;#2196f3&#39;, &#39;#03a9f4&#39;, &#39;#00bcd4&#39;, &#39;#009688&#39;, &#39;#4CAF50&#39;,\n                &#39;#8BC34A&#39;, &#39;#CDDC39&#39;, &#39;#FFEB3B&#39;, &#39;#FFC107&#39;, &#39;#FF9800&#39;,\n                &#39;#FF5722&#39;\n            ],\n            durVal &#x3D; 0.1;\n\n\n        &#x2F;&#x2F; 粒子\n        function Particle(x, y) &#123;\n            this.x &#x3D; x;\n            this.y &#x3D; y;\n            this.color &#x3D; colors[Math.floor(Math.random() * colors.length)]; &#x2F;&#x2F;&#39;bleack&#39;&#x2F;&#x2F;\n            this.futurRadius &#x3D; randomInt(1.1, 5.1);\n            this.radius &#x3D; 1.1;\n            this.dying &#x3D; false;\n            this.base &#x3D; [x, y];\n\n            this.drawParticle &#x3D; function () &#123;\n\n                &#x2F;&#x2F; 当前粒子变小到一定程度之后，每次将它的半径+0.1，使其慢慢变大\n                if (this.radius &lt; this.futurRadius &amp;&amp; this.dying &#x3D;&#x3D;&#x3D; false) &#123;\n                    this.radius +&#x3D; durVal;\n                &#125; else &#123; &#x2F;&#x2F;粒子已经到达最大状态\n                    this.dying &#x3D; true; &#x2F;&#x2F;表示粒子还处于show状态\n                &#125;\n\n                &#x2F;&#x2F;每次-0.1\n                if (this.dying) &#123;\n                    this.radius -&#x3D; durVal;\n                &#125;\n                &#x2F;&#x2F; 画粒子形状\n                context.save();\n                context.fillStyle &#x3D; this.color;\n                context.beginPath();\n                context.fillRect(this.x, this.y, this.futurRadius, this.futurRadius)\n                context.closePath();\n                context.fill();\n                context.restore();\n\n                &#x2F;&#x2F;将消失的粒子重置最初的状态\n                if (this.y &lt; 0 || this.radius &lt; 1) &#123;\n                    this.x &#x3D; this.base[0];\n                    this.y &#x3D; this.base[1];\n                    this.dying &#x3D; false;\n                    this.futurRadius &#x3D; randomInt(1.1, 5.1);\n                &#125;\n            &#125;\n        &#125;\n\n        function Shape(x, y, texte) &#123;\n            this.x &#x3D; x;\n            this.y &#x3D; y;\n            this.size &#x3D; 200;\n            this.text &#x3D; texte;\n            this.placement &#x3D; [];\n        &#125;\n\n\n        Shape.prototype.getValue &#x3D; function () &#123;\n            context.textAlign &#x3D; &quot;center&quot;;\n            context.font &#x3D; this.size + &quot;px arial&quot;;\n            context.fillText(this.text, this.x, this.y);\n\n            let idata &#x3D; context.getImageData(0, 0, canvas.width, canvas.height); &#x2F;&#x2F; 获取 canvas指定范围内的 像素数组\n            let buffer32 &#x3D; new Uint32Array(idata.data.buffer); &#x2F;&#x2F; 转成32位的数组\n\n            &#x2F;&#x2F; 遍历所有的数组 \n            for (var j &#x3D; 0; j &lt; canvas.height; j +&#x3D; gridY) &#123;\n                for (var i &#x3D; 0; i &lt; canvas.width; i +&#x3D; gridX) &#123;\n                    if (buffer32[j * canvas.width + i]) &#123;\n                        &#x2F;&#x2F; 放入粒子对象\n                        var ball &#x3D; new Particle(i, j);\n                        this.placement.push(ball);\n                    &#125;\n                &#125;\n            &#125;\n\n            context.clearRect(0, 0, canvas.width, canvas.height);\n        &#125;\n\n        function randomInt(min, max) &#123;\n            return min + Math.random() * (max - min + 1);\n        &#125;\n\n        var word &#x3D; new Shape(canvas.width &#x2F; 2, canvas.height &#x2F; 2, &#39;文字粒子&#39;)\n        word.getValue\n\n        (function drawFrame() &#123;\n            window.requestAnimationFrame(drawFrame);\n            context.clearRect(0, 0, canvas.width, canvas.height);\n\n            for (var i &#x3D; 0; i &lt; word.placement.length; i++) &#123;\n                &#x2F;&#x2F;调用particle对像的drawParticle方法，开始画布上画\n                word.placement[i].drawParticle();\n            &#125;\n\n        &#125;())\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n\n\n\n\n","slug":"Canvas实现文字粒子效果","date":"2019-03-29T06:45:12.000Z","categories_index":"canvas","tags_index":"","author_index":"打工战士"},{"id":"6d5ec0ddb13963c47904e9839c9e31d9","title":"git把某本地分支的某次修改修改到其他远程分支","content":"起因\n因为一次手残操作，在没看清分支的情况下把代码写在了一个错误分支上，并且把修改提交到了该分支上。在网上找了很多解决办法都不太好用，最后用下面的这个命令解决了这个问题。\n目标\ngit的修改提交到了不是目标分支的另一个分支上，需要将其修正过来。\n解决\n\n首先切换到本地的错误分支上 git checkout -b [分支]\n\n在错误分支上使用命令 git log 控制台输出\n 复制下需要修改的提交记录的commitedId(红框内的部分)\n\n切换到正常的分支上使用命令 git cherry-pick [commitedId] \n\n如果有冲突，解决冲突之后 git add . git cherry-pick --continue\n\n\n\n\n\n\n\n\n\n\n\n此时可能会出现一个error的报错，暂时还没有研究这个报错的原因，不过好像并没有什么影响，代码已经被更新到正确的分支上了。\n","slug":"git把某本地分支的某次修改修改到其他远程分支","date":"2019-03-28T08:18:56.000Z","categories_index":"git","tags_index":"","author_index":"打工战士"},{"id":"043f9cbe38a0b25b8b616d2a4ca463e9","title":"JavaScript工作原理之事件循环和基础的异步实现","content":"事件循环\n常规的JavaScript引擎是单线程的，也就是说所有的代码块都是顺序按照顺序被执行，这就导致遇到处理慢的代码块会阻塞软件的运行，甚至使程序停止响应，通常解决方案是使用异步来处理，把需要时间处理的代码块异步的进行处理，后面的块则继续执行，等到该代码块处理完以后再回过头来进行结果的处理，但是在ES6前并没有很好的异步解决方案，所以大部分是使用setTimeout来进行处理。下面就通过setTimeout的执行原理来理解一下JavaScript的异步处理的核心机制－－事件循环机制。\n首先看一下JavaScript的运行时模型：\n\nJavaScript引擎部分(例如V8引擎) ，黑框中部分\n\nWebAPIs部分，由宿主环境提供的额外API不属于引擎的原生部分\n\nEventLoop &amp; CallbackQueue 事件循环和回调队列，同样属于宿主环境提供的机制，用于辅助引擎工作\n\n\n\n\n下面基于这个模型，通过定时器来理解一下，JavaScript的事件循环机制以及异步是如何调用的。\n首先写一个基本的定时器\n[图片上传失败…(image-5c33a6-1553756162784)]\n1.代码运行，此时进行代码的解析\n\n2.调用console.log(&#39;HI&#39;) 进入到调用栈中\n\n3.控制台打印Hi\n\n4.解析下一部分代码\n\n5.执行定时器，加入到调用栈中\n\n6.在WebAPIs中创建一个Timer，并将定时器的内容移过去\n\n7.定时器部分执行完毕，弹出调用栈,此时定时器内的内容被保存在WebAPIs环境当中\n\n8.调用console.log(&#39;Bye&#39;) 进入到调用栈中\n\n9.控制台打印Bye\n\n10.console.log(&#39;Bye&#39;)弹出调用栈\n\n11.等待WebAPIs中的timer执行，将cb1加入到回调队列中\n\n12.通过事件循环将回调队列中的cb1重新压入到调用栈中\n\n13.cb1内调用了console.log(&#39;cb1&#39;)所以也要压入到调用栈中\n\n14.控制台打印cb1\n\n15.弹出console.log(&#39;cb1&#39;)\n\n16.弹出cb1\n\n通过对setTimeout的流程解析，很容易发现JavaScript在运行时的调用过程是首先由JS引擎将代码解析编译，然后根据调用顺序加入到调用栈中(栈中的每一项都叫做帧)逐帧执行，其中需要用到WebAPIs、事件循环、回调队列的辅助，最后将执行的结果返回给调用处，至此JavaScript就完成了一次调用的循环。\n基础异步实现\n上面的例子已经使用setTimeout实现了一个基础的异步调用但是需要注意的是，虽然例子中使用的setTimeout(myCallback, 5000);但这并不意味着回调函数会在5秒后立即被执行，而是表示回调方法在5秒后把回调函数添加到回调队列中,如果此时队列中存在待处理任务，那么该回调函数也会相应的被延迟执行。\n所以即使是像下面这个例子一样也依然会是一个异步的调用结果，因为setTimeout的第二个参数仅仅是延迟多久将回调内容放置到回调队列中，而不是确保延迟多久后一定执行。\n\nconsole.log(&#39;Hi&#39;);\n\nsetTimeout(function() &#123;\n\n    console.log(&#39;callback&#39;);\n\n&#125;, 0);\n\nconsole.log(&#39;Bye&#39;);\n\n&#x2F;**输出结果**&#x2F;\n\n&#x2F;&#x2F;Hi\n\n&#x2F;&#x2F;Bye\n\n&#x2F;&#x2F;callback\n","slug":"JavaScript工作原理之事件循环和基础的异步实现","date":"2019-03-28T06:22:44.000Z","categories_index":"js","tags_index":"","author_index":"打工战士"},{"id":"4ed54b66406825cfd09b4a09d07c0870","title":"[转]写好JavaScript条件语句的5条守则","content":"\n\n\n\n\n\n\n\n\n\n原文地址：5 Tips to Write Better Conditionals in JavaScript\n原文作者：ecelyn Yeen(@jecelynyeen)\n译文出自：阿里云翻译小组\n译文链接：https://github.com/dawn-teams/translate/blob/master/articles/5-Tips-to-Write-Better-Conditionals-in-JavaScript.md\n译者：眠云(杨涛)\n校对者：也树，Mcskiller\n\n\n写好JavaScript条件语句的5条守则在用 JavaScript 工作时，我们经常和条件语句打交道，这里有5条让你写出更好/干净的条件语句的建议。\n1.多重判断时使用 Array.includes\n2.更少的嵌套，尽早 return\n3.使用默认参数和解构\n4.倾向于遍历对象而不是 Switch 语句\n5.对 所有/部分 判断使用 Array.every &amp; Array.some\n6.总结\n1.多重判断时使用 Array.includes让我们看一下下面这个例子:\n&#x2F;&#x2F; condition\nfunction test(fruit) &#123;\n  if (fruit &#x3D;&#x3D; &#39;apple&#39; || fruit &#x3D;&#x3D; &#39;strawberry&#39;) &#123;\n    console.log(&#39;red&#39;);\n  &#125;\n&#125;\n\n第一眼，上面这个例子看起来没问题。如果我们有更多名字叫 cherry 和 cranberries 的红色水果呢？我们准备用更多的 || 来拓展条件语句吗？\n我们可以用 Array.includes (Array.includes)重写条件语句。\nfunction test(fruit) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  if (redFruits.includes(fruit)) &#123;\n    console.log(&#39;red&#39;);\n  &#125;\n&#125;\n\n我们把红色的水果(red fruits)这一判断条件提取到一个数组。这样一来，代码看起来更整洁。\n2.更少的嵌套，尽早 Return让我们拓展上一个例子让它包含两个条件。\n\n如果没有传入参数 fruit，抛出错误\n接受 quantity 参数，并且在 quantity 大于 10 时打印出来\n\nfunction test(fruit, quantity) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  &#x2F;&#x2F; 条件 1: fruit 必须有值\n  if (fruit) &#123;\n    &#x2F;&#x2F; 条件 2: 必须是red的\n    if (redFruits.includes(fruit)) &#123;\n      console.log(&#39;red&#39;);\n\n      &#x2F;&#x2F; 条件 3: quantity大于10\n      if (quantity &gt; 10) &#123;\n        console.log(&#39;big quantity&#39;);\n      &#125;\n    &#125;\n  &#125; else &#123;\n    throw new Error(&#39;No fruit!&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 测试结果\ntest(null); &#x2F;&#x2F; error: No fruits\ntest(&#39;apple&#39;); &#x2F;&#x2F; print: red\ntest(&#39;apple&#39;, 20); &#x2F;&#x2F; print: red, big quantity\n\n在上面的代码, 我们有:\n\n1个 if/else 语句筛选出无效的语句\n3层if嵌套语句 (条件 1, 2 &amp; 3)\n\n我个人遵循的规则一般是在发现无效条件时，尽早Return。\n&#x2F;_ 当发现无效语句时，尽早Return _&#x2F;\n\nfunction test(fruit, quantity) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  &#x2F;&#x2F; 条件 1: 尽早抛出错误\n  if (!fruit) throw new Error(&#39;No fruit!&#39;);\n\n  &#x2F;&#x2F; 条件 2: 必须是红色的\n  if (redFruits.includes(fruit)) &#123;\n    console.log(&#39;red&#39;);\n\n    &#x2F;&#x2F; 条件 3: 必须是大质量的\n    if (quantity &gt; 10) &#123;\n      console.log(&#39;big quantity&#39;);\n    &#125;\n  &#125;\n&#125;\n\n\n这样一来，我们少了一层嵌套语句。这种编码风格非常好，尤其是当你有很长的if语句的时候(想象你需要滚动到最底层才知道还有else语句，这并不酷)\n我们可以通过 倒置判断条件 &amp; 尽早return 进一步减少if嵌套。看下面我们是怎么处理判断 条件2 的: \n&#x2F;_ 当发现无效语句时，尽早Return _&#x2F;\n\nfunction test(fruit, quantity) &#123;\n  const redFruits &#x3D; [&#39;apple&#39;, &#39;strawberry&#39;, &#39;cherry&#39;, &#39;cranberries&#39;];\n\n  &#x2F;&#x2F; 条件 1: 尽早抛出错误\n  if (!fruit) throw new Error(&#39;No fruit!&#39;);\n  &#x2F;&#x2F; 条件 2: 当水果不是红色时停止继续执行\n  if (!redFruits.includes(fruit)) return; \n\n  console.log(&#39;red&#39;);\n\n  &#x2F;&#x2F; 条件 3: 必须是大质量的\n  if (quantity &gt; 10) &#123;\n    console.log(&#39;big quantity&#39;);\n  &#125;\n&#125;\n\n通过倒置判断条件2，我们的代码避免了嵌套语句。这个技巧在我们需要进行很长的逻辑判断时是非常有用的，特别是我们希望能够在条件不满足时能够停止下来进行处理。\n而且这么做并不困难。问问自己，这个版本(没有嵌套)是不是比之前的(两层条件嵌套)更好，可读性更高？\n但对于我，我会保留先前的版本(包含两层嵌套)。这是因为:\n\n代码比较短且直接，包含if嵌套的更清晰\n倒置判断条件可能加重思考的负担(增加认知载荷)\n\n因此，应当尽力减少嵌套和尽早return，但不要过度。如果你感兴趣的话，可以看一下关于这个话题的一篇文章和 StackOverflow 上的讨论。\n\nAvoid Else, Return Early by Tim Oxley\nStackOverflow discussion on if/else coding style\n\n3.使用默认参数和解构我猜下面的代码你可能会熟悉，在JavaScript中我们总是需要检查 null / undefined的值和指定默认值:\nfunction test(fruit, quantity) &#123;\n  if (!fruit) return;\n  &#x2F;&#x2F; 如果 quantity 参数没有传入，设置默认值为 1\n  const q &#x3D; quantity || 1; \n\n  console.log(&#96;We have $&#123;q&#125; $&#123;fruit&#125;!&#96;);\n&#125;\n\n&#x2F;&#x2F;test results\ntest(&#39;banana&#39;); &#x2F;&#x2F; We have 1 banana!\ntest(&#39;apple&#39;, 2); &#x2F;&#x2F; We have 2 apple!\n\n实际上，我们可以通过声明 默认函数参数 来消除变量 q。\nfunction test(fruit, quantity &#x3D; 1) &#123;\n  &#x2F;&#x2F; 如果 quantity 参数没有传入，设置默认值为 1\n  if (!fruit) return;\n  console.log(&#96;We have $&#123;quantity&#125; $&#123;fruit&#125;!&#96;);\n&#125;\n\n&#x2F;&#x2F;test results\ntest(&#39;banana&#39;); &#x2F;&#x2F; We have 1 banana!\ntest(&#39;apple&#39;, 2); &#x2F;&#x2F; We have 2 apple!\n\n这更加直观，不是吗？注意，每个声明都有自己的默认参数.\n例如，我们也能给fruit分配默认值:function test(fruit = &#39;unknown&#39;, quantity = 1)。\n如果fruit是一个object会怎么样？我们能分配一个默认参数吗？\nfunction test(fruit) &#123; \n  &#x2F;&#x2F; 当值存在时打印 fruit 的值\n  if (fruit &amp;&amp; fruit.name)  &#123;\n    console.log (fruit.name);\n  &#125; else &#123;\n    console.log(&#39;unknown&#39;);\n  &#125;\n&#125;\n\n&#x2F;&#x2F;test results\ntest(undefined); &#x2F;&#x2F; unknown\ntest(&#123; &#125;); &#x2F;&#x2F; unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); &#x2F;&#x2F; apple\n\n看上面这个例子，我们想打印 fruit 对象中可能存在的 name 属性。否则我们将打印unknown。我们可以通过默认参数以及解构从而避免判断条件 fruit &amp;&amp; fruit.name\n&#x2F;&#x2F; 解构 - 仅仅获取 name 属性\n&#x2F;&#x2F; 为其赋默认值为空对象\nfunction test(&#123;name&#125; &#x3D; &#123;&#125;) &#123;\n  console.log (name || &#39;unknown&#39;);\n&#125;\n\n&#x2F;&#x2F; test results\ntest(undefined); &#x2F;&#x2F; unknown\ntest(&#123; &#125;); &#x2F;&#x2F; unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); &#x2F;&#x2F; apple\n\n由于我们只需要 name 属性，我们可以用 &#123;name&#125; 解构出参数，然后我们就能使用变量 name 代替 fruit.name。\n我们也需要声明空对象 &#123;&#125; 作为默认值。如果我们不这么做，当执行 test(undefined) 时，你将得到一个无法对 undefined 或 null 解构的的错误。因为在 undefined 中没有 name 属性。\n如果你不介意使用第三方库，这有一些方式减少null的检查:\n\n使用 Lodash get函数\n使用Facebook开源的idx库(with Babeljs)\n\n这是一个使用Lodash的例子:\nfunction test(fruit) &#123;\n  &#x2F;&#x2F; 获取属性名，如果属性名不可用，赋默认值为 unknown\n  console.log(__.get(fruit, &#39;name&#39;, &#39;unknown&#39;); \n&#125;\n\n&#x2F;&#x2F; test results\ntest(undefined); &#x2F;&#x2F; unknown\ntest(&#123; &#125;); &#x2F;&#x2F; unknown\ntest(&#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;); &#x2F;&#x2F; apple\n\n你可以在jsbin运行demo代码。除此之外，如果你是函数式编程的粉丝，你可能选择使用 Lodash fp，Lodash的函数式版本(方法变更为get或者getOr)。\n4.倾向于对象遍历而不是Switch语句让我们看下面这个例子，我们想根据 color 打印出水果:\nfunction test(color) &#123;\n  &#x2F;&#x2F; 使用条件语句来寻找对应颜色的水果\n  switch (color) &#123;\n    case &#39;red&#39;:\n      return [&#39;apple&#39;, &#39;strawberry&#39;];\n    case &#39;yellow&#39;:\n      return [&#39;banana&#39;, &#39;pineapple&#39;];\n    case &#39;purple&#39;:\n      return [&#39;grape&#39;, &#39;plum&#39;];\n    default:\n      return [];\n  &#125;\n&#125;\n\n&#x2F;&#x2F; test results\ntest(null); &#x2F;&#x2F; []\ntest(&#39;yellow&#39;); &#x2F;&#x2F; [&#39;banana&#39;, &#39;pineapple&#39;]\n\n上面的代码看起来没有错误，但是我找到了一些累赘。用对象遍历实现相同的结果，语法看起来更简洁:\nconst fruitColor &#x3D; &#123;\n  red: [&#39;apple&#39;, &#39;strawberry&#39;],\n  yellow: [&#39;banana&#39;, &#39;pineapple&#39;],\n  purple: [&#39;grape&#39;, &#39;plum&#39;]\n&#125;;\n\nfunction test(color) &#123;\n  return fruitColor[color] || [];\n&#125;\n\n或者你也可以使用 Map实现相同的结果:\n  const fruitColor &#x3D; new Map()\n    .set(&#39;red&#39;, [&#39;apple&#39;, &#39;strawberry&#39;])\n    .set(&#39;yellow&#39;, [&#39;banana&#39;, &#39;pineapple&#39;])\n    .set(&#39;purple&#39;, [&#39;grape&#39;, &#39;plum&#39;]);\n\nfunction test(color) &#123;\n  return fruitColor.get(color) || [];\n&#125;\n\nMap是一种在 ES2015 规范之后实现的对象类型，允许你存储 key 和 value 的值。\n但我们是否应当禁止switch语句的使用呢？答案是不要限制你自己。从个人来说，我会尽可能的使用对象遍历，但我并不严格遵守它，而是使用对当前的场景更有意义的方式。\nTodd Motto有一篇关于 switch 语句对比对象遍历的更深入的文章，你可以在这个地方阅读\nTL;DR; 重构语法在上面的例子，我们能够用Array.filter 重构我们的代码，实现相同的效果。\n const fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;, \n    &#123; name: &#39;strawberry&#39;, color: &#39;red&#39; &#125;, \n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;, \n    &#123; name: &#39;pineapple&#39;, color: &#39;yellow&#39; &#125;, \n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;, \n    &#123; name: &#39;plum&#39;, color: &#39;purple&#39; &#125;\n];\n\nfunction test(color) &#123;\n  return fruits.filter(f &#x3D;&gt; f.color &#x3D;&#x3D; color);\n&#125;\n\n有着不止一种方法能够实现相同的结果，我们以上展示了 4 种。\n5.对 所有/部分 判断使用Array.every &amp; Array.some这最后一个建议更多是关于利用 JavaScript Array 的内置方法来减少代码行数。看下面的代码，我们想要检查是否所有水果都是红色:\nconst fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n  ];\n\nfunction test() &#123;\n  let isAllRed &#x3D; true;\n\n  &#x2F;&#x2F; 条件：所有水果都是红色\n  for (let f of fruits) &#123;\n    if (!isAllRed) break;\n    isAllRed &#x3D; (f.color &#x3D;&#x3D; &#39;red&#39;);\n  &#125;\n\n  console.log(isAllRed); &#x2F;&#x2F; false\n&#125;\n\n代码那么长！我们可以通过 Array.every减少代码行数:\nconst fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n  ];\n\nfunction test() &#123;\n  const isAllRed &#x3D; fruits.every(f &#x3D;&gt; f.color &#x3D;&#x3D; &#39;red&#39;);\n\n  console.log(isAllRed); &#x2F;&#x2F; false\n&#125;\n\n现在更简洁了，不是吗？相同的方式，如果我们想测试是否存在红色的水果，我们可以使用 Array.some 一行代码实现。\nconst fruits &#x3D; [\n    &#123; name: &#39;apple&#39;, color: &#39;red&#39; &#125;,\n    &#123; name: &#39;banana&#39;, color: &#39;yellow&#39; &#125;,\n    &#123; name: &#39;grape&#39;, color: &#39;purple&#39; &#125;\n];\n\nfunction test() &#123;\n  &#x2F;&#x2F; 条件：任何一个水果是红色\n  const isAnyRed &#x3D; fruits.some(f &#x3D;&gt; f.color &#x3D;&#x3D; &#39;red&#39;);\n\n  console.log(isAnyRed); &#x2F;&#x2F; true\n&#125;\n\n6.总结让我们一起生产更多可读性高的代码。我希望你能从这篇文章学到东西。\n这就是所有的内容。编码快乐！\n","slug":"写好JavaScript条件语句的5条守则(转)","date":"2019-03-28T06:21:57.000Z","categories_index":"js","tags_index":"","author_index":"打工战士"},{"id":"7fb61ad3abf570e620c0abbb8d9991cb","title":"centos安装jdk8","content":"准备\n\n\n\n\n\n\n\n\n\n在 linux 环境下创建一个目录来安装 java如/usr/java\n下载安装文件\nJDK8 官网下载地址\n移动到/usr/java 目录，使用 wget 进行安装，需要先在网页上点击要下载的版本，然后在浏览器的下载内容里把带有带有认证信息的下载链接拷贝出来使用 wget 安装。\n命令如下:\nwget https:&#x2F;&#x2F;download.oracle.com&#x2F;otn-pub&#x2F;java&#x2F;jdk&#x2F;8u191-b12&#x2F;2787e4a523244c269598db4e85c51e0c&#x2F;jdk-8u191-linux-x64.tar.gz?AuthParam&#x3D;1544493195_05ddb141d0fd346fda735fcc6a63f5ba\n\n\n\n\n\n\n\n\n\n\n复制链接这一步速度要快，认证信息有时效\n解压文件\n\n使用 tar zxvf 命令将压缩包解压。\n接完完成后使用 rm -rf 删除掉压缩包。\n\n环境变量的配置\n这一步是把 java 配置到全局的环境变量\n\n使用 vi /etc/profile 打开profile文件\n按 i 进入编辑模式，并调整光标到最后一行\n找一个舒服的位置，把下面的内容拷贝进去，修改路径\n确认没错后按 ESC 输入:wq 保存退出\n使用 source /etc/profile 使环境变量立即生效\n\n配置文件如下:\nexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;dev&#x2F;jdk1.8.0_131 \\\\这里改成自己的路径\nexport JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre\nexport CLASSPATH&#x3D;$JAVA_HOME&#x2F;lib&#x2F;\nexport PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin\n\n最后使用 java -version 和 javac -version 来确认是否安装成功\n","slug":"centos安装jdk8","date":"2019-01-17T08:12:56.000Z","categories_index":"linux","tags_index":"linux,java","author_index":"打工战士"},{"id":"ee7eeb40394fd08cf916793f98d4a3ee","title":"linux安装Mysql5.7","content":"why?\n搞了个百度云服务器，装了CentOS7系统,然后发现升级到 7 以后安装 mysql 和 6 不一样，在网上找了很多资料最后终于装上了，记录一下，留着以后用。\nhow?\n\n\n\n\n\n\n\n\n\n安装的 Mysql 版本为5.7\n下载 yum 源\n官网找到对应的 yum 源 找到Red Hat Enterprise Linux 7 / Oracle Linux 7 (Architecture Independent), RPM Package 点击下载在浏览器下载记录中把下载地址拷贝下来即可。\n下载 yum 的 rpm 包\n首先创建一个目录来放安装文件\ncd &#x2F;usr\n\nmkdir mysql\n\ncd mysql\n\nwget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-11.noarch.rpm\n\n安装 rpm 包\nrpm -ivh mysql57-community-release-el7-11.noarch.rpm\n\n安装 mysql 服务\nyum install -y mysql-server\n\n启动服务\n在 7 中没有 service 命令，所以使用 systemctl 命令\nsystemctl start mysqld\n\n查看初始密码因为 5.7 以后首次安装不允许使用空密码登录，所以会随机生成一个密码，这个密码存放在/var/log/mysqld.log\ncat &#x2F;var&#x2F;log&#x2F;mysqld.log|grep &#39;A temporary password&#39;\n2018-12-11T12:57:59.878904Z 1 [Note] A temporary password is generated for root@localhost: ESkTTaw;k0R&amp;\n&#x2F;&#x2F; 冒号后面的就是初始密码\n\n登录并修改密码\nmysql -u root -p\n\nalter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;your_password&#39;;\n\n修改完密码后，重新登录测试下，就可以使用 Mysql 了\n","slug":"安装Mysql5-7","date":"2019-01-16T05:50:55.000Z","categories_index":"linux","tags_index":"linux,mysql","author_index":"打工战士"}]